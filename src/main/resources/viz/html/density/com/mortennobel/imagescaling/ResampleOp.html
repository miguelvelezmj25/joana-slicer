<html><body><pre><code><div>  /*</div><div>   * Copyright 2013, Morten Nobel-Joergensen</div><div>   *</div><div>   * License: The BSD 3-Clause License</div><div>   * http://opensource.org/licenses/BSD-3-Clause</div><div>   */</div><div>  package com.mortennobel.imagescaling;</div><div>  </div><div>  import java.awt.image.BufferedImage;</div><div>  import java.awt.image.DataBuffer;</div><div>  import java.util.concurrent.atomic.AtomicInteger;</div><div>  </div><div>  /**</div><div>   * Based on work from Java Image Util ( http://schmidt.devlib.org/jiu/ )</div><div>   *</div><div>   * &lt;p&gt;Note that the filter method is not thread safe</div><div>   *</div><div>   * @author Morten Nobel-Joergensen</div><div>   * @author Heinz Doerr</div><div>   */</div><div>* public class ResampleOp extends AdvancedResizeOp {</div><div>*   private final int MAX_CHANNEL_VALUE = 255;</div><div>*   private final AtomicInteger multipleInvocationLock = new AtomicInteger();</div><div>    private int nrChannels;</div><div>    private int srcWidth;</div><div>    private int srcHeight;</div><div>    private int dstWidth;</div><div>    private int dstHeight;</div><div>    private SubSamplingData horizontalSubsamplingData;</div><div>    private SubSamplingData verticalSubsamplingData;</div><div>    private int processedItems;</div><div>    private float totalItems;</div><div>*   private int numberOfThreads = Runtime.getRuntime().availableProcessors();</div><div>*   private ResampleFilter filter = ResampleFilters.getLanczos3Filter();</div><div>  </div><div>    public ResampleOp(int destWidth, int destHeight) {</div><div>*     this(DimensionConstrain.createAbsolutionDimension(destWidth, destHeight));</div><div>    }</div><div>  </div><div>    public ResampleOp(DimensionConstrain dimensionConstrain) {</div><div>*     super(dimensionConstrain);</div><div>    }</div><div>  </div><div>    static SubSamplingData createSubSampling(ResampleFilter filter, int srcSize, int dstSize) {</div><div>*     float scale = (float) dstSize / (float) srcSize;</div><div>*     int[] arrN = new int[dstSize];</div><div>      int numContributors;</div><div>      float[] arrWeight;</div><div>      int[] arrPixel;</div><div>  </div><div>*     final float fwidth = filter.getSamplingRadius();</div><div>  </div><div>*     float centerOffset = 0.5f / scale;</div><div>  </div><div>*     if (scale &lt; 1.0f) {</div><div>*       final float width = fwidth / scale;</div><div>*       numContributors = (int) (width * 2.0f + 2); // Heinz: added 1 to be save with the ceilling</div><div>*       arrWeight = new float[dstSize * numContributors];</div><div>*       arrPixel = new int[dstSize * numContributors];</div><div>  </div><div>*       final float fNormFac = (float) (1f / (Math.ceil(width) / fwidth));</div><div>        //</div><div>*       for (int i = 0; i &lt; dstSize; i++) {</div><div>*         final int subindex = i * numContributors;</div><div>*         float center = i / scale + centerOffset;</div><div>*         int left = (int) Math.floor(center - width);</div><div>*         int right = (int) Math.ceil(center + width);</div><div>*         for (int j = left; j &lt;= right; j++) {</div><div>            float weight;</div><div>*           weight = filter.apply((center - j) * fNormFac);</div><div>  </div><div>*           if (weight == 0.0f) {</div><div>              continue;</div><div>            }</div><div>            int n;</div><div>*           if (j &lt; 0) {</div><div>*             n = -j;</div><div>*           } else if (j &gt;= srcSize) {</div><div>*             n = srcSize - j + srcSize - 1;</div><div>            } else {</div><div>              n = j;</div><div>            }</div><div>*           int k = arrN[i];</div><div>            // assert k == j-left:String.format(&quot;%s = %s %s&quot;, k,j,left);</div><div>*           arrN[i]++;</div><div>*           if (n &lt; 0 || n &gt;= srcSize) {</div><div>              weight = 0.0f; // Flag that cell should not be used</div><div>            }</div><div>*           arrPixel[subindex + k] = n;</div><div>*           arrWeight[subindex + k] = weight;</div><div>          }</div><div>          // normalize the filter&#x27;s weight&#x27;s so the sum equals to 1.0, very important for avoiding box</div><div>          // type of artifacts</div><div>*         final int max = arrN[i];</div><div>          float tot = 0;</div><div>*         for (int k = 0; k &lt; max; k++) tot += arrWeight[subindex + k];</div><div>*         if (tot != 0f) { // 0 should never happen except bug in filter</div><div>*           for (int k = 0; k &lt; max; k++) arrWeight[subindex + k] /= tot;</div><div>          }</div><div>        }</div><div>      } else</div><div>      // super-sampling</div><div>      // Scales from smaller to bigger height</div><div>      {</div><div>*       numContributors = (int) (fwidth * 2.0f + 1);</div><div>*       arrWeight = new float[dstSize * numContributors];</div><div>*       arrPixel = new int[dstSize * numContributors];</div><div>        //</div><div>*       for (int i = 0; i &lt; dstSize; i++) {</div><div>*         final int subindex = i * numContributors;</div><div>*         float center = i / scale + centerOffset;</div><div>*         int left = (int) Math.floor(center - fwidth);</div><div>*         int right = (int) Math.ceil(center + fwidth);</div><div>*         for (int j = left; j &lt;= right; j++) {</div><div>*           float weight = filter.apply(center - j);</div><div>*           if (weight == 0.0f) {</div><div>              continue;</div><div>            }</div><div>            int n;</div><div>*           if (j &lt; 0) {</div><div>*             n = -j;</div><div>*           } else if (j &gt;= srcSize) {</div><div>*             n = srcSize - j + srcSize - 1;</div><div>            } else {</div><div>              n = j;</div><div>            }</div><div>*           int k = arrN[i];</div><div>*           arrN[i]++;</div><div>*           if (n &lt; 0 || n &gt;= srcSize) {</div><div>              weight = 0.0f; // Flag that cell should not be used</div><div>            }</div><div>*           arrPixel[subindex + k] = n;</div><div>*           arrWeight[subindex + k] = weight;</div><div>          }</div><div>          // normalize the filter&#x27;s weight&#x27;s so the sum equals to 1.0, very important for avoiding box</div><div>          // type of artifacts</div><div>*         final int max = arrN[i];</div><div>          float tot = 0;</div><div>*         for (int k = 0; k &lt; max; k++) tot += arrWeight[subindex + k];</div><div>*         assert tot != 0 : &quot;should never happen except bug in filter&quot;;</div><div>*         if (tot != 0f) {</div><div>*           for (int k = 0; k &lt; max; k++) arrWeight[subindex + k] /= tot;</div><div>          }</div><div>        }</div><div>      }</div><div>*     return new SubSamplingData(arrN, arrPixel, arrWeight, numContributors);</div><div>    }</div><div>  </div><div>    public ResampleFilter getFilter() {</div><div>      return filter;</div><div>    }</div><div>  </div><div>    public void setFilter(ResampleFilter filter) {</div><div>*     this.filter = filter;</div><div>    }</div><div>  </div><div>    public int getNumberOfThreads() {</div><div>      return numberOfThreads;</div><div>    }</div><div>  </div><div>    public void setNumberOfThreads(int numberOfThreads) {</div><div>      this.numberOfThreads = numberOfThreads;</div><div>    }</div><div>  </div><div>    public BufferedImage doFilter(</div><div>        BufferedImage srcImg, BufferedImage dest, int dstWidth, int dstHeight) {</div><div>*     this.dstWidth = dstWidth;</div><div>*     this.dstHeight = dstHeight;</div><div>  </div><div>*     if (dstWidth &lt; 3 || dstHeight &lt; 3) {</div><div>*       throw new RuntimeException(</div><div>            &quot;Error doing rescale. Target size was &quot;</div><div>                + dstWidth</div><div>                + &quot;x&quot;</div><div>                + dstHeight</div><div>                + &quot; but must be at least 3x3.&quot;);</div><div>      }</div><div>  </div><div>*     assert multipleInvocationLock.incrementAndGet() == 1</div><div>          : &quot;Multiple concurrent invocations detected&quot;;</div><div>  </div><div>*     if (srcImg.getType() == BufferedImage.TYPE_BYTE_BINARY</div><div>*         || srcImg.getType() == BufferedImage.TYPE_BYTE_INDEXED</div><div>*         || srcImg.getType() == BufferedImage.TYPE_CUSTOM)</div><div>        srcImg =</div><div>*           ImageUtils.convert(</div><div>                srcImg,</div><div>*               srcImg.getColorModel().hasAlpha()</div><div>                    ? BufferedImage.TYPE_4BYTE_ABGR</div><div>                    : BufferedImage.TYPE_3BYTE_BGR);</div><div>  </div><div>*     this.nrChannels = ImageUtils.nrChannels(srcImg);</div><div>*     assert nrChannels &gt; 0;</div><div>*     this.srcWidth = srcImg.getWidth();</div><div>*     this.srcHeight = srcImg.getHeight();</div><div>  </div><div>*     byte[][] workPixels = new byte[srcHeight][dstWidth * nrChannels];</div><div>  </div><div>*     this.processedItems = 0;</div><div>*     this.totalItems = srcHeight + dstWidth;</div><div>  </div><div>      // Pre-calculate  sub-sampling</div><div>*     horizontalSubsamplingData = createSubSampling(filter, srcWidth, dstWidth);</div><div>*     verticalSubsamplingData = createSubSampling(filter, srcHeight, dstHeight);</div><div>  </div><div>      final BufferedImage scrImgCopy = srcImg;</div><div>      final byte[][] workPixelsCopy = workPixels;</div><div>*     Thread[] threads = new Thread[numberOfThreads - 1];</div><div>*     for (int i = 1; i &lt; numberOfThreads; i++) {</div><div>        final int finalI = i;</div><div>*       threads[i - 1] =</div><div>            new Thread(</div><div>*               new Runnable() {</div><div>                  public void run() {</div><div>*                   horizontallyFromSrcToWork(scrImgCopy, workPixelsCopy, finalI, numberOfThreads);</div><div>                  }</div><div>                });</div><div>*       threads[i - 1].start();</div><div>      }</div><div>*     horizontallyFromSrcToWork(scrImgCopy, workPixelsCopy, 0, numberOfThreads);</div><div>*     waitForAllThreads(threads);</div><div>  </div><div>*     byte[] outPixels = new byte[dstWidth * dstHeight * nrChannels];</div><div>      // --------------------------------------------------</div><div>      // Apply filter to sample vertically from Work to Dst</div><div>      // --------------------------------------------------</div><div>      final byte[] outPixelsCopy = outPixels;</div><div>*     for (int i = 1; i &lt; numberOfThreads; i++) {</div><div>        final int finalI = i;</div><div>*       threads[i - 1] =</div><div>            new Thread(</div><div>*               new Runnable() {</div><div>                  public void run() {</div><div>*                   verticalFromWorkToDst(workPixelsCopy, outPixelsCopy, finalI, numberOfThreads);</div><div>                  }</div><div>                });</div><div>*       threads[i - 1].start();</div><div>      }</div><div>*     verticalFromWorkToDst(workPixelsCopy, outPixelsCopy, 0, numberOfThreads);</div><div>*     waitForAllThreads(threads);</div><div>  </div><div>      //noinspection UnusedAssignment</div><div>      workPixels = null; // free memory</div><div>      BufferedImage out;</div><div>*     if (dest != null &amp;&amp; dstWidth == dest.getWidth() &amp;&amp; dstHeight == dest.getHeight()) {</div><div>        out = dest;</div><div>*       int nrDestChannels = ImageUtils.nrChannels(dest);</div><div>*       if (nrDestChannels != nrChannels) {</div><div>*         String errorMgs =</div><div>*             String.format(</div><div>                  &quot;Destination image must be compatible width source image. Source image had %d channels destination image had %d channels&quot;,</div><div>*                 nrChannels, nrDestChannels);</div><div>*         throw new RuntimeException(errorMgs);</div><div>        }</div><div>      } else {</div><div>*       out = new BufferedImage(dstWidth, dstHeight, getResultBufferedImageType(srcImg));</div><div>      }</div><div>  </div><div>*     ImageUtils.setBGRPixels(outPixels, out, 0, 0, dstWidth, dstHeight);</div><div>  </div><div>*     assert multipleInvocationLock.decrementAndGet() == 0</div><div>          : &quot;Multiple concurrent invocations detected&quot;;</div><div>  </div><div>*     return out;</div><div>    }</div><div>  </div><div>    private void waitForAllThreads(Thread[] threads) {</div><div>      try {</div><div>        for (Thread t : threads) {</div><div>          t.join(Long.MAX_VALUE);</div><div>        }</div><div>      } catch (InterruptedException e) {</div><div>        Thread.currentThread().interrupt();</div><div>        throw new RuntimeException(e);</div><div>      }</div><div>    }</div><div>  </div><div>    private void verticalFromWorkToDst(byte[][] workPixels, byte[] outPixels, int start, int delta) {</div><div>*     if (nrChannels == 1) {</div><div>*       verticalFromWorkToDstGray(workPixels, outPixels, start, numberOfThreads);</div><div>        return;</div><div>      }</div><div>*     boolean useChannel3 = nrChannels &gt; 3;</div><div>*     System.out.println(dstWidth);</div><div>*     for (int x = start; x &lt; dstWidth; x += delta) {</div><div>*       final int xLocation = x * nrChannels;</div><div>*       for (int y = dstHeight - 1; y &gt;= 0; y--) {</div><div>*         final int yTimesNumContributors = y * verticalSubsamplingData.numContributors;</div><div>*         final int max = verticalSubsamplingData.arrN[y];</div><div>*         final int sampleLocation = (y * dstWidth + x) * nrChannels;</div><div>  </div><div>          float sample0 = 0.0f;</div><div>          float sample1 = 0.0f;</div><div>          float sample2 = 0.0f;</div><div>          float sample3 = 0.0f;</div><div>          int index = yTimesNumContributors;</div><div>*         for (int j = max - 1; j &gt;= 0; j--) {</div><div>*           int valueLocation = verticalSubsamplingData.arrPixel[index];</div><div>*           float arrWeight = verticalSubsamplingData.arrWeight[index];</div><div>*           sample0 += (workPixels[valueLocation][xLocation] &amp; 0xff) * arrWeight;</div><div>*           sample1 += (workPixels[valueLocation][xLocation + 1] &amp; 0xff) * arrWeight;</div><div>*           sample2 += (workPixels[valueLocation][xLocation + 2] &amp; 0xff) * arrWeight;</div><div>*           if (useChannel3) {</div><div>*             sample3 += (workPixels[valueLocation][xLocation + 3] &amp; 0xff) * arrWeight;</div><div>            }</div><div>  </div><div>*           index++;</div><div>          }</div><div>  </div><div>*         outPixels[sampleLocation] = toByte(sample0);</div><div>*         outPixels[sampleLocation + 1] = toByte(sample1);</div><div>*         outPixels[sampleLocation + 2] = toByte(sample2);</div><div>*         if (useChannel3) {</div><div>*           outPixels[sampleLocation + 3] = toByte(sample3);</div><div>          }</div><div>        }</div><div>*       processedItems++;</div><div>*       if (start == 0) { // only update progress listener from main thread</div><div>*         setProgress();</div><div>        }</div><div>      }</div><div>    }</div><div>  </div><div>    private void verticalFromWorkToDstGray(</div><div>        byte[][] workPixels, byte[] outPixels, int start, int delta) {</div><div>*     for (int x = start; x &lt; dstWidth; x += delta) {</div><div>        final int xLocation = x;</div><div>*       for (int y = dstHeight - 1; y &gt;= 0; y--) {</div><div>*         final int yTimesNumContributors = y * verticalSubsamplingData.numContributors;</div><div>*         final int max = verticalSubsamplingData.arrN[y];</div><div>*         final int sampleLocation = (y * dstWidth + x);</div><div>  </div><div>          float sample0 = 0.0f;</div><div>          int index = yTimesNumContributors;</div><div>*         for (int j = max - 1; j &gt;= 0; j--) {</div><div>*           int valueLocation = verticalSubsamplingData.arrPixel[index];</div><div>*           float arrWeight = verticalSubsamplingData.arrWeight[index];</div><div>*           sample0 += (workPixels[valueLocation][xLocation] &amp; 0xff) * arrWeight;</div><div>  </div><div>*           index++;</div><div>          }</div><div>  </div><div>*         outPixels[sampleLocation] = toByte(sample0);</div><div>        }</div><div>*       processedItems++;</div><div>*       if (start == 0) { // only update progress listener from main thread</div><div>*         setProgress();</div><div>        }</div><div>      }</div><div>    }</div><div>  </div><div>    /**</div><div>     * Apply filter to sample horizontally from Src to Work</div><div>     *</div><div>     * @param srcImg</div><div>     * @param workPixels</div><div>     */</div><div>    private void horizontallyFromSrcToWork(</div><div>        BufferedImage srcImg, byte[][] workPixels, int start, int delta) {</div><div>*     if (nrChannels == 1) {</div><div>*       horizontallyFromSrcToWorkGray(srcImg, workPixels, start, delta);</div><div>        return;</div><div>      }</div><div>*     final int[] tempPixels =</div><div>          new int</div><div>              [srcWidth]; // Used if we work on int based bitmaps, later used to keep channel values</div><div>*     final byte[] srcPixels =</div><div>          new byte[srcWidth * nrChannels]; // create reusable row to minimize memory overhead</div><div>*     final boolean useChannel3 = nrChannels &gt; 3;</div><div>  </div><div>*     for (int k = start; k &lt; srcHeight; k = k + delta) {</div><div>*       ImageUtils.getPixelsBGR(srcImg, k, srcWidth, srcPixels, tempPixels);</div><div>  </div><div>*       for (int i = dstWidth - 1; i &gt;= 0; i--) {</div><div>*         int sampleLocation = i * nrChannels;</div><div>*         final int max = horizontalSubsamplingData.arrN[i];</div><div>  </div><div>          float sample0 = 0.0f;</div><div>          float sample1 = 0.0f;</div><div>          float sample2 = 0.0f;</div><div>          float sample3 = 0.0f;</div><div>*         int index = i * horizontalSubsamplingData.numContributors;</div><div>*         for (int j = max - 1; j &gt;= 0; j--) {</div><div>*           float arrWeight = horizontalSubsamplingData.arrWeight[index];</div><div>*           int pixelIndex = horizontalSubsamplingData.arrPixel[index] * nrChannels;</div><div>  </div><div>*           sample0 += (srcPixels[pixelIndex] &amp; 0xff) * arrWeight;</div><div>*           sample1 += (srcPixels[pixelIndex + 1] &amp; 0xff) * arrWeight;</div><div>*           sample2 += (srcPixels[pixelIndex + 2] &amp; 0xff) * arrWeight;</div><div>*           if (useChannel3) {</div><div>*             sample3 += (srcPixels[pixelIndex + 3] &amp; 0xff) * arrWeight;</div><div>            }</div><div>*           index++;</div><div>          }</div><div>  </div><div>*         workPixels[k][sampleLocation] = toByte(sample0);</div><div>*         workPixels[k][sampleLocation + 1] = toByte(sample1);</div><div>*         workPixels[k][sampleLocation + 2] = toByte(sample2);</div><div>*         if (useChannel3) {</div><div>*           workPixels[k][sampleLocation + 3] = toByte(sample3);</div><div>          }</div><div>        }</div><div>*       processedItems++;</div><div>*       if (start == 0) { // only update progress listener from main thread</div><div>*         setProgress();</div><div>        }</div><div>      }</div><div>    }</div><div>  </div><div>    /**</div><div>     * Apply filter to sample horizontally from Src to Work</div><div>     *</div><div>     * @param srcImg</div><div>     * @param workPixels</div><div>     */</div><div>    private void horizontallyFromSrcToWorkGray(</div><div>        BufferedImage srcImg, byte[][] workPixels, int start, int delta) {</div><div>*     final int[] tempPixels =</div><div>          new int</div><div>              [srcWidth]; // Used if we work on int based bitmaps, later used to keep channel values</div><div>*     final byte[] srcPixels = new byte[srcWidth]; // create reusable row to minimize memory overhead</div><div>  </div><div>*     for (int k = start; k &lt; srcHeight; k = k + delta) {</div><div>*       ImageUtils.getPixelsBGR(srcImg, k, srcWidth, srcPixels, tempPixels);</div><div>  </div><div>*       for (int i = dstWidth - 1; i &gt;= 0; i--) {</div><div>          int sampleLocation = i;</div><div>*         final int max = horizontalSubsamplingData.arrN[i];</div><div>  </div><div>          float sample0 = 0.0f;</div><div>*         int index = i * horizontalSubsamplingData.numContributors;</div><div>*         for (int j = max - 1; j &gt;= 0; j--) {</div><div>*           float arrWeight = horizontalSubsamplingData.arrWeight[index];</div><div>*           int pixelIndex = horizontalSubsamplingData.arrPixel[index];</div><div>  </div><div>*           sample0 += (srcPixels[pixelIndex] &amp; 0xff) * arrWeight;</div><div>*           index++;</div><div>          }</div><div>  </div><div>*         workPixels[k][sampleLocation] = toByte(sample0);</div><div>        }</div><div>*       processedItems++;</div><div>*       if (start == 0) { // only update progress listener from main thread</div><div>*         setProgress();</div><div>        }</div><div>      }</div><div>    }</div><div>  </div><div>    private byte toByte(float f) {</div><div>*     if (f &lt; 0) {</div><div>*       return 0;</div><div>      }</div><div>*     if (f &gt; MAX_CHANNEL_VALUE) {</div><div>*       return (byte) MAX_CHANNEL_VALUE;</div><div>      }</div><div>*     return (byte) (f + 0.5f); // add 0.5 same as Math.round</div><div>    }</div><div>  </div><div>    private void setProgress() {</div><div>*     fireProgressChanged(processedItems / totalItems);</div><div>    }</div><div>  </div><div>    protected int getResultBufferedImageType(BufferedImage srcImg) {</div><div>*     return nrChannels == 3</div><div>          ? BufferedImage.TYPE_3BYTE_BGR</div><div>          : (nrChannels == 4</div><div>              ? BufferedImage.TYPE_4BYTE_ABGR</div><div>*             : (srcImg.getSampleModel().getDataType() == DataBuffer.TYPE_USHORT</div><div>                  ? BufferedImage.TYPE_USHORT_GRAY</div><div>                  : BufferedImage.TYPE_BYTE_GRAY));</div><div>    }</div><div>  </div><div>*   static class SubSamplingData {</div><div>      private final int[] arrN; // individual - per row or per column - nr of contributions</div><div>      private final int[] arrPixel; // 2Dim: [wid or hei][contrib]</div><div>      private final float[] arrWeight; // 2Dim: [wid or hei][contrib]</div><div>      private final int</div><div>          numContributors; // the primary index length for the 2Dim arrays : arrPixel and arrWeight</div><div>  </div><div>      private SubSamplingData(int[] arrN, int[] arrPixel, float[] arrWeight, int numContributors) {</div><div>*       this.arrN = arrN;</div><div>*       this.arrPixel = arrPixel;</div><div>*       this.arrWeight = arrWeight;</div><div>*       this.numContributors = numContributors;</div><div>      }</div><div>  </div><div>      public int getNumContributors() {</div><div>        return numContributors;</div><div>      }</div><div>  </div><div>      public int[] getArrN() {</div><div>        return arrN;</div><div>      }</div><div>  </div><div>      public int[] getArrPixel() {</div><div>        return arrPixel;</div><div>      }</div><div>  </div><div>      public float[] getArrWeight() {</div><div>        return arrWeight;</div><div>      }</div><div>    }</div><div>  }</div></code></pre></body></html>