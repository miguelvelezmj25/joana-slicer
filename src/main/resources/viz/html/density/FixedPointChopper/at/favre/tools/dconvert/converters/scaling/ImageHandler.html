<html><body style="font-size:16px;width:1000px;"><pre><code><div> /*</div><div>  *  Copyright 2016 Patrick Favre-Bulle</div><div>  *</div><div>  *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</div><div>  *  you may not use this file except in compliance with the License.</div><div>  *  You may obtain a copy of the License at</div><div>  *</div><div>  *      http://www.apache.org/licenses/LICENSE-2.0</div><div>  *</div><div>  * Unless required by applicable law or agreed to in writing, software</div><div>  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</div><div>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div>  * See the License for the specific language governing permissions and</div><div>  * limitations under the License.</div><div>  */</div><div> </div><div> package at.favre.tools.dconvert.converters.scaling;</div><div> </div><div> import at.favre.tools.dconvert.arg.Arguments;</div><div> import at.favre.tools.dconvert.arg.EScalingAlgorithm;</div><div> import at.favre.tools.dconvert.arg.ImageType;</div><div> import at.favre.tools.dconvert.util.LoadedImage;</div><div> import at.favre.tools.dconvert.util.MiscUtil;</div><div> import at.favre.tools.dconvert.util.NinePatchScaler;</div><div> import com.twelvemonkeys.imageio.metadata.CompoundDirectory;</div><div> </div><div> import javax.imageio.IIOImage;</div><div> import javax.imageio.ImageIO;</div><div> import javax.imageio.ImageWriteParam;</div><div> import javax.imageio.ImageWriter;</div><div> import javax.imageio.stream.FileImageOutputStream;</div><div> import javax.imageio.stream.ImageOutputStream;</div><div> import java.awt.*;</div><div> import java.awt.image.BufferedImage;</div><div> import java.awt.image.ConvolveOp;</div><div> import java.awt.image.Kernel;</div><div> import java.io.File;</div><div> import java.io.IOException;</div><div> import java.util.List;</div><div> import java.util.*;</div><div> </div><div> /** Handles scaling and writing/compression images to disk */</div><div> public class ImageHandler {</div><div>   public static final boolean TEST_MODE = false;</div><div>   public static final ConvolveOp OP_ANTIALIAS =</div><div>       new ConvolveOp(</div><div>           new Kernel(3, 3, new float[] {.0f, .08f, .0f, .08f, .68f, .08f, .0f, .08f, .0f}),</div><div>           ConvolveOp.EDGE_NO_OP,</div><div>           null);</div><div>   private static final Color DEFAULT_COLOR = Color.white;</div><div>   public static Map&lt;ScaleAlgorithm, Long&gt; traceMap = new HashMap&lt;ScaleAlgorithm, Long&gt;();</div><div>   private final Arguments args;</div><div> </div><div>   public ImageHandler(Arguments args) {</div><div style="background-color:MediumSpringGreen;">     this.args = args;</div><div>   }</div><div> </div><div>   public List&lt;File&gt; saveToFile(</div><div>       File targetFile, LoadedImage imageData, Dimension targetDimension, boolean isNinePatch)</div><div>       throws Exception {</div><div> </div><div>     List&lt;File&gt; files = new ArrayList&lt;File&gt;(2);</div><div>     List&lt;ImageType.ECompression&gt; compressionList =</div><div>         Arguments.getOutCompressionForType(</div><div>             args.outputCompressionMode, Arguments.getImageType(imageData.getSourceFile()));</div><div style="background-color:MediumSpringGreen;">     for (ImageType.ECompression compression : compressionList) {</div><div style="background-color:MediumSpringGreen;">       File imageFile = new File(targetFile.getAbsolutePath() + &quot;.&quot; + compression.extension);</div><div> </div><div style="background-color:MediumSpringGreen;">       if (imageFile.exists() &amp;&amp; args.skipExistingFiles) {</div><div>         break;</div><div>       }</div><div> </div><div>       List&lt;ScaleAlgorithm&gt; algorithms =</div><div style="background-color:MediumSpringGreen;">           getScaleAlgorithm(</div><div style="background-color:MediumSpringGreen;">               getScalingAlgorithm(getScalingType(imageData, targetDimension)),</div><div>               getScalingType(imageData, targetDimension));</div><div> </div><div style="background-color:MediumSpringGreen;">       for (ScaleAlgorithm scaleAlgorithm : algorithms) {</div><div> </div><div>         if (!traceMap.containsKey(scaleAlgorithm)) {</div><div>           traceMap.put(scaleAlgorithm, 0L);</div><div>         }</div><div> </div><div>         BufferedImage scaledImage;</div><div style="background-color:MediumSpringGreen;">         if (isNinePatch &amp;&amp; compression == ImageType.ECompression.PNG) {</div><div style="background-color:MediumSpringGreen;">           scaledImage =</div><div>               new NinePatchScaler()</div><div style="background-color:MediumSpringGreen;">                   .scale(</div><div style="background-color:MediumSpringGreen;">                       imageData.getImage(),</div><div>                       targetDimension,</div><div>                       getAsScalingAlgorithm(scaleAlgorithm, compression));</div><div>         } else {</div><div>           long startNanos = System.nanoTime();</div><div>           scaledImage =</div><div style="background-color:MediumSpringGreen;">               scale(</div><div>                   scaleAlgorithm,</div><div style="background-color:MediumSpringGreen;">                   imageData.getImage(),</div><div>                   targetDimension.width,</div><div>                   targetDimension.height,</div><div>                   compression,</div><div>                   DEFAULT_COLOR);</div><div>           traceMap.put(</div><div>               scaleAlgorithm, traceMap.get(scaleAlgorithm) + (System.nanoTime() - startNanos));</div><div>         }</div><div> </div><div>         File fileToSave = imageFile;</div><div> </div><div>         if (algorithms.size() &gt; 1) {</div><div>           fileToSave =</div><div>               new File(</div><div>                   imageFile.getParentFile(),</div><div>                   MiscUtil.getFileNameWithoutExtension(imageFile)</div><div>                       + &quot;.&quot;</div><div>                       + scaleAlgorithm.toString()</div><div>                       + &quot;.&quot;</div><div>                       + MiscUtil.getFileExtension(imageFile));</div><div>         }</div><div> </div><div>         if (compression == ImageType.ECompression.JPG) {</div><div style="background-color:MediumSpringGreen;">           compressJpeg(scaledImage, null, args.compressionQuality, fileToSave);</div><div>         } else {</div><div>           ImageIO.write(scaledImage, compression.name().toLowerCase(), fileToSave);</div><div>         }</div><div>         scaledImage.flush();</div><div>         files.add(imageFile);</div><div>       }</div><div>     }</div><div>     return files;</div><div>   }</div><div> </div><div>   public void compressJpeg(</div><div>       BufferedImage bufferedImage, CompoundDirectory exif, float quality, File targetFile)</div><div>       throws IOException {</div><div style="background-color:MediumSpringGreen;">     if (bufferedImage.hasTileWriters()) {</div><div>       ImageWriter jpgWriter = ImageIO.getImageWritersByFormatName(&quot;jpg&quot;).next();</div><div>       ImageWriteParam jpgWriteParam = jpgWriter.getDefaultWriteParam();</div><div>       jpgWriteParam.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);</div><div>       jpgWriteParam.setCompressionQuality(quality);</div><div> </div><div>       ImageWriter writer = null;</div><div>       try {</div><div>         ImageOutputStream outputStream = new FileImageOutputStream(targetFile);</div><div>         writer = ImageIO.getImageWritersByFormatName(&quot;jpg&quot;).next();</div><div>         writer.setOutput(outputStream);</div><div style="background-color:MediumSpringGreen;">         writer.write(null, new IIOImage(bufferedImage, null, null), jpgWriteParam);</div><div>         outputStream.close();</div><div>       } finally {</div><div>         if (writer != null) writer.dispose();</div><div>       }</div><div>     }</div><div>   }</div><div> </div><div>   private EScalingAlgorithm getScalingAlgorithm(EScalingAlgorithm.Type type) {</div><div style="background-color:MediumSpringGreen;">     return type == EScalingAlgorithm.Type.UPSCALING</div><div>         ? args.upScalingAlgorithm</div><div>         : args.downScalingAlgorithm;</div><div>   }</div><div> </div><div>   private EScalingAlgorithm.Type getScalingType(LoadedImage imageData, Dimension targetDimension) {</div><div style="background-color:MediumSpringGreen;">     long targetSize = targetDimension.height * targetDimension.width;</div><div style="background-color:MediumSpringGreen;">     long sourceSize = imageData.getImage().getHeight() * imageData.getImage().getWidth();</div><div style="background-color:MediumSpringGreen;">     return targetSize &gt;= sourceSize</div><div>         ? EScalingAlgorithm.Type.UPSCALING</div><div>         : EScalingAlgorithm.Type.DOWNSCALING;</div><div>   }</div><div> </div><div>   private List&lt;ScaleAlgorithm&gt; getScaleAlgorithm(</div><div>       EScalingAlgorithm algorithm, EScalingAlgorithm.Type type) {</div><div>     if (TEST_MODE) {</div><div>       List&lt;ScaleAlgorithm&gt; algos = new ArrayList&lt;ScaleAlgorithm&gt;();</div><div>       for (EScalingAlgorithm eScalingAlgorithm : EScalingAlgorithm.getAllEnabled()) {</div><div>         if (eScalingAlgorithm.getSupportedForType().contains(type)) {</div><div>           algos.add(eScalingAlgorithm.getImplementation());</div><div>         }</div><div>       }</div><div>       return algos;</div><div>       //      return EScalingAlgorithm.getAllEnabled().stream()</div><div>       //          .filter(eScalingAlgorithm -&gt;</div><div>       // eScalingAlgorithm.getSupportedForType().contains(type))</div><div>       //          .map(EScalingAlgorithm::getImplementation)</div><div>       //          .collect(Collectors.toList());</div><div>     } else {</div><div style="background-color:MediumSpringGreen;">       return Collections.singletonList(algorithm.getImplementation());</div><div>     }</div><div>   }</div><div> </div><div>   public BufferedImage scale(</div><div>       ScaleAlgorithm scaleAlgorithm,</div><div>       BufferedImage imageToScale,</div><div>       int dWidth,</div><div>       int dHeight,</div><div>       ImageType.ECompression compression,</div><div>       Color background) {</div><div> </div><div>     BufferedImage scaledImage;</div><div> </div><div style="background-color:MediumSpringGreen;">     if (dWidth == imageToScale.getWidth() &amp;&amp; dHeight == imageToScale.getHeight()) {</div><div>       scaledImage = imageToScale;</div><div>     } else {</div><div style="background-color:MediumSpringGreen;">       scaledImage = scaleAlgorithm.scale(imageToScale, dWidth, dHeight);</div><div>     }</div><div> </div><div style="background-color:MediumSpringGreen;">     if (!compression.hasTransparency) {</div><div style="background-color:MediumSpringGreen;">       BufferedImage convertedImg =</div><div>           new BufferedImage(</div><div>               scaledImage.getWidth(), scaledImage.getHeight(), BufferedImage.TYPE_INT_RGB);</div><div>       convertedImg.getGraphics().drawImage(scaledImage, 0, 0, background, null);</div><div>       scaledImage = convertedImg;</div><div>     }</div><div> </div><div style="background-color:MediumSpringGreen;">     if (args.enableAntiAliasing) {</div><div style="background-color:MediumSpringGreen;">       scaledImage = OP_ANTIALIAS.filter(scaledImage, null);</div><div>     }</div><div> </div><div style="background-color:MediumSpringGreen;">     return scaledImage;</div><div>   }</div><div> </div><div>   private ScaleAlgorithm getAsScalingAlgorithm(</div><div>       final ScaleAlgorithm algorithm, ImageType.ECompression compression) {</div><div>     throw new UnsupportedOperationException(&quot;Java 1.6&quot;);</div><div>     //    return (imageToScale, dWidth, dHeight) -&gt;</div><div>     //        ImageHandler.this.scale(</div><div>     //            algorithm, imageToScale, dWidth, dHeight, compression, DEFAULT_COLOR);</div><div>   }</div><div> }</div></code></pre></body></html>