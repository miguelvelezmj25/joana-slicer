<html><body style="font-size:16px;width:1000px;"><pre><code><div> /*</div><div>  *  Copyright 2016 Patrick Favre-Bulle</div><div>  *</div><div>  *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</div><div>  *  you may not use this file except in compliance with the License.</div><div>  *  You may obtain a copy of the License at</div><div>  *</div><div>  *      http://www.apache.org/licenses/LICENSE-2.0</div><div>  *</div><div>  * Unless required by applicable law or agreed to in writing, software</div><div>  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</div><div>  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div>  * See the License for the specific language governing permissions and</div><div>  * limitations under the License.</div><div>  */</div><div> </div><div> package at.favre.tools.dconvert.util;</div><div> </div><div> import at.favre.tools.dconvert.converters.scaling.ScaleAlgorithm;</div><div> import at.favre.tools.dconvert.converters.scaling.ThumbnailnatorProgressiveAlgorithm;</div><div> import at.favre.tools.dconvert.exceptions.NinePatchException;</div><div> </div><div> import java.awt.*;</div><div> import java.awt.image.BufferedImage;</div><div> </div><div> /**</div><div>  * Scales 9-patches correctly, keeping the 1px border intact.</div><div>  *</div><div>  * &lt;p&gt;Adapted from &lt;a</div><div>  * href=&quot;https://github.com/redwarp/9-Patch-Resizer/blob/develop/src/net/redwarp/tool/resizer/worker/ImageScaler.java&quot;&gt;Github&lt;/a&gt;</div><div>  *</div><div>  * @author Redwarp, pfavre</div><div>  */</div><div> public class NinePatchScaler {</div><div> </div><div>   private ScaleAlgorithm algorithm;</div><div>   private final ScaleAlgorithm borderScalerAlgorithm =</div><div>       new ThumbnailnatorProgressiveAlgorithm(RenderingHints.VALUE_INTERPOLATION_BILINEAR);</div><div> </div><div>   public BufferedImage scale(</div><div>       BufferedImage inputImage, Dimension dimensions, ScaleAlgorithm algorithm)</div><div>       throws NinePatchException {</div><div>     this.algorithm = algorithm;</div><div style="background-color:MediumSpringGreen;">     BufferedImage trimmedImage = this.trim9PBorder(inputImage);</div><div> </div><div style="background-color:MediumSpringGreen;">     trimmedImage = algorithm.scale(trimmedImage, dimensions.width, dimensions.height);</div><div> </div><div>     BufferedImage borderImage;</div><div> </div><div style="background-color:MediumSpringGreen;">     int w = trimmedImage.getWidth();</div><div style="background-color:MediumSpringGreen;">     int h = trimmedImage.getHeight();</div><div> </div><div style="background-color:MediumSpringGreen;">     borderImage = this.generateBordersImage(inputImage, w, h);</div><div> </div><div style="background-color:MediumSpringGreen;">     int[] rgbArray = new int[w * h];</div><div>     trimmedImage.getRGB(0, 0, w, h, rgbArray, 0, w);</div><div style="background-color:MediumSpringGreen;">     borderImage.setRGB(1, 1, w, h, rgbArray, 0, w);</div><div>     rgbArray = null;</div><div> </div><div>     return borderImage;</div><div>   }</div><div> </div><div>   private BufferedImage trim9PBorder(BufferedImage inputImage) {</div><div>     BufferedImage trimedImage =</div><div>         new BufferedImage(</div><div style="background-color:MediumSpringGreen;">             inputImage.getWidth() - 2, inputImage.getHeight() - 2, BufferedImage.TYPE_INT_ARGB);</div><div style="background-color:MediumSpringGreen;">     Graphics2D g = trimedImage.createGraphics();</div><div>     g.drawImage(</div><div>         inputImage,</div><div>         0,</div><div>         0,</div><div>         trimedImage.getWidth(),</div><div>         trimedImage.getHeight(),</div><div>         1,</div><div>         1,</div><div>         inputImage.getWidth() - 1,</div><div>         inputImage.getHeight() - 1,</div><div>         null);</div><div>     g.dispose();</div><div>     return trimedImage;</div><div>   }</div><div> </div><div>   private void enforceBorderColors(BufferedImage inputImage) {</div><div>     Graphics2D g = inputImage.createGraphics();</div><div>     g.setBackground(new Color(0, 0, 0, 0));</div><div>     g.clearRect(1, 1, inputImage.getWidth() - 2, inputImage.getHeight() - 2);</div><div>     g.dispose();</div><div>     int w = inputImage.getWidth();</div><div>     int h = inputImage.getHeight();</div><div>     int[] rgb = new int[w * h];</div><div> </div><div>     inputImage.getRGB(0, 0, w, h, rgb, 0, w);</div><div> </div><div>     for (int i = 0; i &lt; rgb.length; i++) {</div><div>       if ((0xff000000 &amp; rgb[i]) != 0) {</div><div>         rgb[i] = 0xff000000;</div><div>       }</div><div>     }</div><div>     inputImage.setRGB(0, 0, w, h, rgb, 0, w);</div><div>     inputImage.setRGB(0, 0, 0x0);</div><div>     inputImage.setRGB(0, h - 1, 0x0);</div><div>     inputImage.setRGB(w - 1, h - 1, 0x0);</div><div>     inputImage.setRGB(w - 1, 0, 0x0);</div><div>   }</div><div> </div><div>   private BufferedImage generateBordersImage(</div><div>       BufferedImage source, int trimedWidth, int trimedHeight) throws NinePatchException {</div><div style="background-color:MediumSpringGreen;">     BufferedImage finalBorder =</div><div>         new BufferedImage(trimedWidth + 2, trimedHeight + 2, BufferedImage.TYPE_INT_ARGB);</div><div style="background-color:MediumSpringGreen;">     int cutW = source.getWidth() - 2;</div><div style="background-color:MediumSpringGreen;">     int cutH = source.getHeight() - 2;</div><div>     // left border</div><div style="background-color:MediumSpringGreen;">     BufferedImage leftBorder = new BufferedImage(1, cutH, BufferedImage.TYPE_INT_ARGB);</div><div style="background-color:MediumSpringGreen;">     leftBorder.setRGB(0, 0, 1, cutH, source.getRGB(0, 1, 1, cutH, null, 0, 1), 0, 1);</div><div style="background-color:MediumSpringGreen;">     this.verifyBorderImage(leftBorder);</div><div style="background-color:MediumSpringGreen;">     leftBorder = this.resizeBorder(leftBorder, 1, trimedHeight);</div><div style="background-color:MediumSpringGreen;">     finalBorder.setRGB(</div><div style="background-color:MediumSpringGreen;">         0, 1, 1, trimedHeight, leftBorder.getRGB(0, 0, 1, trimedHeight, null, 0, 1), 0, 1);</div><div>     // right border</div><div style="background-color:MediumSpringGreen;">     BufferedImage rightBorder = new BufferedImage(1, cutH, BufferedImage.TYPE_INT_ARGB);</div><div style="background-color:MediumSpringGreen;">     rightBorder.setRGB(0, 0, 1, cutH, source.getRGB(cutW + 1, 1, 1, cutH, null, 0, 1), 0, 1);</div><div style="background-color:MediumSpringGreen;">     this.verifyBorderImage(rightBorder);</div><div style="background-color:MediumSpringGreen;">     rightBorder = this.resizeBorder(rightBorder, 1, trimedHeight);</div><div style="background-color:MediumSpringGreen;">     finalBorder.setRGB(</div><div>         trimedWidth + 1,</div><div>         1,</div><div>         1,</div><div>         trimedHeight,</div><div style="background-color:MediumSpringGreen;">         rightBorder.getRGB(0, 0, 1, trimedHeight, null, 0, 1),</div><div>         0,</div><div>         1);</div><div>     // top border</div><div style="background-color:MediumSpringGreen;">     BufferedImage topBorder = new BufferedImage(cutW, 1, BufferedImage.TYPE_INT_ARGB);</div><div style="background-color:MediumSpringGreen;">     topBorder.setRGB(0, 0, cutW, 1, source.getRGB(1, 0, cutW, 1, null, 0, cutW), 0, cutW);</div><div style="background-color:MediumSpringGreen;">     this.verifyBorderImage(topBorder);</div><div style="background-color:MediumSpringGreen;">     topBorder = this.resizeBorder(topBorder, trimedWidth, 1);</div><div style="background-color:MediumSpringGreen;">     finalBorder.setRGB(</div><div>         1,</div><div>         0,</div><div>         trimedWidth,</div><div>         1,</div><div style="background-color:MediumSpringGreen;">         topBorder.getRGB(0, 0, trimedWidth, 1, null, 0, trimedWidth),</div><div>         0,</div><div>         trimedWidth);</div><div>     // bottom border</div><div style="background-color:MediumSpringGreen;">     BufferedImage bottomBorder = new BufferedImage(cutW, 1, BufferedImage.TYPE_INT_ARGB);</div><div style="background-color:MediumSpringGreen;">     bottomBorder.setRGB(0, 0, cutW, 1, source.getRGB(1, cutH + 1, cutW, 1, null, 0, cutW), 0, cutW);</div><div style="background-color:MediumSpringGreen;">     this.verifyBorderImage(bottomBorder);</div><div style="background-color:MediumSpringGreen;">     bottomBorder = this.resizeBorder(bottomBorder, trimedWidth, 1);</div><div style="background-color:MediumSpringGreen;">     finalBorder.setRGB(</div><div>         1,</div><div>         trimedHeight + 1,</div><div>         trimedWidth,</div><div>         1,</div><div style="background-color:MediumSpringGreen;">         bottomBorder.getRGB(0, 0, trimedWidth, 1, null, 0, trimedWidth),</div><div>         0,</div><div>         trimedWidth);</div><div> </div><div>     return finalBorder;</div><div>   }</div><div> </div><div>   private BufferedImage resizeBorder(</div><div>       final BufferedImage border, int targetWidth, int targetHeight) {</div><div>     if (targetWidth &gt; border.getWidth() || targetHeight &gt; border.getHeight()) {</div><div>       BufferedImage endImage = borderScalerAlgorithm.scale(border, targetWidth, targetHeight);</div><div>       this.enforceBorderColors(endImage);</div><div>       return endImage;</div><div>     }</div><div> </div><div style="background-color:MediumSpringGreen;">     int w = border.getWidth();</div><div style="background-color:MediumSpringGreen;">     int h = border.getHeight();</div><div style="background-color:MediumSpringGreen;">     int[] data = border.getRGB(0, 0, w, h, null, 0, w);</div><div style="background-color:MediumSpringGreen;">     int[] newData = new int[targetWidth * targetHeight];</div><div> </div><div style="background-color:MediumSpringGreen;">     float widthRatio = (float) Math.max(targetWidth - 1, 1) / (float) Math.max(w - 1, 1);</div><div style="background-color:MediumSpringGreen;">     float heightRatio = (float) Math.max(targetHeight - 1, 1) / (float) Math.max(h - 1, 1);</div><div> </div><div>     for (int y = 0; y &lt; h; y++) {</div><div>       for (int x = 0; x &lt; w; x++) {</div><div>         if ((0xff000000 &amp; data[y * w + x]) != 0) {</div><div style="background-color:MediumSpringGreen;">           int newX = Math.min(Math.round(x * widthRatio), targetWidth - 1);</div><div style="background-color:MediumSpringGreen;">           int newY = Math.min(Math.round(y * heightRatio), targetHeight - 1);</div><div> </div><div style="background-color:MediumSpringGreen;">           newData[newY * targetWidth + newX] = data[y * w + x];</div><div>         }</div><div>       }</div><div>     }</div><div> </div><div style="background-color:MediumSpringGreen;">     BufferedImage img = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_ARGB);</div><div style="background-color:MediumSpringGreen;">     img.setRGB(0, 0, targetWidth, targetHeight, newData, 0, targetWidth);</div><div> </div><div>     return img;</div><div>   }</div><div> </div><div>   private void verifyBorderImage(BufferedImage border) throws NinePatchException {</div><div>     int[] rgb =</div><div style="background-color:MediumSpringGreen;">         border.getRGB(0, 0, border.getWidth(), border.getHeight(), null, 0, border.getWidth());</div><div>     for (int i = 0; i &lt; rgb.length; i++) {</div><div>       if ((0xff000000 &amp; rgb[i]) != 0) {</div><div>         if (rgb[i] != 0xff000000 &amp;&amp; rgb[i] != 0xffff0000) {</div><div>           throw new NinePatchException();</div><div>         }</div><div>       }</div><div>     }</div><div>   }</div><div> }</div></code></pre></body></html>