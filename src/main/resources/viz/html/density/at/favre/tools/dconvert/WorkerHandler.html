<html><body><pre><code><div>  /*</div><div>   *  Copyright 2016 Patrick Favre-Bulle</div><div>   *</div><div>   *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</div><div>   *  you may not use this file except in compliance with the License.</div><div>   *  You may obtain a copy of the License at</div><div>   *</div><div>   *      http://www.apache.org/licenses/LICENSE-2.0</div><div>   *</div><div>   * Unless required by applicable law or agreed to in writing, software</div><div>   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</div><div>   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div>   * See the License for the specific language governing permissions and</div><div>   * limitations under the License.</div><div>   */</div><div>  </div><div>  package at.favre.tools.dconvert;</div><div>  </div><div>  import at.favre.tools.dconvert.arg.Arguments;</div><div>  import at.favre.tools.dconvert.converters.IPlatformConverter;</div><div>  import at.favre.tools.dconvert.converters.Result;</div><div>  import at.favre.tools.dconvert.converters.postprocessing.IPostProcessor;</div><div>  </div><div>  import java.io.File;</div><div>  import java.util.ArrayList;</div><div>  import java.util.List;</div><div>  import java.util.concurrent.ArrayBlockingQueue;</div><div>  import java.util.concurrent.ExecutorService;</div><div>  import java.util.concurrent.ThreadPoolExecutor;</div><div>  import java.util.concurrent.TimeUnit;</div><div>  </div><div>  /** Handles post processing tasks */</div><div>* public class WorkerHandler&lt;T&gt; {</div><div>  </div><div>    private final List&lt;T&gt; processors;</div><div>    private final ExecutorService threadPool;</div><div>    private final Arguments arguments;</div><div>    private final Callback callback;</div><div>    private int jobCount;</div><div>  </div><div>    public WorkerHandler(List&lt;T&gt; processors, Arguments arguments, Callback callback) {</div><div>*     this.processors = processors;</div><div>*     this.threadPool =</div><div>          new ThreadPoolExecutor(</div><div>              arguments.threadCount,</div><div>              arguments.threadCount,</div><div>              5,</div><div>              TimeUnit.SECONDS,</div><div>              new ArrayBlockingQueue&lt;Runnable&gt;(1024 * 10));</div><div>*     this.callback = callback;</div><div>*     this.arguments = arguments;</div><div>    }</div><div>  </div><div>    public void start(List&lt;File&gt; allFiles) {</div><div>*     this.jobCount = allFiles.size() * processors.size();</div><div>  </div><div>*     InternalCallback internalCallback = new InternalCallback(callback);</div><div>  </div><div>*     for (T processor : processors) {</div><div>*       for (File fileToProcess : allFiles) {</div><div>*         threadPool.execute(new Worker(fileToProcess, processor, arguments, internalCallback));</div><div>        }</div><div>      }</div><div>  </div><div>*     threadPool.shutdown();</div><div>  </div><div>*     if (jobCount == 0) {</div><div>*       callback.onFinished(</div><div>            0, new ArrayList&lt;File&gt;(), new StringBuilder(), new ArrayList&lt;Exception&gt;(), false);</div><div>      }</div><div>    }</div><div>  </div><div>    public interface Callback {</div><div>      void onProgress(float percent);</div><div>  </div><div>      void onFinished(</div><div>          int finishedJobs,</div><div>          List&lt;File&gt; outFiles,</div><div>          StringBuilder log,</div><div>          List&lt;Exception&gt; exceptions,</div><div>          boolean haltedDuringProcess);</div><div>    }</div><div>  </div><div>    private class Worker implements Runnable {</div><div>      private final Arguments arguments;</div><div>      private final File unprocessedFile;</div><div>      private final T processor;</div><div>      private final InternalCallback callback;</div><div>  </div><div>      public Worker(</div><div>*         File unprocessedFile, T processors, Arguments arguments, InternalCallback callback) {</div><div>*       this.unprocessedFile = unprocessedFile;</div><div>*       this.arguments = arguments;</div><div>*       this.processor = processors;</div><div>*       this.callback = callback;</div><div>      }</div><div>  </div><div>      @Override</div><div>      public void run() {</div><div>        Result result = null;</div><div>*       if (processor instanceof IPostProcessor) {</div><div>*         result =</div><div>              ((IPostProcessor) processor)</div><div>*                 .process(unprocessedFile, arguments.keepUnoptimizedFilesPostProcessor);</div><div>*       } else if (processor instanceof IPlatformConverter) {</div><div>*         result = ((IPlatformConverter) processor).convert(unprocessedFile, arguments);</div><div>        }</div><div>*       callback.onJobFinished(result);</div><div>      }</div><div>    }</div><div>  </div><div>    private class InternalCallback {</div><div>*     private final List&lt;Exception&gt; exceptionList = new ArrayList&lt;Exception&gt;();</div><div>      private final Callback callback;</div><div>*     private final StringBuilder logBuilder = new StringBuilder();</div><div>*     private final List&lt;File&gt; files = new ArrayList&lt;File&gt;();</div><div>*     private int currentJobCount = 0;</div><div>*     private boolean canceled = false;</div><div>  </div><div>*     public InternalCallback(Callback callback) {</div><div>*       this.callback = callback;</div><div>      }</div><div>  </div><div>      synchronized void onJobFinished(Result result) {</div><div>*       if (!canceled) {</div><div>*         currentJobCount++;</div><div>  </div><div>*         if (result != null) {</div><div>*           if (result.log != null &amp;&amp; result.log.length() &gt; 0) {</div><div>*             logBuilder.append(result.log).append(&quot;\n&quot;);</div><div>            }</div><div>*           if (result.processedFiles != null) {</div><div>*             files.addAll(result.processedFiles);</div><div>            }</div><div>*           if (result.exception != null) {</div><div>*             exceptionList.add(result.exception);</div><div>  </div><div>*             if (arguments.haltOnError) {</div><div>*               canceled = true;</div><div>*               threadPool.shutdownNow();</div><div>*               callback.onFinished(currentJobCount, files, logBuilder, exceptionList, true);</div><div>              }</div><div>            }</div><div>          }</div><div>  </div><div>*         if (!canceled) {</div><div>*           if (currentJobCount == jobCount) {</div><div>*             callback.onFinished(currentJobCount, files, logBuilder, exceptionList, false);</div><div>            } else {</div><div>*             callback.onProgress((float) currentJobCount / (float) jobCount);</div><div>            }</div><div>          }</div><div>        }</div><div>      }</div><div>    }</div><div>  }</div></code></pre></body></html>