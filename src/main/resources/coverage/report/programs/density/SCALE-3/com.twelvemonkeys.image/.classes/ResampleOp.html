


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ResampleOp</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.twelvemonkeys.image</a> ]
</div>

<h1>Coverage Summary for Class: ResampleOp (com.twelvemonkeys.image)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ResampleOp</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 392)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ResampleOp$BlackmanBesselFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$BlackmanSincFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$BlacmanFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$BoxFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$CatromFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$Contributor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$ContributorList</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$CubicFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$GaussianFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$HammingFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$HanningFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$HermiteFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$Key</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$LanczosFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$MitchellFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$PointFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$QuadraticFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$TriangleFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResampleOp$Value</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 79)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 497)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2008, Harald Kuhr
<i>3</i>&nbsp; * All rights reserved.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; * Redistribution and use in source and binary forms, with or without
<i>6</i>&nbsp; * modification, are permitted provided that the following conditions are met:
<i>7</i>&nbsp; *
<i>8</i>&nbsp; * * Redistributions of source code must retain the above copyright notice, this
<i>9</i>&nbsp; *   list of conditions and the following disclaimer.
<i>10</i>&nbsp; *
<i>11</i>&nbsp; * * Redistributions in binary form must reproduce the above copyright notice,
<i>12</i>&nbsp; *   this list of conditions and the following disclaimer in the documentation
<i>13</i>&nbsp; *   and/or other materials provided with the distribution.
<i>14</i>&nbsp; *
<i>15</i>&nbsp; * * Neither the name of the copyright holder nor the names of its
<i>16</i>&nbsp; *   contributors may be used to endorse or promote products derived from
<i>17</i>&nbsp; *   this software without specific prior written permission.
<i>18</i>&nbsp; *
<i>19</i>&nbsp; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
<i>20</i>&nbsp; * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<i>21</i>&nbsp; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
<i>22</i>&nbsp; * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
<i>23</i>&nbsp; * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
<i>24</i>&nbsp; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
<i>25</i>&nbsp; * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
<i>26</i>&nbsp; * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
<i>27</i>&nbsp; * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<i>28</i>&nbsp; * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<i>29</i>&nbsp; */
<i>30</i>&nbsp;/*
<i>31</i>&nbsp; *******************************************************************************
<i>32</i>&nbsp; *
<i>33</i>&nbsp; *  Based on example code found in Graphics Gems III, Filtered Image Rescaling
<i>34</i>&nbsp; *  (filter_rcg.c), available from http://www.acm.org/tog/GraphicsGems/.
<i>35</i>&nbsp; *
<i>36</i>&nbsp; *  Public Domain 1991 by Dale Schumacher. Mods by Ray Gardener
<i>37</i>&nbsp; *
<i>38</i>&nbsp; *  Original by Dale Schumacher (fzoom)
<i>39</i>&nbsp; *
<i>40</i>&nbsp; *  Additional changes by Ray Gardener, Daylon Graphics Ltd.
<i>41</i>&nbsp; *  December 4, 1999
<i>42</i>&nbsp; *
<i>43</i>&nbsp; *******************************************************************************
<i>44</i>&nbsp; *
<i>45</i>&nbsp; *  Aditional changes inspired by ImageMagick&#39;s resize.c.
<i>46</i>&nbsp; *
<i>47</i>&nbsp; *******************************************************************************
<i>48</i>&nbsp; *
<i>49</i>&nbsp; *  Java port and additional changes/bugfixes by Harald Kuhr, Twelvemonkeys.
<i>50</i>&nbsp; *  February 20, 2006
<i>51</i>&nbsp; *
<i>52</i>&nbsp; *******************************************************************************
<i>53</i>&nbsp; */
<i>54</i>&nbsp;
<i>55</i>&nbsp;package com.twelvemonkeys.image;
<i>56</i>&nbsp;
<i>57</i>&nbsp;import java.awt.*;
<i>58</i>&nbsp;import java.awt.geom.AffineTransform;
<i>59</i>&nbsp;import java.awt.geom.Point2D;
<i>60</i>&nbsp;import java.awt.geom.Rectangle2D;
<i>61</i>&nbsp;import java.awt.image.*;
<i>62</i>&nbsp;
<i>63</i>&nbsp;/**
<i>64</i>&nbsp; * Resamples (scales) a {@code BufferedImage} to a new width and height, using
<i>65</i>&nbsp; * high performance and high quality algorithms.
<i>66</i>&nbsp; * Several different interpolation algorithms may be specifed in the
<i>67</i>&nbsp; * constructor, either using the
<i>68</i>&nbsp; * &lt;a href=&quot;#field_summary&quot;&gt;filter type constants&lt;/a&gt;, or one of the
<i>69</i>&nbsp; * {@code RendereingHints}.
<i>70</i>&nbsp; * &lt;p/&gt;
<i>71</i>&nbsp; * For fastest results, use {@link #FILTER_POINT} or {@link #FILTER_BOX}.
<i>72</i>&nbsp; * In most cases, {@link #FILTER_TRIANGLE} will produce acceptable results, while
<i>73</i>&nbsp; * being relatively fast.
<i>74</i>&nbsp; * For higher quality output, use more sophisticated interpolation algorithms,
<i>75</i>&nbsp; * like {@link #FILTER_MITCHELL} or {@link #FILTER_LANCZOS}.
<i>76</i>&nbsp; * &lt;p/&gt;
<i>77</i>&nbsp; * Example:
<i>78</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>79</i>&nbsp; * BufferedImage image;
<i>80</i>&nbsp; * &lt;p/&gt;
<i>81</i>&nbsp; * //...
<i>82</i>&nbsp; * &lt;p/&gt;
<i>83</i>&nbsp; * ResampleOp resampler = new ResampleOp(100, 100, ResampleOp.FILTER_TRIANGLE);
<i>84</i>&nbsp; * BufferedImage thumbnail = resampler.filter(image, null);
<i>85</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>86</i>&nbsp; * &lt;p/&gt;
<i>87</i>&nbsp; * If your imput image is very large, it&#39;s possible to first resample using the
<i>88</i>&nbsp; * very fast {@code FILTER_POINT} algorithm, then resample to the wanted size,
<i>89</i>&nbsp; * using a higher quality algorithm:
<i>90</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>91</i>&nbsp; * BufferedImage verylLarge;
<i>92</i>&nbsp; * &lt;p/&gt;
<i>93</i>&nbsp; * //...
<i>94</i>&nbsp; * &lt;p/&gt;
<i>95</i>&nbsp; * int w = 300;
<i>96</i>&nbsp; * int h = 200;
<i>97</i>&nbsp; * &lt;p/&gt;
<i>98</i>&nbsp; * BufferedImage temp = new ResampleOp(w * 2, h * 2, FILTER_POINT).filter(verylLarge, null);
<i>99</i>&nbsp; * &lt;p/&gt;
<i>100</i>&nbsp; * BufferedImage scaled = new ResampleOp(w, h).filter(temp, null);
<i>101</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>102</i>&nbsp; * &lt;p/&gt;
<i>103</i>&nbsp; * For maximum performance, this class will use native code, through
<i>104</i>&nbsp; * &lt;a href=&quot;http://www.yeo.id.au/jmagick/&quot;&gt;JMagick&lt;/a&gt;, when available.
<i>105</i>&nbsp; * Otherwise, the class will silently fall back to pure Java mode.
<i>106</i>&nbsp; * Native code may be disabled globally, by setting the system property
<i>107</i>&nbsp; * {@code com.twelvemonkeys.image.accel} to {@code false}.
<i>108</i>&nbsp; * To allow debug of the native code, set the system property
<i>109</i>&nbsp; * {@code com.twelvemonkeys.image.magick.debug} to {@code true}.
<i>110</i>&nbsp; * &lt;p/&gt;
<i>111</i>&nbsp; * This {@code BufferedImageOp} is based on C example code found in
<i>112</i>&nbsp; * &lt;a href=&quot;http://www.acm.org/tog/GraphicsGems/&quot;&gt;Graphics Gems III&lt;/a&gt;,
<i>113</i>&nbsp; * Filtered Image Rescaling, by Dale Schumacher (with additional improvments by
<i>114</i>&nbsp; * Ray Gardener).
<i>115</i>&nbsp; * Additional changes are inspired by
<i>116</i>&nbsp; * &lt;a href=&quot;http://www.imagemagick.org/&quot;&gt;ImageMagick&lt;/a&gt; and
<i>117</i>&nbsp; * Marco Schmidt&#39;s &lt;a href=&quot;http://schmidt.devlib.org/jiu/&quot;&gt;Java Imaging Utilities&lt;/a&gt;
<i>118</i>&nbsp; * (which are also adaptions of the same original code from Graphics Gems III).
<i>119</i>&nbsp; * &lt;p/&gt;
<i>120</i>&nbsp; * For a description of the various interpolation algorithms, see
<i>121</i>&nbsp; * &lt;em&gt;General Filtered Image Rescaling&lt;/em&gt; in &lt;em&gt;Graphics Gems III&lt;/em&gt;,
<i>122</i>&nbsp; * Academic Press, 1994.
<i>123</i>&nbsp; *
<i>124</i>&nbsp; * @author &lt;a href=&quot;mailto:harald.kuhr@gmail.com&quot;&gt;Harald Kuhr&lt;/a&gt;
<i>125</i>&nbsp; * @author last modified by $Author: haku $
<i>126</i>&nbsp; * @version $Id: //depot/branches/personal/haraldk/twelvemonkeys/release-2/twelvemonkeys-core/src/main/java/com/twelvemonkeys/image/ResampleOp.java#1 $
<i>127</i>&nbsp; * @see #ResampleOp(int,int,int)
<i>128</i>&nbsp; * @see #ResampleOp(int,int, RenderingHints)
<i>129</i>&nbsp; * @see BufferedImage
<i>130</i>&nbsp; * @see RenderingHints
<i>131</i>&nbsp; * @see AffineTransformOp
<i>132</i>&nbsp; */
<i>133</i>&nbsp;// TODO: Consider using AffineTransformOp for more operations!?
<b class="nc"><i>134</i>&nbsp;public class ResampleOp implements BufferedImageOp/* TODO: RasterOp */ {</b>
<i>135</i>&nbsp;
<i>136</i>&nbsp;    // NOTE: These MUST correspond to ImageMagick filter types, for the
<i>137</i>&nbsp;    // MagickAccelerator to work consistently (see magick.FilterType).
<i>138</i>&nbsp;
<i>139</i>&nbsp;    /**
<i>140</i>&nbsp;     * Undefined interpolation, filter method will use default filter.
<i>141</i>&nbsp;     */
<i>142</i>&nbsp;    public final static int FILTER_UNDEFINED = 0;
<i>143</i>&nbsp;    /**
<i>144</i>&nbsp;     * Point interpolation (also known as &quot;nearest neighbour&quot;).
<i>145</i>&nbsp;     * Very fast, but low quality
<i>146</i>&nbsp;     * (similar to {@link RenderingHints#VALUE_INTERPOLATION_NEAREST_NEIGHBOR}
<i>147</i>&nbsp;     * and {@link Image#SCALE_REPLICATE}).
<i>148</i>&nbsp;     */
<i>149</i>&nbsp;    public final static int FILTER_POINT = 1;
<i>150</i>&nbsp;    /**
<i>151</i>&nbsp;     * Box interpolation. Fast, but low quality.
<i>152</i>&nbsp;     */
<i>153</i>&nbsp;    public final static int FILTER_BOX = 2;
<i>154</i>&nbsp;    /**
<i>155</i>&nbsp;     * Triangle interpolation (also known as &quot;linear&quot; or &quot;bilinear&quot;).
<i>156</i>&nbsp;     * Quite fast, with acceptable quality
<i>157</i>&nbsp;     * (similar to {@link RenderingHints#VALUE_INTERPOLATION_BILINEAR} and
<i>158</i>&nbsp;     * {@link Image#SCALE_AREA_AVERAGING}).
<i>159</i>&nbsp;     */
<i>160</i>&nbsp;    public final static int FILTER_TRIANGLE = 3;
<i>161</i>&nbsp;    /**
<i>162</i>&nbsp;     * Hermite interpolation.
<i>163</i>&nbsp;     */
<i>164</i>&nbsp;    public final static int FILTER_HERMITE = 4;
<i>165</i>&nbsp;    /**
<i>166</i>&nbsp;     * Hanning interpolation.
<i>167</i>&nbsp;     */
<i>168</i>&nbsp;    public final static int FILTER_HANNING = 5;
<i>169</i>&nbsp;    /**
<i>170</i>&nbsp;     * Hamming interpolation.
<i>171</i>&nbsp;     */
<i>172</i>&nbsp;    public final static int FILTER_HAMMING = 6;
<i>173</i>&nbsp;    /**
<i>174</i>&nbsp;     * Blackman interpolation..
<i>175</i>&nbsp;     */
<i>176</i>&nbsp;    public final static int FILTER_BLACKMAN = 7;
<i>177</i>&nbsp;    /**
<i>178</i>&nbsp;     * Gaussian interpolation.
<i>179</i>&nbsp;     */
<i>180</i>&nbsp;    public final static int FILTER_GAUSSIAN = 8;
<i>181</i>&nbsp;    /**
<i>182</i>&nbsp;     * Quadratic interpolation.
<i>183</i>&nbsp;     */
<i>184</i>&nbsp;    public final static int FILTER_QUADRATIC = 9;
<i>185</i>&nbsp;    /**
<i>186</i>&nbsp;     * Cubic interpolation.
<i>187</i>&nbsp;     */
<i>188</i>&nbsp;    public final static int FILTER_CUBIC = 10;
<i>189</i>&nbsp;    /**
<i>190</i>&nbsp;     * Catrom interpolation.
<i>191</i>&nbsp;     */
<i>192</i>&nbsp;    public final static int FILTER_CATROM = 11;
<i>193</i>&nbsp;    /**
<i>194</i>&nbsp;     * Mitchell interpolation. High quality.
<i>195</i>&nbsp;     */
<i>196</i>&nbsp;    public final static int FILTER_MITCHELL = 12; // IM default scale with palette or alpha, or scale up
<i>197</i>&nbsp;    /**
<i>198</i>&nbsp;     * Lanczos interpolation. High quality.
<i>199</i>&nbsp;     */
<i>200</i>&nbsp;    public final static int FILTER_LANCZOS = 13; // IM default
<i>201</i>&nbsp;    /**
<i>202</i>&nbsp;     * Blackman-Bessel interpolation. High quality.
<i>203</i>&nbsp;     */
<i>204</i>&nbsp;    public final static int FILTER_BLACKMAN_BESSEL = 14;
<i>205</i>&nbsp;    /**
<i>206</i>&nbsp;     * Blackman-Sinc interpolation. High quality.
<i>207</i>&nbsp;     */
<i>208</i>&nbsp;    public final static int FILTER_BLACKMAN_SINC = 15;
<i>209</i>&nbsp;
<i>210</i>&nbsp;    /**
<i>211</i>&nbsp;     * RenderingHints.Key specifying resampling interpolation algorithm.
<i>212</i>&nbsp;     */
<b class="nc"><i>213</i>&nbsp;    public final static RenderingHints.Key KEY_RESAMPLE_INTERPOLATION = new Key(&quot;ResampleInterpolation&quot;);</b>
<i>214</i>&nbsp;
<i>215</i>&nbsp;    /**
<i>216</i>&nbsp;     * @see #FILTER_POINT
<i>217</i>&nbsp;     */
<b class="nc"><i>218</i>&nbsp;    public final static Object VALUE_INTERPOLATION_POINT =</b>
<i>219</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Point&quot;, FILTER_POINT);
<i>220</i>&nbsp;    /**
<i>221</i>&nbsp;     * @see #FILTER_BOX
<i>222</i>&nbsp;     */
<b class="nc"><i>223</i>&nbsp;    public final static Object VALUE_INTERPOLATION_BOX =</b>
<i>224</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Box&quot;, FILTER_BOX);
<i>225</i>&nbsp;    /**
<i>226</i>&nbsp;     * @see #FILTER_TRIANGLE
<i>227</i>&nbsp;     */
<b class="nc"><i>228</i>&nbsp;    public final static Object VALUE_INTERPOLATION_TRIANGLE =</b>
<i>229</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Triangle&quot;, FILTER_TRIANGLE);
<i>230</i>&nbsp;    /**
<i>231</i>&nbsp;     * @see #FILTER_HERMITE
<i>232</i>&nbsp;     */
<b class="nc"><i>233</i>&nbsp;    public final static Object VALUE_INTERPOLATION_HERMITE =</b>
<i>234</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Hermite&quot;, FILTER_HERMITE);
<i>235</i>&nbsp;    /**
<i>236</i>&nbsp;     * @see #FILTER_HANNING
<i>237</i>&nbsp;     */
<b class="nc"><i>238</i>&nbsp;    public final static Object VALUE_INTERPOLATION_HANNING =</b>
<i>239</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Hanning&quot;, FILTER_HANNING);
<i>240</i>&nbsp;    /**
<i>241</i>&nbsp;     * @see #FILTER_HAMMING
<i>242</i>&nbsp;     */
<b class="nc"><i>243</i>&nbsp;    public final static Object VALUE_INTERPOLATION_HAMMING =</b>
<i>244</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Hamming&quot;, FILTER_HAMMING);
<i>245</i>&nbsp;    /**
<i>246</i>&nbsp;     * @see #FILTER_BLACKMAN
<i>247</i>&nbsp;     */
<b class="nc"><i>248</i>&nbsp;    public final static Object VALUE_INTERPOLATION_BLACKMAN =</b>
<i>249</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Blackman&quot;, FILTER_BLACKMAN);
<i>250</i>&nbsp;    /**
<i>251</i>&nbsp;     * @see #FILTER_GAUSSIAN
<i>252</i>&nbsp;     */
<b class="nc"><i>253</i>&nbsp;    public final static Object VALUE_INTERPOLATION_GAUSSIAN =</b>
<i>254</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Gaussian&quot;, FILTER_GAUSSIAN);
<i>255</i>&nbsp;    /**
<i>256</i>&nbsp;     * @see #FILTER_QUADRATIC
<i>257</i>&nbsp;     */
<b class="nc"><i>258</i>&nbsp;    public final static Object VALUE_INTERPOLATION_QUADRATIC =</b>
<i>259</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Quadratic&quot;, FILTER_QUADRATIC);
<i>260</i>&nbsp;    /**
<i>261</i>&nbsp;     * @see #FILTER_CUBIC
<i>262</i>&nbsp;     */
<b class="nc"><i>263</i>&nbsp;    public final static Object VALUE_INTERPOLATION_CUBIC =</b>
<i>264</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Cubic&quot;, FILTER_CUBIC);
<i>265</i>&nbsp;    /**
<i>266</i>&nbsp;     * @see #FILTER_CATROM
<i>267</i>&nbsp;     */
<b class="nc"><i>268</i>&nbsp;    public final static Object VALUE_INTERPOLATION_CATROM =</b>
<i>269</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Catrom&quot;, FILTER_CATROM);
<i>270</i>&nbsp;    /**
<i>271</i>&nbsp;     * @see #FILTER_MITCHELL
<i>272</i>&nbsp;     */
<b class="nc"><i>273</i>&nbsp;    public final static Object VALUE_INTERPOLATION_MITCHELL =</b>
<i>274</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Mitchell&quot;, FILTER_MITCHELL);
<i>275</i>&nbsp;    /**
<i>276</i>&nbsp;     * @see #FILTER_LANCZOS
<i>277</i>&nbsp;     */
<b class="nc"><i>278</i>&nbsp;    public final static Object VALUE_INTERPOLATION_LANCZOS =</b>
<i>279</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Lanczos&quot;, FILTER_LANCZOS);
<i>280</i>&nbsp;    /**
<i>281</i>&nbsp;     * @see #FILTER_BLACKMAN_BESSEL
<i>282</i>&nbsp;     */
<b class="nc"><i>283</i>&nbsp;    public final static Object VALUE_INTERPOLATION_BLACKMAN_BESSEL =</b>
<i>284</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Blackman-Bessel&quot;, FILTER_BLACKMAN_BESSEL);
<i>285</i>&nbsp;    /**
<i>286</i>&nbsp;     * @see #FILTER_BLACKMAN_SINC
<i>287</i>&nbsp;     */
<b class="nc"><i>288</i>&nbsp;    public final static Object VALUE_INTERPOLATION_BLACKMAN_SINC =</b>
<i>289</i>&nbsp;            new Value(KEY_RESAMPLE_INTERPOLATION, &quot;Blackman-Sinc&quot;, FILTER_BLACKMAN_SINC);
<i>290</i>&nbsp;
<i>291</i>&nbsp;    // Member variables
<i>292</i>&nbsp;    // Package access, to allow access from MagickAccelerator
<i>293</i>&nbsp;    int width;
<i>294</i>&nbsp;    int height;
<i>295</i>&nbsp;
<i>296</i>&nbsp;    int filterType;
<i>297</i>&nbsp;
<i>298</i>&nbsp;    /**
<i>299</i>&nbsp;     * RendereingHints.Key implementation, works only with Value values.
<i>300</i>&nbsp;     */
<i>301</i>&nbsp;    // TODO: Move to abstract class AbstractBufferedImageOp?
<i>302</i>&nbsp;    static class Key extends RenderingHints.Key {
<b class="nc"><i>303</i>&nbsp;        static int sIndex = 10000;</b>
<i>304</i>&nbsp;
<i>305</i>&nbsp;        private final String name;
<i>306</i>&nbsp;
<i>307</i>&nbsp;        public Key(final String pName) {
<b class="nc"><i>308</i>&nbsp;            super(sIndex++);</b>
<b class="nc"><i>309</i>&nbsp;            name = pName;</b>
<i>310</i>&nbsp;        }
<i>311</i>&nbsp;
<i>312</i>&nbsp;        public boolean isCompatibleValue(Object pValue) {
<b class="nc"><i>313</i>&nbsp;            return pValue instanceof Value &amp;&amp; ((Value) pValue).isCompatibleKey(this);</b>
<i>314</i>&nbsp;        }
<i>315</i>&nbsp;
<i>316</i>&nbsp;        public String toString() {
<b class="nc"><i>317</i>&nbsp;            return name;</b>
<i>318</i>&nbsp;        }
<i>319</i>&nbsp;    }
<i>320</i>&nbsp;
<i>321</i>&nbsp;    /**
<i>322</i>&nbsp;     * RenderingHints value implementation, works with Key keys.
<i>323</i>&nbsp;     */
<i>324</i>&nbsp;    // TODO: Extract abstract Value class, and move to AbstractBufferedImageOp
<i>325</i>&nbsp;    static final class Value {
<i>326</i>&nbsp;        final private RenderingHints.Key key;
<i>327</i>&nbsp;        final private String name;
<i>328</i>&nbsp;        final private int type;
<i>329</i>&nbsp;
<b class="nc"><i>330</i>&nbsp;        public Value(final RenderingHints.Key pKey, final String pName, final int pType) {</b>
<b class="nc"><i>331</i>&nbsp;            key = pKey;</b>
<b class="nc"><i>332</i>&nbsp;            name = pName;</b>
<b class="nc"><i>333</i>&nbsp;            type = validateFilterType(pType);</b>
<i>334</i>&nbsp;        }
<i>335</i>&nbsp;
<i>336</i>&nbsp;        public boolean isCompatibleKey(Key pKey) {
<b class="nc"><i>337</i>&nbsp;            return pKey == key;</b>
<i>338</i>&nbsp;        }
<i>339</i>&nbsp;
<i>340</i>&nbsp;        public int getFilterType() {
<b class="nc"><i>341</i>&nbsp;            return type;</b>
<i>342</i>&nbsp;        }
<i>343</i>&nbsp;
<i>344</i>&nbsp;        public String toString() {
<b class="nc"><i>345</i>&nbsp;            return name;</b>
<i>346</i>&nbsp;        }
<i>347</i>&nbsp;    }
<i>348</i>&nbsp;
<i>349</i>&nbsp;    /**
<i>350</i>&nbsp;     * Creates a {@code ResampleOp} that will resample input images to the
<i>351</i>&nbsp;     * given width and height, using the default interpolation filter.
<i>352</i>&nbsp;     *
<i>353</i>&nbsp;     * @param width  width of the re-sampled image
<i>354</i>&nbsp;     * @param height height of the re-sampled image
<i>355</i>&nbsp;     */
<i>356</i>&nbsp;    public ResampleOp(int width, int height) {
<b class="nc"><i>357</i>&nbsp;        this(width, height, FILTER_UNDEFINED);</b>
<i>358</i>&nbsp;    }
<i>359</i>&nbsp;
<i>360</i>&nbsp;    /**
<i>361</i>&nbsp;     * Creates a {@code ResampleOp} that will resample input images to the
<i>362</i>&nbsp;     * given width and height, using the interpolation filter specified by
<i>363</i>&nbsp;     * the given hints.
<i>364</i>&nbsp;     * If using {@code RenderingHints}, the hints are mapped as follows:
<i>365</i>&nbsp;     * &lt;ul&gt;
<i>366</i>&nbsp;     * &lt;li&gt;{@code KEY_RESAMPLE_INTERPOLATION} takes precedence over any
<i>367</i>&nbsp;     * standard {@code java.awt} hints, and dictates interpolation
<i>368</i>&nbsp;     * directly, see
<i>369</i>&nbsp;     * &lt;a href=&quot;#field_summary&quot;&gt;{@code RenderingHints} constants&lt;/a&gt;.&lt;/li&gt;
<i>370</i>&nbsp;     * &lt;p/&gt;
<i>371</i>&nbsp;     * &lt;li&gt;{@code KEY_INTERPOLATION} takes precedence over other hints.
<i>372</i>&nbsp;     * &lt;ul&gt;
<i>373</i>&nbsp;     * &lt;li&gt;{@link RenderingHints#VALUE_INTERPOLATION_NEAREST_NEIGHBOR} specifies
<i>374</i>&nbsp;     * {@code FILTER_POINT}&lt;/li&gt;
<i>375</i>&nbsp;     * &lt;li&gt;{@link RenderingHints#VALUE_INTERPOLATION_BILINEAR} specifies
<i>376</i>&nbsp;     * {@code FILTER_TRIANGLE}&lt;/li&gt;
<i>377</i>&nbsp;     * &lt;li&gt;{@link RenderingHints#VALUE_INTERPOLATION_BICUBIC} specifies
<i>378</i>&nbsp;     * {@code FILTER_QUADRATIC}&lt;/li&gt;
<i>379</i>&nbsp;     * &lt;/ul&gt;
<i>380</i>&nbsp;     * &lt;/li&gt;
<i>381</i>&nbsp;     * &lt;p/&gt;
<i>382</i>&nbsp;     * &lt;li&gt;{@code KEY_RENDERING} or {@code KEY_COLOR_RENDERING}
<i>383</i>&nbsp;     * &lt;ul&gt;
<i>384</i>&nbsp;     * &lt;li&gt;{@link RenderingHints#VALUE_RENDER_SPEED} specifies
<i>385</i>&nbsp;     * {@code FILTER_POINT}&lt;/li&gt;
<i>386</i>&nbsp;     * &lt;li&gt;{@link RenderingHints#VALUE_RENDER_QUALITY} specifies
<i>387</i>&nbsp;     * {@code FILTER_MITCHELL}&lt;/li&gt;
<i>388</i>&nbsp;     * &lt;/ul&gt;
<i>389</i>&nbsp;     * &lt;/li&gt;
<i>390</i>&nbsp;     * &lt;/ul&gt;
<i>391</i>&nbsp;     * Other hints have no effect on this filter.
<i>392</i>&nbsp;     *
<i>393</i>&nbsp;     * @param width  width of the re-sampled image
<i>394</i>&nbsp;     * @param height height of the re-sampled image
<i>395</i>&nbsp;     * @param hints  rendering hints, affecting interpolation algorithm
<i>396</i>&nbsp;     * @see #KEY_RESAMPLE_INTERPOLATION
<i>397</i>&nbsp;     * @see RenderingHints#KEY_INTERPOLATION
<i>398</i>&nbsp;     * @see RenderingHints#KEY_RENDERING
<i>399</i>&nbsp;     * @see RenderingHints#KEY_COLOR_RENDERING
<i>400</i>&nbsp;     */
<i>401</i>&nbsp;    public ResampleOp(int width, int height, RenderingHints hints) {
<b class="nc"><i>402</i>&nbsp;        this(width, height, getFilterType(hints));</b>
<i>403</i>&nbsp;    }
<i>404</i>&nbsp;
<i>405</i>&nbsp;    /**
<i>406</i>&nbsp;     * Creates a {@code ResampleOp} that will resample input images to the
<i>407</i>&nbsp;     * given width and height, using the given interpolation filter.
<i>408</i>&nbsp;     *
<i>409</i>&nbsp;     * @param width      width of the re-sampled image
<i>410</i>&nbsp;     * @param height     height of the re-sampled image
<i>411</i>&nbsp;     * @param filterType interpolation filter algorithm
<i>412</i>&nbsp;     * @see &lt;a href=&quot;#field_summary&quot;&gt;filter type constants&lt;/a&gt;
<i>413</i>&nbsp;     */
<b class="nc"><i>414</i>&nbsp;    public ResampleOp(int width, int height, int filterType) {</b>
<b class="nc"><i>415</i>&nbsp;        if (width &lt;= 0 || height &lt;= 0) {</b>
<i>416</i>&nbsp;            // NOTE: w/h == 0 makes the Magick DLL crash and the JVM dies.. :-P
<b class="nc"><i>417</i>&nbsp;            throw new IllegalArgumentException(&quot;width and height must be positive&quot;);</b>
<i>418</i>&nbsp;        }
<i>419</i>&nbsp;
<b class="nc"><i>420</i>&nbsp;        this.width = width;</b>
<b class="nc"><i>421</i>&nbsp;        this.height = height;</b>
<i>422</i>&nbsp;
<b class="nc"><i>423</i>&nbsp;        this.filterType = validateFilterType(filterType);</b>
<i>424</i>&nbsp;    }
<i>425</i>&nbsp;
<i>426</i>&nbsp;    private static int validateFilterType(int pFilterType) {
<b class="nc"><i>427</i>&nbsp;        switch (pFilterType) {</b>
<i>428</i>&nbsp;            case FILTER_UNDEFINED:
<i>429</i>&nbsp;            case FILTER_POINT:
<i>430</i>&nbsp;            case FILTER_BOX:
<i>431</i>&nbsp;            case FILTER_TRIANGLE:
<i>432</i>&nbsp;            case FILTER_HERMITE:
<i>433</i>&nbsp;            case FILTER_HANNING:
<i>434</i>&nbsp;            case FILTER_HAMMING:
<i>435</i>&nbsp;            case FILTER_BLACKMAN:
<i>436</i>&nbsp;            case FILTER_GAUSSIAN:
<i>437</i>&nbsp;            case FILTER_QUADRATIC:
<i>438</i>&nbsp;            case FILTER_CUBIC:
<i>439</i>&nbsp;            case FILTER_CATROM:
<i>440</i>&nbsp;            case FILTER_MITCHELL:
<i>441</i>&nbsp;            case FILTER_LANCZOS:
<i>442</i>&nbsp;            case FILTER_BLACKMAN_BESSEL:
<i>443</i>&nbsp;            case FILTER_BLACKMAN_SINC:
<b class="nc"><i>444</i>&nbsp;                return pFilterType;</b>
<i>445</i>&nbsp;            default:
<b class="nc"><i>446</i>&nbsp;                throw new IllegalArgumentException(&quot;Unknown filter type: &quot; + pFilterType);</b>
<i>447</i>&nbsp;        }
<i>448</i>&nbsp;    }
<i>449</i>&nbsp;
<i>450</i>&nbsp;    /**
<i>451</i>&nbsp;     * Gets the filter type specified by the given hints.
<i>452</i>&nbsp;     *
<i>453</i>&nbsp;     * @param pHints rendering hints
<i>454</i>&nbsp;     * @return a filter type constant
<i>455</i>&nbsp;     */
<i>456</i>&nbsp;    private static int getFilterType(RenderingHints pHints) {
<b class="nc"><i>457</i>&nbsp;        if (pHints == null) {</b>
<b class="nc"><i>458</i>&nbsp;            return FILTER_UNDEFINED;</b>
<i>459</i>&nbsp;        }
<i>460</i>&nbsp;
<b class="nc"><i>461</i>&nbsp;        if (pHints.containsKey(KEY_RESAMPLE_INTERPOLATION)) {</b>
<b class="nc"><i>462</i>&nbsp;            Object value = pHints.get(KEY_RESAMPLE_INTERPOLATION);</b>
<i>463</i>&nbsp;            // NOTE: Workaround for a bug in RenderingHints constructor (Bug id# 5084832)
<b class="nc"><i>464</i>&nbsp;            if (!KEY_RESAMPLE_INTERPOLATION.isCompatibleValue(value)) {</b>
<b class="nc"><i>465</i>&nbsp;                throw new IllegalArgumentException(value + &quot; incompatible with key &quot; + KEY_RESAMPLE_INTERPOLATION);</b>
<i>466</i>&nbsp;            }
<b class="nc"><i>467</i>&nbsp;            return value != null ? ((Value) value).getFilterType() : FILTER_UNDEFINED;</b>
<i>468</i>&nbsp;        }
<b class="nc"><i>469</i>&nbsp;        else if (RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR.equals(pHints.get(RenderingHints.KEY_INTERPOLATION))</b>
<b class="nc"><i>470</i>&nbsp;                || (!pHints.containsKey(RenderingHints.KEY_INTERPOLATION)</b>
<b class="nc"><i>471</i>&nbsp;                &amp;&amp; (RenderingHints.VALUE_RENDER_SPEED.equals(pHints.get(RenderingHints.KEY_RENDERING))</b>
<b class="nc"><i>472</i>&nbsp;                || RenderingHints.VALUE_COLOR_RENDER_SPEED.equals(pHints.get(RenderingHints.KEY_COLOR_RENDERING))))) {</b>
<i>473</i>&nbsp;            // Nearest neighbour, or prioritize speed
<b class="nc"><i>474</i>&nbsp;            return FILTER_POINT;</b>
<i>475</i>&nbsp;        }
<b class="nc"><i>476</i>&nbsp;        else if (RenderingHints.VALUE_INTERPOLATION_BILINEAR.equals(pHints.get(RenderingHints.KEY_INTERPOLATION))) {</b>
<i>477</i>&nbsp;            // Triangle equals bi-linear interpolation
<b class="nc"><i>478</i>&nbsp;            return FILTER_TRIANGLE;</b>
<i>479</i>&nbsp;        }
<b class="nc"><i>480</i>&nbsp;        else if (RenderingHints.VALUE_INTERPOLATION_BICUBIC.equals(pHints.get(RenderingHints.KEY_INTERPOLATION))) {</b>
<b class="nc"><i>481</i>&nbsp;            return FILTER_QUADRATIC;// No idea if this is correct..?</b>
<i>482</i>&nbsp;        }
<b class="nc"><i>483</i>&nbsp;        else if (RenderingHints.VALUE_RENDER_QUALITY.equals(pHints.get(RenderingHints.KEY_RENDERING))</b>
<b class="nc"><i>484</i>&nbsp;                || RenderingHints.VALUE_COLOR_RENDER_QUALITY.equals(pHints.get(RenderingHints.KEY_COLOR_RENDERING))) {</b>
<i>485</i>&nbsp;            // Prioritize quality
<b class="nc"><i>486</i>&nbsp;            return FILTER_MITCHELL;</b>
<i>487</i>&nbsp;        }
<i>488</i>&nbsp;
<i>489</i>&nbsp;        // NOTE: Other hints are ignored
<b class="nc"><i>490</i>&nbsp;        return FILTER_UNDEFINED;</b>
<i>491</i>&nbsp;    }
<i>492</i>&nbsp;
<i>493</i>&nbsp;    /**
<i>494</i>&nbsp;     * Re-samples (scales) the image to the size, and using the algorithm
<i>495</i>&nbsp;     * specified in the constructor.
<i>496</i>&nbsp;     *
<i>497</i>&nbsp;     * @param input  The {@code BufferedImage} to be filtered
<i>498</i>&nbsp;     * @param output The {@code BufferedImage} in which to store the resampled
<i>499</i>&nbsp;     *                image
<i>500</i>&nbsp;     * @return The re-sampled {@code BufferedImage}.
<i>501</i>&nbsp;     * @throws NullPointerException     if {@code input} is {@code null}
<i>502</i>&nbsp;     * @throws IllegalArgumentException if {@code input == output}.
<i>503</i>&nbsp;     * @see #ResampleOp(int,int,int)
<i>504</i>&nbsp;     */
<i>505</i>&nbsp;    public final BufferedImage filter(final BufferedImage input, final BufferedImage output) {
<b class="nc"><i>506</i>&nbsp;        if (input == null) {</b>
<b class="nc"><i>507</i>&nbsp;            throw new NullPointerException(&quot;Input == null&quot;);</b>
<i>508</i>&nbsp;        }
<b class="nc"><i>509</i>&nbsp;        if (input == output) {</b>
<b class="nc"><i>510</i>&nbsp;            throw new IllegalArgumentException(&quot;Output image cannot be the same as the input image&quot;);</b>
<i>511</i>&nbsp;        }
<i>512</i>&nbsp;
<i>513</i>&nbsp;        InterpolationFilter filter;
<i>514</i>&nbsp;
<i>515</i>&nbsp;        // Special case for POINT, TRIANGLE and QUADRATIC filter, as standard
<i>516</i>&nbsp;        // Java implementation is very fast (possibly H/W accelerated)
<b class="nc"><i>517</i>&nbsp;        switch (filterType) {</b>
<i>518</i>&nbsp;            case FILTER_POINT:
<b class="nc"><i>519</i>&nbsp;                if (input.getType() != BufferedImage.TYPE_CUSTOM) {</b>
<b class="nc"><i>520</i>&nbsp;                    return fastResample(input, output, width, height, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);</b>
<i>521</i>&nbsp;                }
<i>522</i>&nbsp;                // Else fall through
<i>523</i>&nbsp;            case FILTER_TRIANGLE:
<b class="nc"><i>524</i>&nbsp;                if (input.getType() != BufferedImage.TYPE_CUSTOM) {</b>
<b class="nc"><i>525</i>&nbsp;                    return fastResample(input, output, width, height, AffineTransformOp.TYPE_BILINEAR);</b>
<i>526</i>&nbsp;                }
<i>527</i>&nbsp;                // Else fall through
<i>528</i>&nbsp;            case FILTER_QUADRATIC:
<b class="nc"><i>529</i>&nbsp;                if (input.getType() != BufferedImage.TYPE_CUSTOM) {</b>
<b class="nc"><i>530</i>&nbsp;                    return fastResample(input, output, width, height, AffineTransformOp.TYPE_BICUBIC);</b>
<i>531</i>&nbsp;                }
<i>532</i>&nbsp;                // Else fall through
<i>533</i>&nbsp;            default:
<b class="nc"><i>534</i>&nbsp;                filter = createFilter(filterType);</b>
<i>535</i>&nbsp;                // NOTE: Workaround for filter throwing exceptions when input or output is less than support...
<b class="nc"><i>536</i>&nbsp;                if (Math.min(input.getWidth(), input.getHeight()) &lt;= filter.support() || Math.min(width, height) &lt;= filter.support()) {</b>
<b class="nc"><i>537</i>&nbsp;                    return fastResample(input, output, width, height, AffineTransformOp.TYPE_BILINEAR);</b>
<i>538</i>&nbsp;                }
<i>539</i>&nbsp;                // Fall through
<i>540</i>&nbsp;        }
<i>541</i>&nbsp;
<i>542</i>&nbsp;        // Try to use native ImageMagick code
<b class="nc"><i>543</i>&nbsp;        BufferedImage result = MagickAccelerator.filter(this, input, output);</b>
<b class="nc"><i>544</i>&nbsp;        if (result != null) {</b>
<b class="nc"><i>545</i>&nbsp;            return result;</b>
<i>546</i>&nbsp;        }
<i>547</i>&nbsp;
<i>548</i>&nbsp;        // Otherwise, continue in pure Java mode
<i>549</i>&nbsp;
<i>550</i>&nbsp;        // TODO: What if output != null and wrong size? Create new? Render on only a part? Document?
<i>551</i>&nbsp;
<i>552</i>&nbsp;        // If filter type != POINT or BOX and input has IndexColorModel, convert
<i>553</i>&nbsp;        // to true color, with alpha reflecting that of the original color model.
<i>554</i>&nbsp;        BufferedImage temp;
<i>555</i>&nbsp;        ColorModel cm;
<b class="nc"><i>556</i>&nbsp;        if (filterType != FILTER_POINT &amp;&amp; filterType != FILTER_BOX &amp;&amp; (cm = input.getColorModel()) instanceof IndexColorModel) {</b>
<i>557</i>&nbsp;            // TODO: OPTIMIZE: If color model has only b/w or gray, we could skip color info
<b class="nc"><i>558</i>&nbsp;            temp = ImageUtil.toBuffered(input, cm.hasAlpha() ? BufferedImage.TYPE_4BYTE_ABGR : BufferedImage.TYPE_3BYTE_BGR);</b>
<i>559</i>&nbsp;        }
<i>560</i>&nbsp;        else {
<b class="nc"><i>561</i>&nbsp;            temp = input;</b>
<i>562</i>&nbsp;        }
<i>563</i>&nbsp;
<i>564</i>&nbsp;        // Create or convert output to a suitable image
<i>565</i>&nbsp;        // TODO: OPTIMIZE: Don&#39;t really need to convert all types to same as input
<b class="nc"><i>566</i>&nbsp;        result = output != null &amp;&amp; temp.getType() != BufferedImage.TYPE_CUSTOM ? /*output*/ ImageUtil.toBuffered(output, temp.getType()) : createCompatibleDestImage(temp, null);</b>
<i>567</i>&nbsp;
<b class="nc"><i>568</i>&nbsp;        resample(temp, result, filter);</b>
<i>569</i>&nbsp;
<i>570</i>&nbsp;        // If output != null and needed to be converted, draw it back
<b class="nc"><i>571</i>&nbsp;        if (output != null &amp;&amp; output != result) {</b>
<i>572</i>&nbsp;            //output.setData(output.getRaster());
<b class="nc"><i>573</i>&nbsp;            ImageUtil.drawOnto(output, result);</b>
<b class="nc"><i>574</i>&nbsp;            result = output;</b>
<i>575</i>&nbsp;        }
<i>576</i>&nbsp;
<b class="nc"><i>577</i>&nbsp;        return result;</b>
<i>578</i>&nbsp;    }
<i>579</i>&nbsp;
<i>580</i>&nbsp;    /*
<i>581</i>&nbsp;    private static BufferedImage pointResample(final BufferedImage pInput, final BufferedImage pOutput, final int pWidth, final int pHeight) {
<i>582</i>&nbsp;        double xScale = pWidth / (double) pInput.getWidth();
<i>583</i>&nbsp;        double yScale = pHeight / (double) pInput.getHeight();
<i>584</i>&nbsp;
<i>585</i>&nbsp;        // NOTE: This is extremely fast, native, possibly H/W accelerated code
<i>586</i>&nbsp;        AffineTransform transform = AffineTransform.getScaleInstance(xScale, yScale);
<i>587</i>&nbsp;        AffineTransformOp scale = new AffineTransformOp(transform, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);
<i>588</i>&nbsp;        return scale.filter(pInput, pOutput);
<i>589</i>&nbsp;    }
<i>590</i>&nbsp;    */
<i>591</i>&nbsp;
<i>592</i>&nbsp;    /*
<i>593</i>&nbsp;    // TODO: This idea from Chet and Romain is actually not too bad..
<i>594</i>&nbsp;    // It reuses the image/raster/graphics...
<i>595</i>&nbsp;    // However, they don&#39;t end with a halve operation..
<i>596</i>&nbsp;    private static BufferedImage getFasterScaledInstance(BufferedImage img,
<i>597</i>&nbsp;            int targetWidth, int targetHeight, Object hint,
<i>598</i>&nbsp;            boolean progressiveBilinear) {
<i>599</i>&nbsp;        int type = (img.getTransparency() == Transparency.OPAQUE) ?
<i>600</i>&nbsp;            BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB;
<i>601</i>&nbsp;        BufferedImage ret = img;
<i>602</i>&nbsp;        BufferedImage scratchImage = null;
<i>603</i>&nbsp;        Graphics2D g2 = null;
<i>604</i>&nbsp;        int w, h;
<i>605</i>&nbsp;        int prevW = ret.getWidth();
<i>606</i>&nbsp;        int prevH = ret.getHeight();
<i>607</i>&nbsp;        boolean isTranslucent = img.getTransparency() !=  Transparency.OPAQUE;
<i>608</i>&nbsp;
<i>609</i>&nbsp;        if (progressiveBilinear) {
<i>610</i>&nbsp;            // Use multi-step technique: start with original size, then
<i>611</i>&nbsp;            // scale down in multiple passes with drawImage()
<i>612</i>&nbsp;            // until the target size is reached
<i>613</i>&nbsp;            w = img.getWidth();
<i>614</i>&nbsp;            h = img.getHeight();
<i>615</i>&nbsp;        } else {
<i>616</i>&nbsp;            // Use one-step technique: scale directly from original
<i>617</i>&nbsp;            // size to target size with a single drawImage() call
<i>618</i>&nbsp;            w = targetWidth;
<i>619</i>&nbsp;            h = targetHeight;
<i>620</i>&nbsp;        }
<i>621</i>&nbsp;
<i>622</i>&nbsp;        do {
<i>623</i>&nbsp;            if (progressiveBilinear &amp;&amp; w &gt; targetWidth) {
<i>624</i>&nbsp;                w /= 2;
<i>625</i>&nbsp;                if (w &lt; targetWidth) {
<i>626</i>&nbsp;                    w = targetWidth;
<i>627</i>&nbsp;                }
<i>628</i>&nbsp;            }
<i>629</i>&nbsp;
<i>630</i>&nbsp;            if (progressiveBilinear &amp;&amp; h &gt; targetHeight) {
<i>631</i>&nbsp;                h /= 2;
<i>632</i>&nbsp;                if (h &lt; targetHeight) {
<i>633</i>&nbsp;                    h = targetHeight;
<i>634</i>&nbsp;                }
<i>635</i>&nbsp;            }
<i>636</i>&nbsp;
<i>637</i>&nbsp;            if (scratchImage == null || isTranslucent) {
<i>638</i>&nbsp;                // Use a single scratch buffer for all iterations
<i>639</i>&nbsp;                // and then copy to the final, correctly-sized image
<i>640</i>&nbsp;                // before returning
<i>641</i>&nbsp;                scratchImage = new BufferedImage(w, h, type);
<i>642</i>&nbsp;                g2 = scratchImage.createGraphics();
<i>643</i>&nbsp;            }
<i>644</i>&nbsp;            g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, hint);
<i>645</i>&nbsp;            g2.drawImage(ret, 0, 0, w, h, 0, 0, prevW, prevH, null);
<i>646</i>&nbsp;            prevW = w;
<i>647</i>&nbsp;            prevH = h;
<i>648</i>&nbsp;
<i>649</i>&nbsp;            ret = scratchImage;
<i>650</i>&nbsp;        } while (w != targetWidth || h != targetHeight);
<i>651</i>&nbsp;
<i>652</i>&nbsp;        if (g2 != null) {
<i>653</i>&nbsp;            g2.dispose();
<i>654</i>&nbsp;        }
<i>655</i>&nbsp;
<i>656</i>&nbsp;        // If we used a scratch buffer that is larger than our target size,
<i>657</i>&nbsp;        // create an image of the right size and copy the results into it
<i>658</i>&nbsp;        if (targetWidth != ret.getWidth() || targetHeight != ret.getHeight()) {
<i>659</i>&nbsp;            scratchImage = new BufferedImage(targetWidth, targetHeight, type);
<i>660</i>&nbsp;            g2 = scratchImage.createGraphics();
<i>661</i>&nbsp;            g2.drawImage(ret, 0, 0, null);
<i>662</i>&nbsp;            g2.dispose();
<i>663</i>&nbsp;            ret = scratchImage;
<i>664</i>&nbsp;        }
<i>665</i>&nbsp;
<i>666</i>&nbsp;        return ret;
<i>667</i>&nbsp;    }
<i>668</i>&nbsp;    */
<i>669</i>&nbsp;
<i>670</i>&nbsp;    private static BufferedImage fastResample(final BufferedImage input, final BufferedImage output, final int width, final int height, final int type) {
<b class="nc"><i>671</i>&nbsp;        BufferedImage temp = input;</b>
<i>672</i>&nbsp;
<i>673</i>&nbsp;        double xScale;
<i>674</i>&nbsp;        double yScale;
<i>675</i>&nbsp;
<i>676</i>&nbsp;        AffineTransform transform;
<i>677</i>&nbsp;        AffineTransformOp scale;
<i>678</i>&nbsp;
<b class="nc"><i>679</i>&nbsp;        if (type &gt; AffineTransformOp.TYPE_NEAREST_NEIGHBOR) {</b>
<i>680</i>&nbsp;            // Initially scale so all remaining operations will halve the image
<b class="nc"><i>681</i>&nbsp;            if (width &lt; input.getWidth() || height &lt; input.getHeight()) {</b>
<b class="nc"><i>682</i>&nbsp;                int w = width;</b>
<b class="nc"><i>683</i>&nbsp;                int h = height;</b>
<b class="nc"><i>684</i>&nbsp;                while (w &lt; input.getWidth() / 2) {</b>
<b class="nc"><i>685</i>&nbsp;                    w *= 2;</b>
<i>686</i>&nbsp;                }
<b class="nc"><i>687</i>&nbsp;                while (h &lt; input.getHeight() / 2) {</b>
<b class="nc"><i>688</i>&nbsp;                    h *= 2;</b>
<i>689</i>&nbsp;                }
<i>690</i>&nbsp;
<b class="nc"><i>691</i>&nbsp;                xScale = w / (double) input.getWidth();</b>
<b class="nc"><i>692</i>&nbsp;                yScale = h / (double) input.getHeight();</b>
<i>693</i>&nbsp;
<i>694</i>&nbsp;                //System.out.println(&quot;First scale by x=&quot; + xScale + &quot;, y=&quot; + yScale);
<i>695</i>&nbsp;
<b class="nc"><i>696</i>&nbsp;                transform = AffineTransform.getScaleInstance(xScale, yScale);</b>
<b class="nc"><i>697</i>&nbsp;                scale = new AffineTransformOp(transform, AffineTransformOp.TYPE_BILINEAR);</b>
<b class="nc"><i>698</i>&nbsp;                temp = scale.filter(temp, null);</b>
<i>699</i>&nbsp;            }
<i>700</i>&nbsp;        }
<i>701</i>&nbsp;
<b class="nc"><i>702</i>&nbsp;        scale = null; // NOTE: This resets!</b>
<i>703</i>&nbsp;
<b class="nc"><i>704</i>&nbsp;        xScale = width / (double) temp.getWidth();</b>
<b class="nc"><i>705</i>&nbsp;        yScale = height / (double) temp.getHeight();</b>
<i>706</i>&nbsp;
<b class="nc"><i>707</i>&nbsp;        if (type &gt; AffineTransformOp.TYPE_NEAREST_NEIGHBOR) {</b>
<i>708</i>&nbsp;            // TODO: Test skipping first scale (above), and instead scale once
<i>709</i>&nbsp;            // more here, and a little less than .5 each time...
<i>710</i>&nbsp;            // That would probably make the scaling smoother...
<b class="nc"><i>711</i>&nbsp;            while (xScale &lt; 0.5 || yScale &lt; 0.5) {</b>
<b class="nc"><i>712</i>&nbsp;                if (xScale &gt;= 0.5) {</b>
<i>713</i>&nbsp;                    //System.out.println(&quot;Halving by y=&quot; + (yScale * 2.0));
<b class="nc"><i>714</i>&nbsp;                    transform = AffineTransform.getScaleInstance(1.0, 0.5);</b>
<b class="nc"><i>715</i>&nbsp;                    scale = new AffineTransformOp(transform, AffineTransformOp.TYPE_BILINEAR);</b>
<i>716</i>&nbsp;
<b class="nc"><i>717</i>&nbsp;                    yScale *= 2.0;</b>
<i>718</i>&nbsp;                }
<b class="nc"><i>719</i>&nbsp;                else if (yScale &gt;= 0.5) {</b>
<i>720</i>&nbsp;                    //System.out.println(&quot;Halving by x=&quot; + (xScale * 2.0));
<b class="nc"><i>721</i>&nbsp;                    transform = AffineTransform.getScaleInstance(0.5, 1.0);</b>
<b class="nc"><i>722</i>&nbsp;                    scale = new AffineTransformOp(transform, AffineTransformOp.TYPE_BILINEAR);</b>
<i>723</i>&nbsp;
<b class="nc"><i>724</i>&nbsp;                    xScale *= 2.0;</b>
<i>725</i>&nbsp;                }
<i>726</i>&nbsp;                else {
<i>727</i>&nbsp;                    //System.out.println(&quot;Halving by x=&quot; + (xScale * 2.0)  + &quot;, y=&quot; + (yScale * 2.0));
<b class="nc"><i>728</i>&nbsp;                    xScale *= 2.0;</b>
<b class="nc"><i>729</i>&nbsp;                    yScale *= 2.0;</b>
<i>730</i>&nbsp;                }
<i>731</i>&nbsp;
<b class="nc"><i>732</i>&nbsp;                if (scale == null) {</b>
<b class="nc"><i>733</i>&nbsp;                    transform = AffineTransform.getScaleInstance(0.5, 0.5);</b>
<b class="nc"><i>734</i>&nbsp;                    scale = new AffineTransformOp(transform, AffineTransformOp.TYPE_BILINEAR);</b>
<i>735</i>&nbsp;                }
<i>736</i>&nbsp;
<b class="nc"><i>737</i>&nbsp;                temp = scale.filter(temp, null);</b>
<i>738</i>&nbsp;            }
<i>739</i>&nbsp;        }
<i>740</i>&nbsp;
<i>741</i>&nbsp;        //System.out.println(&quot;Rest to scale by x=&quot; + xScale + &quot;, y=&quot; + yScale);
<i>742</i>&nbsp;
<b class="nc"><i>743</i>&nbsp;        transform = AffineTransform.getScaleInstance(xScale, yScale);</b>
<b class="nc"><i>744</i>&nbsp;        scale = new AffineTransformOp(transform, type);</b>
<i>745</i>&nbsp;
<b class="nc"><i>746</i>&nbsp;        return scale.filter(temp, output);</b>
<i>747</i>&nbsp;    }
<i>748</i>&nbsp;
<i>749</i>&nbsp;    /**
<i>750</i>&nbsp;     * Returns the current filter type constant.
<i>751</i>&nbsp;     *
<i>752</i>&nbsp;     * @return the current filter type constant.
<i>753</i>&nbsp;     * @see &lt;a href=&quot;#field_summary&quot;&gt;filter type constants&lt;/a&gt;
<i>754</i>&nbsp;     */
<i>755</i>&nbsp;    public int getFilterType() {
<b class="nc"><i>756</i>&nbsp;        return filterType;</b>
<i>757</i>&nbsp;    }
<i>758</i>&nbsp;
<i>759</i>&nbsp;    private static InterpolationFilter createFilter(int pFilterType) {
<i>760</i>&nbsp;        // TODO: Select correct filter based on scale up or down, if undefined!
<b class="nc"><i>761</i>&nbsp;        if (pFilterType == FILTER_UNDEFINED) {</b>
<b class="nc"><i>762</i>&nbsp;            pFilterType = FILTER_LANCZOS;</b>
<i>763</i>&nbsp;        }
<i>764</i>&nbsp;
<b class="nc"><i>765</i>&nbsp;        switch (pFilterType) {</b>
<i>766</i>&nbsp;            case FILTER_POINT:
<b class="nc"><i>767</i>&nbsp;                return new PointFilter();</b>
<i>768</i>&nbsp;            case FILTER_BOX:
<b class="nc"><i>769</i>&nbsp;                return new BoxFilter();</b>
<i>770</i>&nbsp;            case FILTER_TRIANGLE:
<b class="nc"><i>771</i>&nbsp;                return new TriangleFilter();</b>
<i>772</i>&nbsp;            case FILTER_HERMITE:
<b class="nc"><i>773</i>&nbsp;                return new HermiteFilter();</b>
<i>774</i>&nbsp;            case FILTER_HANNING:
<b class="nc"><i>775</i>&nbsp;                return new HanningFilter();</b>
<i>776</i>&nbsp;            case FILTER_HAMMING:
<b class="nc"><i>777</i>&nbsp;                return new HammingFilter();</b>
<i>778</i>&nbsp;            case FILTER_BLACKMAN:
<b class="nc"><i>779</i>&nbsp;                return new BlacmanFilter();</b>
<i>780</i>&nbsp;            case FILTER_GAUSSIAN:
<b class="nc"><i>781</i>&nbsp;                return new GaussianFilter();</b>
<i>782</i>&nbsp;            case FILTER_QUADRATIC:
<b class="nc"><i>783</i>&nbsp;                return new QuadraticFilter();</b>
<i>784</i>&nbsp;            case FILTER_CUBIC:
<b class="nc"><i>785</i>&nbsp;                return new CubicFilter();</b>
<i>786</i>&nbsp;            case FILTER_CATROM:
<b class="nc"><i>787</i>&nbsp;                return new CatromFilter();</b>
<i>788</i>&nbsp;            case FILTER_MITCHELL:
<b class="nc"><i>789</i>&nbsp;                return new MitchellFilter();</b>
<i>790</i>&nbsp;            case FILTER_LANCZOS:
<b class="nc"><i>791</i>&nbsp;                return new LanczosFilter();</b>
<i>792</i>&nbsp;            case FILTER_BLACKMAN_BESSEL:
<b class="nc"><i>793</i>&nbsp;                return new BlackmanBesselFilter();</b>
<i>794</i>&nbsp;            case FILTER_BLACKMAN_SINC:
<b class="nc"><i>795</i>&nbsp;                return new BlackmanSincFilter();</b>
<i>796</i>&nbsp;            default:
<b class="nc"><i>797</i>&nbsp;                throw new IllegalStateException(&quot;Unknown filter type: &quot; + pFilterType);</b>
<i>798</i>&nbsp;        }
<i>799</i>&nbsp;    }
<i>800</i>&nbsp;
<i>801</i>&nbsp;    public final BufferedImage createCompatibleDestImage(final BufferedImage pInput, final ColorModel pModel) {
<b class="nc"><i>802</i>&nbsp;        if (pInput == null) {</b>
<b class="nc"><i>803</i>&nbsp;            throw new NullPointerException(&quot;pInput == null&quot;);</b>
<i>804</i>&nbsp;        }
<i>805</i>&nbsp;
<b class="nc"><i>806</i>&nbsp;        ColorModel cm = pModel != null ? pModel : pInput.getColorModel();</b>
<i>807</i>&nbsp;
<i>808</i>&nbsp;        // TODO: Might not work with all colormodels..
<i>809</i>&nbsp;        // If indexcolormodel, we probably don&#39;t want to use that...
<i>810</i>&nbsp;        // NOTE: Either BOTH or NONE of the images must have ALPHA
<i>811</i>&nbsp;
<b class="nc"><i>812</i>&nbsp;        return new BufferedImage(cm, ImageUtil.createCompatibleWritableRaster(pInput, cm, width, height),</b>
<b class="nc"><i>813</i>&nbsp;                                 cm.isAlphaPremultiplied(), null);</b>
<i>814</i>&nbsp;    }
<i>815</i>&nbsp;
<i>816</i>&nbsp;    public RenderingHints getRenderingHints() {
<i>817</i>&nbsp;        Object value;
<b class="nc"><i>818</i>&nbsp;        switch (filterType) {</b>
<i>819</i>&nbsp;            case FILTER_UNDEFINED:
<b class="nc"><i>820</i>&nbsp;                return null;</b>
<i>821</i>&nbsp;            case FILTER_POINT:
<b class="nc"><i>822</i>&nbsp;                value = VALUE_INTERPOLATION_POINT;</b>
<b class="nc"><i>823</i>&nbsp;                break;</b>
<i>824</i>&nbsp;            case FILTER_BOX:
<b class="nc"><i>825</i>&nbsp;                value = VALUE_INTERPOLATION_BOX;</b>
<b class="nc"><i>826</i>&nbsp;                break;</b>
<i>827</i>&nbsp;            case FILTER_TRIANGLE:
<b class="nc"><i>828</i>&nbsp;                value = VALUE_INTERPOLATION_TRIANGLE;</b>
<b class="nc"><i>829</i>&nbsp;                break;</b>
<i>830</i>&nbsp;            case FILTER_HERMITE:
<b class="nc"><i>831</i>&nbsp;                value = VALUE_INTERPOLATION_HERMITE;</b>
<b class="nc"><i>832</i>&nbsp;                break;</b>
<i>833</i>&nbsp;            case FILTER_HANNING:
<b class="nc"><i>834</i>&nbsp;                value = VALUE_INTERPOLATION_HANNING;</b>
<b class="nc"><i>835</i>&nbsp;                break;</b>
<i>836</i>&nbsp;            case FILTER_HAMMING:
<b class="nc"><i>837</i>&nbsp;                value = VALUE_INTERPOLATION_HAMMING;</b>
<b class="nc"><i>838</i>&nbsp;                break;</b>
<i>839</i>&nbsp;            case FILTER_BLACKMAN:
<b class="nc"><i>840</i>&nbsp;                value = VALUE_INTERPOLATION_BLACKMAN;</b>
<b class="nc"><i>841</i>&nbsp;                break;</b>
<i>842</i>&nbsp;            case FILTER_GAUSSIAN:
<b class="nc"><i>843</i>&nbsp;                value = VALUE_INTERPOLATION_GAUSSIAN;</b>
<b class="nc"><i>844</i>&nbsp;                break;</b>
<i>845</i>&nbsp;            case FILTER_QUADRATIC:
<b class="nc"><i>846</i>&nbsp;                value = VALUE_INTERPOLATION_QUADRATIC;</b>
<b class="nc"><i>847</i>&nbsp;                break;</b>
<i>848</i>&nbsp;            case FILTER_CUBIC:
<b class="nc"><i>849</i>&nbsp;                value = VALUE_INTERPOLATION_CUBIC;</b>
<b class="nc"><i>850</i>&nbsp;                break;</b>
<i>851</i>&nbsp;            case FILTER_CATROM:
<b class="nc"><i>852</i>&nbsp;                value = VALUE_INTERPOLATION_CATROM;</b>
<b class="nc"><i>853</i>&nbsp;                break;</b>
<i>854</i>&nbsp;            case FILTER_MITCHELL:
<b class="nc"><i>855</i>&nbsp;                value = VALUE_INTERPOLATION_MITCHELL;</b>
<b class="nc"><i>856</i>&nbsp;                break;</b>
<i>857</i>&nbsp;            case FILTER_LANCZOS:
<b class="nc"><i>858</i>&nbsp;                value = VALUE_INTERPOLATION_LANCZOS;</b>
<b class="nc"><i>859</i>&nbsp;                break;</b>
<i>860</i>&nbsp;            case FILTER_BLACKMAN_BESSEL:
<b class="nc"><i>861</i>&nbsp;                value = VALUE_INTERPOLATION_BLACKMAN_BESSEL;</b>
<b class="nc"><i>862</i>&nbsp;                break;</b>
<i>863</i>&nbsp;            case FILTER_BLACKMAN_SINC:
<b class="nc"><i>864</i>&nbsp;                value = VALUE_INTERPOLATION_BLACKMAN_SINC;</b>
<b class="nc"><i>865</i>&nbsp;                break;</b>
<i>866</i>&nbsp;            default:
<b class="nc"><i>867</i>&nbsp;                throw new IllegalStateException(&quot;Unknown filter type: &quot; + filterType);</b>
<i>868</i>&nbsp;        }
<i>869</i>&nbsp;
<b class="nc"><i>870</i>&nbsp;        return new RenderingHints(KEY_RESAMPLE_INTERPOLATION, value);</b>
<i>871</i>&nbsp;    }
<i>872</i>&nbsp;
<i>873</i>&nbsp;    public Rectangle2D getBounds2D(BufferedImage src) {
<b class="nc"><i>874</i>&nbsp;        return new Rectangle(width, height);</b>
<i>875</i>&nbsp;    }
<i>876</i>&nbsp;
<i>877</i>&nbsp;    public Point2D getPoint2D(Point2D srcPt, Point2D dstPt) {
<i>878</i>&nbsp;        // TODO: This is wrong...
<i>879</i>&nbsp;        // How can I possible know how much one point is scaled, without first knowing the ration?!
<i>880</i>&nbsp;        // TODO: Maybe set all points outside of bounds, inside?
<i>881</i>&nbsp;        // TODO: Assume input image of Integer.MAX_VAL x Integer.MAX_VAL?! ;-)
<b class="nc"><i>882</i>&nbsp;        if (dstPt == null) {</b>
<b class="nc"><i>883</i>&nbsp;            if (srcPt instanceof Point2D.Double) {</b>
<b class="nc"><i>884</i>&nbsp;                dstPt = new Point2D.Double();</b>
<i>885</i>&nbsp;            }
<i>886</i>&nbsp;            else {
<b class="nc"><i>887</i>&nbsp;                dstPt = new Point2D.Float();</b>
<i>888</i>&nbsp;            }
<b class="nc"><i>889</i>&nbsp;            dstPt.setLocation(srcPt);</b>
<i>890</i>&nbsp;        }
<b class="nc"><i>891</i>&nbsp;        return dstPt;</b>
<i>892</i>&nbsp;    }
<i>893</i>&nbsp;
<i>894</i>&nbsp;    /* -- Java port of filter_rcg.c below... -- */
<i>895</i>&nbsp;
<i>896</i>&nbsp;    /*
<i>897</i>&nbsp;    *	filter function definitions
<i>898</i>&nbsp;    */
<i>899</i>&nbsp;
<i>900</i>&nbsp;    interface InterpolationFilter {
<i>901</i>&nbsp;        double filter(double t);
<i>902</i>&nbsp;
<i>903</i>&nbsp;        double support();
<i>904</i>&nbsp;    }
<i>905</i>&nbsp;
<b class="nc"><i>906</i>&nbsp;    static class HermiteFilter implements InterpolationFilter {</b>
<i>907</i>&nbsp;        public final double filter(double t) {
<i>908</i>&nbsp;            /* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 &lt;= t &lt;= 1 */
<b class="nc"><i>909</i>&nbsp;            if (t &lt; 0.0) {</b>
<b class="nc"><i>910</i>&nbsp;                t = -t;</b>
<i>911</i>&nbsp;            }
<b class="nc"><i>912</i>&nbsp;            if (t &lt; 1.0) {</b>
<b class="nc"><i>913</i>&nbsp;                return (2.0 * t - 3.0) * t * t + 1.0;</b>
<i>914</i>&nbsp;            }
<b class="nc"><i>915</i>&nbsp;            return 0.0;</b>
<i>916</i>&nbsp;        }
<i>917</i>&nbsp;
<i>918</i>&nbsp;        public final double support() {
<b class="nc"><i>919</i>&nbsp;            return 1.0;</b>
<i>920</i>&nbsp;        }
<i>921</i>&nbsp;    }
<i>922</i>&nbsp;
<i>923</i>&nbsp;    static class PointFilter extends BoxFilter {
<i>924</i>&nbsp;        public PointFilter() {
<b class="nc"><i>925</i>&nbsp;            super(0.0);</b>
<i>926</i>&nbsp;        }
<i>927</i>&nbsp;    }
<i>928</i>&nbsp;
<i>929</i>&nbsp;    static class BoxFilter implements InterpolationFilter {
<i>930</i>&nbsp;        private final double mSupport;
<i>931</i>&nbsp;
<b class="nc"><i>932</i>&nbsp;        public BoxFilter() {</b>
<b class="nc"><i>933</i>&nbsp;            mSupport = 0.5;</b>
<i>934</i>&nbsp;        }
<i>935</i>&nbsp;
<b class="nc"><i>936</i>&nbsp;        protected BoxFilter(double pSupport) {</b>
<b class="nc"><i>937</i>&nbsp;            mSupport = pSupport;</b>
<i>938</i>&nbsp;        }
<i>939</i>&nbsp;
<i>940</i>&nbsp;        public final double filter(final double t) {
<i>941</i>&nbsp;            //if ((t &gt; -0.5) &amp;&amp; (t &lt;= 0.5)) {
<b class="nc"><i>942</i>&nbsp;            if ((t &gt;= -0.5) &amp;&amp; (t &lt; 0.5)) {// ImageMagick resample.c</b>
<b class="nc"><i>943</i>&nbsp;                return 1.0;</b>
<i>944</i>&nbsp;            }
<b class="nc"><i>945</i>&nbsp;            return 0.0;</b>
<i>946</i>&nbsp;        }
<i>947</i>&nbsp;
<i>948</i>&nbsp;        public final double support() {
<b class="nc"><i>949</i>&nbsp;            return mSupport;</b>
<i>950</i>&nbsp;        }
<i>951</i>&nbsp;    }
<i>952</i>&nbsp;
<b class="nc"><i>953</i>&nbsp;    static class TriangleFilter implements InterpolationFilter {</b>
<i>954</i>&nbsp;        public final double filter(double t) {
<b class="nc"><i>955</i>&nbsp;            if (t &lt; 0.0) {</b>
<b class="nc"><i>956</i>&nbsp;                t = -t;</b>
<i>957</i>&nbsp;            }
<b class="nc"><i>958</i>&nbsp;            if (t &lt; 1.0) {</b>
<b class="nc"><i>959</i>&nbsp;                return 1.0 - t;</b>
<i>960</i>&nbsp;            }
<b class="nc"><i>961</i>&nbsp;            return 0.0;</b>
<i>962</i>&nbsp;        }
<i>963</i>&nbsp;
<i>964</i>&nbsp;        public final double support() {
<b class="nc"><i>965</i>&nbsp;            return 1.0;</b>
<i>966</i>&nbsp;        }
<i>967</i>&nbsp;    }
<i>968</i>&nbsp;
<b class="nc"><i>969</i>&nbsp;    static class QuadraticFilter implements InterpolationFilter {</b>
<i>970</i>&nbsp;        // AKA Bell
<i>971</i>&nbsp;        public final double filter(double t)/* box (*) box (*) box */ {
<b class="nc"><i>972</i>&nbsp;            if (t &lt; 0) {</b>
<b class="nc"><i>973</i>&nbsp;                t = -t;</b>
<i>974</i>&nbsp;            }
<b class="nc"><i>975</i>&nbsp;            if (t &lt; .5) {</b>
<b class="nc"><i>976</i>&nbsp;                return .75 - (t * t);</b>
<i>977</i>&nbsp;            }
<b class="nc"><i>978</i>&nbsp;            if (t &lt; 1.5) {</b>
<b class="nc"><i>979</i>&nbsp;                t = (t - 1.5);</b>
<b class="nc"><i>980</i>&nbsp;                return .5 * (t * t);</b>
<i>981</i>&nbsp;            }
<b class="nc"><i>982</i>&nbsp;            return 0.0;</b>
<i>983</i>&nbsp;        }
<i>984</i>&nbsp;
<i>985</i>&nbsp;        public final double support() {
<b class="nc"><i>986</i>&nbsp;            return 1.5;</b>
<i>987</i>&nbsp;        }
<i>988</i>&nbsp;    }
<i>989</i>&nbsp;
<b class="nc"><i>990</i>&nbsp;    static class CubicFilter implements InterpolationFilter {</b>
<i>991</i>&nbsp;        // AKA B-Spline
<i>992</i>&nbsp;        public final double filter(double t)/* box (*) box (*) box (*) box */ {
<i>993</i>&nbsp;            final double tt;
<i>994</i>&nbsp;
<b class="nc"><i>995</i>&nbsp;            if (t &lt; 0) {</b>
<b class="nc"><i>996</i>&nbsp;                t = -t;</b>
<i>997</i>&nbsp;            }
<b class="nc"><i>998</i>&nbsp;            if (t &lt; 1) {</b>
<b class="nc"><i>999</i>&nbsp;                tt = t * t;</b>
<b class="nc"><i>1000</i>&nbsp;                return (.5 * tt * t) - tt + (2.0 / 3.0);</b>
<i>1001</i>&nbsp;            }
<b class="nc"><i>1002</i>&nbsp;            else if (t &lt; 2) {</b>
<b class="nc"><i>1003</i>&nbsp;                t = 2 - t;</b>
<b class="nc"><i>1004</i>&nbsp;                return (1.0 / 6.0) * (t * t * t);</b>
<i>1005</i>&nbsp;            }
<b class="nc"><i>1006</i>&nbsp;            return 0.0;</b>
<i>1007</i>&nbsp;        }
<i>1008</i>&nbsp;
<i>1009</i>&nbsp;        public final double support() {
<b class="nc"><i>1010</i>&nbsp;            return 2.0;</b>
<i>1011</i>&nbsp;        }
<i>1012</i>&nbsp;    }
<i>1013</i>&nbsp;
<i>1014</i>&nbsp;    private static double sinc(double x) {
<b class="nc"><i>1015</i>&nbsp;        x *= Math.PI;</b>
<b class="nc"><i>1016</i>&nbsp;        if (x != 0.0) {</b>
<b class="nc"><i>1017</i>&nbsp;            return Math.sin(x) / x;</b>
<i>1018</i>&nbsp;        }
<b class="nc"><i>1019</i>&nbsp;        return 1.0;</b>
<i>1020</i>&nbsp;    }
<i>1021</i>&nbsp;
<b class="nc"><i>1022</i>&nbsp;    static class LanczosFilter implements InterpolationFilter {</b>
<i>1023</i>&nbsp;        // AKA Lanczos3
<i>1024</i>&nbsp;        public final double filter(double t) {
<b class="nc"><i>1025</i>&nbsp;            if (t &lt; 0) {</b>
<b class="nc"><i>1026</i>&nbsp;                t = -t;</b>
<i>1027</i>&nbsp;            }
<b class="nc"><i>1028</i>&nbsp;            if (t &lt; 3.0) {</b>
<b class="nc"><i>1029</i>&nbsp;                return sinc(t) * sinc(t / 3.0);</b>
<i>1030</i>&nbsp;            }
<b class="nc"><i>1031</i>&nbsp;            return 0.0;</b>
<i>1032</i>&nbsp;        }
<i>1033</i>&nbsp;
<i>1034</i>&nbsp;        public final double support() {
<b class="nc"><i>1035</i>&nbsp;            return 3.0;</b>
<i>1036</i>&nbsp;        }
<i>1037</i>&nbsp;    }
<i>1038</i>&nbsp;
<i>1039</i>&nbsp;    private final static double B = 1.0 / 3.0;
<i>1040</i>&nbsp;    private final static double C = 1.0 / 3.0;
<i>1041</i>&nbsp;    private final static double P0 = (6.0 - 2.0 * B) / 6.0;
<i>1042</i>&nbsp;    private final static double P2 = (-18.0 + 12.0 * B + 6.0 * C) / 6.0;
<i>1043</i>&nbsp;    private final static double P3 = (12.0 - 9.0 * B - 6.0 * C) / 6.0;
<i>1044</i>&nbsp;    private final static double Q0 = (8.0 * B + 24.0 * C) / 6.0;
<i>1045</i>&nbsp;    private final static double Q1 = (-12.0 * B - 48.0 * C) / 6.0;
<i>1046</i>&nbsp;    private final static double Q2 = (6.0 * B + 30.0 * C) / 6.0;
<i>1047</i>&nbsp;    private final static double Q3 = (-1.0 * B - 6.0 * C) / 6.0;
<i>1048</i>&nbsp;
<b class="nc"><i>1049</i>&nbsp;    static class MitchellFilter implements InterpolationFilter {</b>
<i>1050</i>&nbsp;        public final double filter(double t) {
<b class="nc"><i>1051</i>&nbsp;            if (t &lt; -2.0) {</b>
<b class="nc"><i>1052</i>&nbsp;                return 0.0;</b>
<i>1053</i>&nbsp;            }
<b class="nc"><i>1054</i>&nbsp;            if (t &lt; -1.0) {</b>
<b class="nc"><i>1055</i>&nbsp;                return Q0 - t * (Q1 - t * (Q2 - t * Q3));</b>
<i>1056</i>&nbsp;            }
<b class="nc"><i>1057</i>&nbsp;            if (t &lt; 0.0) {</b>
<b class="nc"><i>1058</i>&nbsp;                return P0 + t * t * (P2 - t * P3);</b>
<i>1059</i>&nbsp;            }
<b class="nc"><i>1060</i>&nbsp;            if (t &lt; 1.0) {</b>
<b class="nc"><i>1061</i>&nbsp;                return P0 + t * t * (P2 + t * P3);</b>
<i>1062</i>&nbsp;            }
<b class="nc"><i>1063</i>&nbsp;            if (t &lt; 2.0) {</b>
<b class="nc"><i>1064</i>&nbsp;                return Q0 + t * (Q1 + t * (Q2 + t * Q3));</b>
<i>1065</i>&nbsp;            }
<b class="nc"><i>1066</i>&nbsp;            return 0.0;</b>
<i>1067</i>&nbsp;        }
<i>1068</i>&nbsp;
<i>1069</i>&nbsp;        public final double support() {
<b class="nc"><i>1070</i>&nbsp;            return 2.0;</b>
<i>1071</i>&nbsp;        }
<i>1072</i>&nbsp;    }
<i>1073</i>&nbsp;
<i>1074</i>&nbsp;    private static double j1(final double t) {
<b class="nc"><i>1075</i>&nbsp;        final double[] pOne = {</b>
<i>1076</i>&nbsp;                0.581199354001606143928050809e+21,
<i>1077</i>&nbsp;                -0.6672106568924916298020941484e+20,
<i>1078</i>&nbsp;                0.2316433580634002297931815435e+19,
<i>1079</i>&nbsp;                -0.3588817569910106050743641413e+17,
<i>1080</i>&nbsp;                0.2908795263834775409737601689e+15,
<i>1081</i>&nbsp;                -0.1322983480332126453125473247e+13,
<i>1082</i>&nbsp;                0.3413234182301700539091292655e+10,
<i>1083</i>&nbsp;                -0.4695753530642995859767162166e+7,
<i>1084</i>&nbsp;                0.270112271089232341485679099e+4
<i>1085</i>&nbsp;        };
<b class="nc"><i>1086</i>&nbsp;        final double[] qOne = {</b>
<i>1087</i>&nbsp;                0.11623987080032122878585294e+22,
<i>1088</i>&nbsp;                0.1185770712190320999837113348e+20,
<i>1089</i>&nbsp;                0.6092061398917521746105196863e+17,
<i>1090</i>&nbsp;                0.2081661221307607351240184229e+15,
<i>1091</i>&nbsp;                0.5243710262167649715406728642e+12,
<i>1092</i>&nbsp;                0.1013863514358673989967045588e+10,
<i>1093</i>&nbsp;                0.1501793594998585505921097578e+7,
<i>1094</i>&nbsp;                0.1606931573481487801970916749e+4,
<i>1095</i>&nbsp;                0.1e+1
<i>1096</i>&nbsp;        };
<i>1097</i>&nbsp;
<b class="nc"><i>1098</i>&nbsp;        double p = pOne[8];</b>
<b class="nc"><i>1099</i>&nbsp;        double q = qOne[8];</b>
<b class="nc"><i>1100</i>&nbsp;        for (int i = 7; i &gt;= 0; i--) {</b>
<b class="nc"><i>1101</i>&nbsp;            p = p * t * t + pOne[i];</b>
<b class="nc"><i>1102</i>&nbsp;            q = q * t * t + qOne[i];</b>
<i>1103</i>&nbsp;        }
<b class="nc"><i>1104</i>&nbsp;        return p / q;</b>
<i>1105</i>&nbsp;    }
<i>1106</i>&nbsp;
<i>1107</i>&nbsp;    private static double p1(final double t) {
<b class="nc"><i>1108</i>&nbsp;        final double[] pOne = {</b>
<i>1109</i>&nbsp;                0.352246649133679798341724373e+5,
<i>1110</i>&nbsp;                0.62758845247161281269005675e+5,
<i>1111</i>&nbsp;                0.313539631109159574238669888e+5,
<i>1112</i>&nbsp;                0.49854832060594338434500455e+4,
<i>1113</i>&nbsp;                0.2111529182853962382105718e+3,
<i>1114</i>&nbsp;                0.12571716929145341558495e+1
<i>1115</i>&nbsp;        };
<b class="nc"><i>1116</i>&nbsp;        final double[] qOne = {</b>
<i>1117</i>&nbsp;                0.352246649133679798068390431e+5,
<i>1118</i>&nbsp;                0.626943469593560511888833731e+5,
<i>1119</i>&nbsp;                0.312404063819041039923015703e+5,
<i>1120</i>&nbsp;                0.4930396490181088979386097e+4,
<i>1121</i>&nbsp;                0.2030775189134759322293574e+3,
<i>1122</i>&nbsp;                0.1e+1
<i>1123</i>&nbsp;        };
<i>1124</i>&nbsp;
<b class="nc"><i>1125</i>&nbsp;        double p = pOne[5];</b>
<b class="nc"><i>1126</i>&nbsp;        double q = qOne[5];</b>
<b class="nc"><i>1127</i>&nbsp;        for (int i = 4; i &gt;= 0; i--) {</b>
<b class="nc"><i>1128</i>&nbsp;            p = p * (8.0 / t) * (8.0 / t) + pOne[i];</b>
<b class="nc"><i>1129</i>&nbsp;            q = q * (8.0 / t) * (8.0 / t) + qOne[i];</b>
<i>1130</i>&nbsp;        }
<b class="nc"><i>1131</i>&nbsp;        return p / q;</b>
<i>1132</i>&nbsp;    }
<i>1133</i>&nbsp;
<i>1134</i>&nbsp;    private static double q1(final double t) {
<b class="nc"><i>1135</i>&nbsp;        final double[] pOne = {</b>
<i>1136</i>&nbsp;                0.3511751914303552822533318e+3,
<i>1137</i>&nbsp;                0.7210391804904475039280863e+3,
<i>1138</i>&nbsp;                0.4259873011654442389886993e+3,
<i>1139</i>&nbsp;                0.831898957673850827325226e+2,
<i>1140</i>&nbsp;                0.45681716295512267064405e+1,
<i>1141</i>&nbsp;                0.3532840052740123642735e-1
<i>1142</i>&nbsp;        };
<b class="nc"><i>1143</i>&nbsp;        final double[] qOne = {</b>
<i>1144</i>&nbsp;                0.74917374171809127714519505e+4,
<i>1145</i>&nbsp;                0.154141773392650970499848051e+5,
<i>1146</i>&nbsp;                0.91522317015169922705904727e+4,
<i>1147</i>&nbsp;                0.18111867005523513506724158e+4,
<i>1148</i>&nbsp;                0.1038187585462133728776636e+3,
<i>1149</i>&nbsp;                0.1e+1
<i>1150</i>&nbsp;        };
<i>1151</i>&nbsp;
<b class="nc"><i>1152</i>&nbsp;        double p = pOne[5];</b>
<b class="nc"><i>1153</i>&nbsp;        double q = qOne[5];</b>
<b class="nc"><i>1154</i>&nbsp;        for (int i = 4; i &gt;= 0; i--) {</b>
<b class="nc"><i>1155</i>&nbsp;            p = p * (8.0 / t) * (8.0 / t) + pOne[i];</b>
<b class="nc"><i>1156</i>&nbsp;            q = q * (8.0 / t) * (8.0 / t) + qOne[i];</b>
<i>1157</i>&nbsp;        }
<b class="nc"><i>1158</i>&nbsp;        return p / q;</b>
<i>1159</i>&nbsp;    }
<i>1160</i>&nbsp;
<i>1161</i>&nbsp;    static double besselOrderOne(double t) {
<i>1162</i>&nbsp;        double p, q;
<i>1163</i>&nbsp;
<b class="nc"><i>1164</i>&nbsp;        if (t == 0.0) {</b>
<b class="nc"><i>1165</i>&nbsp;            return 0.0;</b>
<i>1166</i>&nbsp;        }
<b class="nc"><i>1167</i>&nbsp;        p = t;</b>
<b class="nc"><i>1168</i>&nbsp;        if (t &lt; 0.0) {</b>
<b class="nc"><i>1169</i>&nbsp;            t = -t;</b>
<i>1170</i>&nbsp;        }
<b class="nc"><i>1171</i>&nbsp;        if (t &lt; 8.0) {</b>
<b class="nc"><i>1172</i>&nbsp;            return p * j1(t);</b>
<i>1173</i>&nbsp;        }
<b class="nc"><i>1174</i>&nbsp;        q = Math.sqrt(2.0 / (Math.PI * t)) * (p1(t) * (1.0 / Math.sqrt(2.0) * (Math.sin(t) - Math.cos(t))) - 8.0 / t * q1(t) *</b>
<b class="nc"><i>1175</i>&nbsp;                (-1.0 / Math.sqrt(2.0) * (Math.sin(t) + Math.cos(t))));</b>
<b class="nc"><i>1176</i>&nbsp;        if (p &lt; 0.0) {</b>
<b class="nc"><i>1177</i>&nbsp;            q = -q;</b>
<i>1178</i>&nbsp;        }
<b class="nc"><i>1179</i>&nbsp;        return q;</b>
<i>1180</i>&nbsp;    }
<i>1181</i>&nbsp;
<i>1182</i>&nbsp;    private static double bessel(final double t) {
<b class="nc"><i>1183</i>&nbsp;        if (t == 0.0) {</b>
<b class="nc"><i>1184</i>&nbsp;            return Math.PI / 4.0;</b>
<i>1185</i>&nbsp;        }
<b class="nc"><i>1186</i>&nbsp;        return besselOrderOne(Math.PI * t) / (2.0 * t);</b>
<i>1187</i>&nbsp;    }
<i>1188</i>&nbsp;
<i>1189</i>&nbsp;    private static double blackman(final double t) {
<b class="nc"><i>1190</i>&nbsp;        return 0.42 + 0.50 * Math.cos(Math.PI * t) + 0.08 * Math.cos(2.0 * Math.PI * t);</b>
<i>1191</i>&nbsp;    }
<i>1192</i>&nbsp;
<b class="nc"><i>1193</i>&nbsp;    static class BlacmanFilter implements InterpolationFilter {</b>
<i>1194</i>&nbsp;        public final double filter(final double t) {
<b class="nc"><i>1195</i>&nbsp;            return blackman(t);</b>
<i>1196</i>&nbsp;        }
<i>1197</i>&nbsp;
<i>1198</i>&nbsp;        public final double support() {
<b class="nc"><i>1199</i>&nbsp;            return 1.0;</b>
<i>1200</i>&nbsp;        }
<i>1201</i>&nbsp;    }
<i>1202</i>&nbsp;
<b class="nc"><i>1203</i>&nbsp;    static class CatromFilter implements InterpolationFilter {</b>
<i>1204</i>&nbsp;        public final double filter(double t) {
<b class="nc"><i>1205</i>&nbsp;            if (t &lt; 0) {</b>
<b class="nc"><i>1206</i>&nbsp;                t = -t;</b>
<i>1207</i>&nbsp;            }
<b class="nc"><i>1208</i>&nbsp;            if (t &lt; 1.0) {</b>
<b class="nc"><i>1209</i>&nbsp;                return 0.5 * (2.0 + t * t * (-5.0 + t * 3.0));</b>
<i>1210</i>&nbsp;            }
<b class="nc"><i>1211</i>&nbsp;            if (t &lt; 2.0) {</b>
<b class="nc"><i>1212</i>&nbsp;                return 0.5 * (4.0 + t * (-8.0 + t * (5.0 - t)));</b>
<i>1213</i>&nbsp;            }
<b class="nc"><i>1214</i>&nbsp;            return 0.0;</b>
<i>1215</i>&nbsp;        }
<i>1216</i>&nbsp;
<i>1217</i>&nbsp;        public final double support() {
<b class="nc"><i>1218</i>&nbsp;            return 2.0;</b>
<i>1219</i>&nbsp;        }
<i>1220</i>&nbsp;    }
<i>1221</i>&nbsp;
<b class="nc"><i>1222</i>&nbsp;    static class GaussianFilter implements InterpolationFilter {</b>
<i>1223</i>&nbsp;        public final double filter(final double t) {
<b class="nc"><i>1224</i>&nbsp;            return Math.exp(-2.0 * t * t) * Math.sqrt(2.0 / Math.PI);</b>
<i>1225</i>&nbsp;        }
<i>1226</i>&nbsp;
<i>1227</i>&nbsp;        public final double support() {
<b class="nc"><i>1228</i>&nbsp;            return 1.25;</b>
<i>1229</i>&nbsp;        }
<i>1230</i>&nbsp;    }
<i>1231</i>&nbsp;
<b class="nc"><i>1232</i>&nbsp;    static class HanningFilter implements InterpolationFilter {</b>
<i>1233</i>&nbsp;        public final double filter(final double t) {
<b class="nc"><i>1234</i>&nbsp;            return 0.5 + 0.5 * Math.cos(Math.PI * t);</b>
<i>1235</i>&nbsp;        }
<i>1236</i>&nbsp;
<i>1237</i>&nbsp;        public final double support() {
<b class="nc"><i>1238</i>&nbsp;            return 1.0;</b>
<i>1239</i>&nbsp;        }
<i>1240</i>&nbsp;    }
<i>1241</i>&nbsp;
<b class="nc"><i>1242</i>&nbsp;    static class HammingFilter implements InterpolationFilter {</b>
<i>1243</i>&nbsp;        public final double filter(final double t) {
<b class="nc"><i>1244</i>&nbsp;            return 0.54 + 0.46 * Math.cos(Math.PI * t);</b>
<i>1245</i>&nbsp;        }
<i>1246</i>&nbsp;
<i>1247</i>&nbsp;        public final double support() {
<b class="nc"><i>1248</i>&nbsp;            return 1.0;</b>
<i>1249</i>&nbsp;        }
<i>1250</i>&nbsp;    }
<i>1251</i>&nbsp;
<b class="nc"><i>1252</i>&nbsp;    static class BlackmanBesselFilter implements InterpolationFilter {</b>
<i>1253</i>&nbsp;        public final double filter(final double t) {
<b class="nc"><i>1254</i>&nbsp;            return blackman(t / support()) * bessel(t);</b>
<i>1255</i>&nbsp;        }
<i>1256</i>&nbsp;
<i>1257</i>&nbsp;        public final double support() {
<b class="nc"><i>1258</i>&nbsp;            return 3.2383;</b>
<i>1259</i>&nbsp;        }
<i>1260</i>&nbsp;    }
<i>1261</i>&nbsp;
<b class="nc"><i>1262</i>&nbsp;    static class BlackmanSincFilter implements InterpolationFilter {</b>
<i>1263</i>&nbsp;        public final double filter(final double t) {
<b class="nc"><i>1264</i>&nbsp;            return blackman(t / support()) * sinc(t);</b>
<i>1265</i>&nbsp;        }
<i>1266</i>&nbsp;
<i>1267</i>&nbsp;        public final double support() {
<b class="nc"><i>1268</i>&nbsp;            return 4.0;</b>
<i>1269</i>&nbsp;        }
<i>1270</i>&nbsp;    }
<i>1271</i>&nbsp;
<i>1272</i>&nbsp;    /*
<i>1273</i>&nbsp;    *	image rescaling routine
<i>1274</i>&nbsp;    */
<b class="nc"><i>1275</i>&nbsp;    class Contributor {</b>
<i>1276</i>&nbsp;        int pixel;
<i>1277</i>&nbsp;        double weight;
<i>1278</i>&nbsp;    }
<i>1279</i>&nbsp;
<b class="nc"><i>1280</i>&nbsp;    class ContributorList {</b>
<i>1281</i>&nbsp;        int n;/* number of contributors (may be &lt; p.length) */
<i>1282</i>&nbsp;        Contributor[] p;/* pointer to list of contributions */
<i>1283</i>&nbsp;    }
<i>1284</i>&nbsp;
<i>1285</i>&nbsp;    /*
<i>1286</i>&nbsp;        round()
<i>1287</i>&nbsp;
<i>1288</i>&nbsp;        Round an FP value to its closest int representation.
<i>1289</i>&nbsp;        General routine; ideally belongs in general math lib file.
<i>1290</i>&nbsp;    */
<i>1291</i>&nbsp;
<i>1292</i>&nbsp;    static int round(double d) {
<i>1293</i>&nbsp;        // NOTE: This code seems to be faster than Math.round(double)...
<i>1294</i>&nbsp;        // Version that uses no function calls at all.
<b class="nc"><i>1295</i>&nbsp;        int n = (int) d;</b>
<b class="nc"><i>1296</i>&nbsp;        double diff = d - (double) n;</b>
<b class="nc"><i>1297</i>&nbsp;        if (diff &lt; 0) {</b>
<b class="nc"><i>1298</i>&nbsp;            diff = -diff;</b>
<i>1299</i>&nbsp;        }
<b class="nc"><i>1300</i>&nbsp;        if (diff &gt;= 0.5) {</b>
<b class="nc"><i>1301</i>&nbsp;            if (d &lt; 0) {</b>
<b class="nc"><i>1302</i>&nbsp;                n--;</b>
<i>1303</i>&nbsp;            }
<i>1304</i>&nbsp;            else {
<b class="nc"><i>1305</i>&nbsp;                n++;</b>
<i>1306</i>&nbsp;            }
<i>1307</i>&nbsp;        }
<b class="nc"><i>1308</i>&nbsp;        return n;</b>
<i>1309</i>&nbsp;    }/* round */
<i>1310</i>&nbsp;
<i>1311</i>&nbsp;    /*
<i>1312</i>&nbsp;        calcXContrib()
<i>1313</i>&nbsp;
<i>1314</i>&nbsp;        Calculates the filter weights for a single target column.
<i>1315</i>&nbsp;        contribX-&gt;p must be freed afterwards.
<i>1316</i>&nbsp;
<i>1317</i>&nbsp;        Returns -1 if error, 0 otherwise.
<i>1318</i>&nbsp;    */
<i>1319</i>&nbsp;    private ContributorList calcXContrib(double xscale, double fwidth, int srcwidth, InterpolationFilter pFilter, int i) {
<i>1320</i>&nbsp;        // TODO: What to do when fwidth &gt; srcwidyj or dstwidth
<i>1321</i>&nbsp;
<i>1322</i>&nbsp;        double width;
<i>1323</i>&nbsp;        double fscale;
<i>1324</i>&nbsp;        double center;
<i>1325</i>&nbsp;        double weight;
<i>1326</i>&nbsp;
<b class="nc"><i>1327</i>&nbsp;        ContributorList contribX = new ContributorList();</b>
<i>1328</i>&nbsp;
<b class="nc"><i>1329</i>&nbsp;        if (xscale &lt; 1.0) {</b>
<i>1330</i>&nbsp;            /* Shrinking image */
<b class="nc"><i>1331</i>&nbsp;            width = fwidth / xscale;</b>
<b class="nc"><i>1332</i>&nbsp;            fscale = 1.0 / xscale;</b>
<i>1333</i>&nbsp;
<b class="nc"><i>1334</i>&nbsp;            if (width &lt;= .5) {</b>
<i>1335</i>&nbsp;                // Reduce to point sampling.
<b class="nc"><i>1336</i>&nbsp;                width = .5 + 1.0e-6;</b>
<b class="nc"><i>1337</i>&nbsp;                fscale = 1.0;</b>
<i>1338</i>&nbsp;            }
<i>1339</i>&nbsp;
<i>1340</i>&nbsp;            //contribX.n = 0;
<b class="nc"><i>1341</i>&nbsp;            contribX.p = new Contributor[(int) (width * 2.0 + 1.0 + 0.5)];</b>
<i>1342</i>&nbsp;
<b class="nc"><i>1343</i>&nbsp;            center = (double) i / xscale;</b>
<b class="nc"><i>1344</i>&nbsp;            int left = (int) Math.ceil(center - width);// Note: Assumes width &lt;= .5</b>
<b class="nc"><i>1345</i>&nbsp;            int right = (int) Math.floor(center + width);</b>
<i>1346</i>&nbsp;
<b class="nc"><i>1347</i>&nbsp;            double density = 0.0;</b>
<i>1348</i>&nbsp;
<b class="nc"><i>1349</i>&nbsp;            for (int j = left; j &lt;= right; j++) {</b>
<b class="nc"><i>1350</i>&nbsp;                weight = center - (double) j;</b>
<b class="nc"><i>1351</i>&nbsp;                weight = pFilter.filter(weight / fscale) / fscale;</b>
<i>1352</i>&nbsp;                int n;
<b class="nc"><i>1353</i>&nbsp;                if (j &lt; 0) {</b>
<b class="nc"><i>1354</i>&nbsp;                    n = -j;</b>
<i>1355</i>&nbsp;                }
<b class="nc"><i>1356</i>&nbsp;                else if (j &gt;= srcwidth) {</b>
<b class="nc"><i>1357</i>&nbsp;                    n = (srcwidth - j) + srcwidth - 1;</b>
<i>1358</i>&nbsp;                }
<i>1359</i>&nbsp;                else {
<b class="nc"><i>1360</i>&nbsp;                    n = j;</b>
<i>1361</i>&nbsp;                }
<i>1362</i>&nbsp;
<i>1363</i>&nbsp;                /**/
<b class="nc"><i>1364</i>&nbsp;                if (n &gt;= srcwidth) {</b>
<b class="nc"><i>1365</i>&nbsp;                    n = n % srcwidth;</b>
<i>1366</i>&nbsp;                }
<b class="nc"><i>1367</i>&nbsp;                else if (n &lt; 0) {</b>
<b class="nc"><i>1368</i>&nbsp;                    n = srcwidth - 1;</b>
<i>1369</i>&nbsp;                }
<i>1370</i>&nbsp;                /**/
<i>1371</i>&nbsp;
<b class="nc"><i>1372</i>&nbsp;                int k = contribX.n++;</b>
<b class="nc"><i>1373</i>&nbsp;                contribX.p[k] = new Contributor();</b>
<b class="nc"><i>1374</i>&nbsp;                contribX.p[k].pixel = n;</b>
<b class="nc"><i>1375</i>&nbsp;                contribX.p[k].weight = weight;</b>
<i>1376</i>&nbsp;
<b class="nc"><i>1377</i>&nbsp;                density += weight;</b>
<i>1378</i>&nbsp;
<i>1379</i>&nbsp;            }
<i>1380</i>&nbsp;
<b class="nc"><i>1381</i>&nbsp;            if ((density != 0.0) &amp;&amp; (density != 1.0)) {</b>
<i>1382</i>&nbsp;                //Normalize.
<b class="nc"><i>1383</i>&nbsp;                density = 1.0 / density;</b>
<b class="nc"><i>1384</i>&nbsp;                for (int k = 0; k &lt; contribX.n; k++) {</b>
<b class="nc"><i>1385</i>&nbsp;                    contribX.p[k].weight *= density;</b>
<i>1386</i>&nbsp;                }
<i>1387</i>&nbsp;            }
<b class="nc"><i>1388</i>&nbsp;        }</b>
<i>1389</i>&nbsp;        else {
<i>1390</i>&nbsp;            /* Expanding image */
<i>1391</i>&nbsp;            //contribX.n = 0;
<b class="nc"><i>1392</i>&nbsp;            contribX.p = new Contributor[(int) (fwidth * 2.0 + 1.0 + 0.5)];</b>
<i>1393</i>&nbsp;
<b class="nc"><i>1394</i>&nbsp;            center = (double) i / xscale;</b>
<b class="nc"><i>1395</i>&nbsp;            int left = (int) Math.ceil(center - fwidth);</b>
<b class="nc"><i>1396</i>&nbsp;            int right = (int) Math.floor(center + fwidth);</b>
<i>1397</i>&nbsp;
<b class="nc"><i>1398</i>&nbsp;            for (int j = left; j &lt;= right; j++) {</b>
<b class="nc"><i>1399</i>&nbsp;                weight = center - (double) j;</b>
<b class="nc"><i>1400</i>&nbsp;                weight = pFilter.filter(weight);</b>
<i>1401</i>&nbsp;
<i>1402</i>&nbsp;                int n;
<b class="nc"><i>1403</i>&nbsp;                if (j &lt; 0) {</b>
<b class="nc"><i>1404</i>&nbsp;                    n = -j;</b>
<i>1405</i>&nbsp;                }
<b class="nc"><i>1406</i>&nbsp;                else if (j &gt;= srcwidth) {</b>
<b class="nc"><i>1407</i>&nbsp;                    n = (srcwidth - j) + srcwidth - 1;</b>
<i>1408</i>&nbsp;                }
<i>1409</i>&nbsp;                else {
<b class="nc"><i>1410</i>&nbsp;                    n = j;</b>
<i>1411</i>&nbsp;                }
<i>1412</i>&nbsp;
<i>1413</i>&nbsp;                /**/
<b class="nc"><i>1414</i>&nbsp;                if (n &gt;= srcwidth) {</b>
<b class="nc"><i>1415</i>&nbsp;                    n = n % srcwidth;</b>
<i>1416</i>&nbsp;                }
<b class="nc"><i>1417</i>&nbsp;                else if (n &lt; 0) {</b>
<b class="nc"><i>1418</i>&nbsp;                    n = srcwidth - 1;</b>
<i>1419</i>&nbsp;                }
<i>1420</i>&nbsp;                /**/
<i>1421</i>&nbsp;
<b class="nc"><i>1422</i>&nbsp;                int k = contribX.n++;</b>
<b class="nc"><i>1423</i>&nbsp;                contribX.p[k] = new Contributor();</b>
<b class="nc"><i>1424</i>&nbsp;                contribX.p[k].pixel = n;</b>
<b class="nc"><i>1425</i>&nbsp;                contribX.p[k].weight = weight;</b>
<i>1426</i>&nbsp;            }
<i>1427</i>&nbsp;        }
<b class="nc"><i>1428</i>&nbsp;        return contribX;</b>
<i>1429</i>&nbsp;    }/* calcXContrib */
<i>1430</i>&nbsp;
<i>1431</i>&nbsp;    /*
<i>1432</i>&nbsp;        resample()
<i>1433</i>&nbsp;
<i>1434</i>&nbsp;        Resizes bitmaps while resampling them.
<i>1435</i>&nbsp;    */
<i>1436</i>&nbsp;    private BufferedImage resample(BufferedImage pSource, BufferedImage pDest, InterpolationFilter pFilter) {
<b class="nc"><i>1437</i>&nbsp;        final int dstWidth = pDest.getWidth();</b>
<b class="nc"><i>1438</i>&nbsp;        final int dstHeight = pDest.getHeight();</b>
<i>1439</i>&nbsp;
<b class="nc"><i>1440</i>&nbsp;        final int srcWidth = pSource.getWidth();</b>
<b class="nc"><i>1441</i>&nbsp;        final int srcHeight = pSource.getHeight();</b>
<i>1442</i>&nbsp;
<i>1443</i>&nbsp;        /* create intermediate column to hold horizontal dst column zoom */
<b class="nc"><i>1444</i>&nbsp;        final ColorModel cm = pSource.getColorModel();</b>
<i>1445</i>&nbsp;//        final WritableRaster work = cm.createCompatibleWritableRaster(1, srcHeight);
<b class="nc"><i>1446</i>&nbsp;        final WritableRaster work = ImageUtil.createCompatibleWritableRaster(pSource, cm, 1, srcHeight);</b>
<i>1447</i>&nbsp;
<b class="nc"><i>1448</i>&nbsp;        double xscale = (double) dstWidth / (double) srcWidth;</b>
<b class="nc"><i>1449</i>&nbsp;        double yscale = (double) dstHeight / (double) srcHeight;</b>
<i>1450</i>&nbsp;
<b class="nc"><i>1451</i>&nbsp;        ContributorList[] contribY = new ContributorList[dstHeight];</b>
<b class="nc"><i>1452</i>&nbsp;        for (int i = 0; i &lt; contribY.length; i++) {</b>
<b class="nc"><i>1453</i>&nbsp;            contribY[i] = new ContributorList();</b>
<i>1454</i>&nbsp;        }
<i>1455</i>&nbsp;
<i>1456</i>&nbsp;        // TODO: What to do when fwidth &gt; srcHeight or dstHeight
<b class="nc"><i>1457</i>&nbsp;        double fwidth = pFilter.support();</b>
<b class="nc"><i>1458</i>&nbsp;        if (yscale &lt; 1.0) {</b>
<b class="nc"><i>1459</i>&nbsp;            double width = fwidth / yscale;</b>
<b class="nc"><i>1460</i>&nbsp;            double fscale = 1.0 / yscale;</b>
<i>1461</i>&nbsp;
<b class="nc"><i>1462</i>&nbsp;            if (width &lt;= .5) {</b>
<i>1463</i>&nbsp;                // Reduce to point sampling.
<b class="nc"><i>1464</i>&nbsp;                width = .5 + 1.0e-6;</b>
<b class="nc"><i>1465</i>&nbsp;                fscale = 1.0;</b>
<i>1466</i>&nbsp;            }
<i>1467</i>&nbsp;
<b class="nc"><i>1468</i>&nbsp;            for (int i = 0; i &lt; dstHeight; i++) {</b>
<i>1469</i>&nbsp;                //contribY[i].n = 0;
<b class="nc"><i>1470</i>&nbsp;                contribY[i].p = new Contributor[(int) (width * 2.0 + 1 + 0.5)];</b>
<i>1471</i>&nbsp;
<b class="nc"><i>1472</i>&nbsp;                double center = (double) i / yscale;</b>
<b class="nc"><i>1473</i>&nbsp;                int left = (int) Math.ceil(center - width);</b>
<b class="nc"><i>1474</i>&nbsp;                int right = (int) Math.floor(center + width);</b>
<i>1475</i>&nbsp;
<b class="nc"><i>1476</i>&nbsp;                double density = 0.0;</b>
<i>1477</i>&nbsp;
<b class="nc"><i>1478</i>&nbsp;                for (int j = left; j &lt;= right; j++) {</b>
<b class="nc"><i>1479</i>&nbsp;                    double weight = center - (double) j;</b>
<b class="nc"><i>1480</i>&nbsp;                    weight = pFilter.filter(weight / fscale) / fscale;</b>
<i>1481</i>&nbsp;                    int n;
<b class="nc"><i>1482</i>&nbsp;                    if (j &lt; 0) {</b>
<b class="nc"><i>1483</i>&nbsp;                        n = -j;</b>
<i>1484</i>&nbsp;                    }
<b class="nc"><i>1485</i>&nbsp;                    else if (j &gt;= srcHeight) {</b>
<b class="nc"><i>1486</i>&nbsp;                        n = (srcHeight - j) + srcHeight - 1;</b>
<i>1487</i>&nbsp;                    }
<i>1488</i>&nbsp;                    else {
<b class="nc"><i>1489</i>&nbsp;                        n = j;</b>
<i>1490</i>&nbsp;                    }
<i>1491</i>&nbsp;
<i>1492</i>&nbsp;                    /**/
<b class="nc"><i>1493</i>&nbsp;                    if (n &gt;= srcHeight) {</b>
<b class="nc"><i>1494</i>&nbsp;                        n = n % srcHeight;</b>
<i>1495</i>&nbsp;                    }
<b class="nc"><i>1496</i>&nbsp;                    else if (n &lt; 0) {</b>
<b class="nc"><i>1497</i>&nbsp;                        n = srcHeight - 1;</b>
<i>1498</i>&nbsp;                    }
<i>1499</i>&nbsp;                    /**/
<i>1500</i>&nbsp;
<b class="nc"><i>1501</i>&nbsp;                    int k = contribY[i].n++;</b>
<b class="nc"><i>1502</i>&nbsp;                    contribY[i].p[k] = new Contributor();</b>
<b class="nc"><i>1503</i>&nbsp;                    contribY[i].p[k].pixel = n;</b>
<b class="nc"><i>1504</i>&nbsp;                    contribY[i].p[k].weight = weight;</b>
<i>1505</i>&nbsp;
<b class="nc"><i>1506</i>&nbsp;                    density += weight;</b>
<i>1507</i>&nbsp;                }
<i>1508</i>&nbsp;
<b class="nc"><i>1509</i>&nbsp;                if ((density != 0.0) &amp;&amp; (density != 1.0)) {</b>
<i>1510</i>&nbsp;                    //Normalize.
<b class="nc"><i>1511</i>&nbsp;                    density = 1.0 / density;</b>
<b class="nc"><i>1512</i>&nbsp;                    for (int k = 0; k &lt; contribY[i].n; k++) {</b>
<b class="nc"><i>1513</i>&nbsp;                        contribY[i].p[k].weight *= density;</b>
<i>1514</i>&nbsp;                    }
<i>1515</i>&nbsp;                }
<i>1516</i>&nbsp;            }
<b class="nc"><i>1517</i>&nbsp;        }</b>
<i>1518</i>&nbsp;        else {
<b class="nc"><i>1519</i>&nbsp;            for (int i = 0; i &lt; dstHeight; ++i) {</b>
<i>1520</i>&nbsp;                //contribY[i].n = 0;
<b class="nc"><i>1521</i>&nbsp;                contribY[i].p = new Contributor[(int) (fwidth * 2 + 1 + 0.5)];</b>
<i>1522</i>&nbsp;
<b class="nc"><i>1523</i>&nbsp;                double center = (double) i / yscale;</b>
<b class="nc"><i>1524</i>&nbsp;                double left = Math.ceil(center - fwidth);</b>
<b class="nc"><i>1525</i>&nbsp;                double right = Math.floor(center + fwidth);</b>
<b class="nc"><i>1526</i>&nbsp;                for (int j = (int) left; j &lt;= right; ++j) {</b>
<b class="nc"><i>1527</i>&nbsp;                    double weight = center - (double) j;</b>
<b class="nc"><i>1528</i>&nbsp;                    weight = pFilter.filter(weight);</b>
<i>1529</i>&nbsp;                    int n;
<b class="nc"><i>1530</i>&nbsp;                    if (j &lt; 0) {</b>
<b class="nc"><i>1531</i>&nbsp;                        n = -j;</b>
<i>1532</i>&nbsp;                    }
<b class="nc"><i>1533</i>&nbsp;                    else if (j &gt;= srcHeight) {</b>
<b class="nc"><i>1534</i>&nbsp;                        n = (srcHeight - j) + srcHeight - 1;</b>
<i>1535</i>&nbsp;                    }
<i>1536</i>&nbsp;                    else {
<b class="nc"><i>1537</i>&nbsp;                        n = j;</b>
<i>1538</i>&nbsp;                    }
<i>1539</i>&nbsp;
<i>1540</i>&nbsp;                    /**/
<b class="nc"><i>1541</i>&nbsp;                    if (n &gt;= srcHeight) {</b>
<b class="nc"><i>1542</i>&nbsp;                        n = n % srcHeight;</b>
<i>1543</i>&nbsp;                    }
<b class="nc"><i>1544</i>&nbsp;                    else if (n &lt; 0) {</b>
<b class="nc"><i>1545</i>&nbsp;                        n = srcHeight - 1;</b>
<i>1546</i>&nbsp;                    }
<i>1547</i>&nbsp;                    /**/
<i>1548</i>&nbsp;
<b class="nc"><i>1549</i>&nbsp;                    int k = contribY[i].n++;</b>
<b class="nc"><i>1550</i>&nbsp;                    contribY[i].p[k] = new Contributor();</b>
<b class="nc"><i>1551</i>&nbsp;                    contribY[i].p[k].pixel = n;</b>
<b class="nc"><i>1552</i>&nbsp;                    contribY[i].p[k].weight = weight;</b>
<i>1553</i>&nbsp;                }
<i>1554</i>&nbsp;            }
<i>1555</i>&nbsp;        }
<i>1556</i>&nbsp;
<b class="nc"><i>1557</i>&nbsp;        final Raster raster = pSource.getRaster();</b>
<b class="nc"><i>1558</i>&nbsp;        final WritableRaster out = pDest.getRaster();</b>
<i>1559</i>&nbsp;
<i>1560</i>&nbsp;        // TODO: This is not optimal for non-byte-packed rasters...
<i>1561</i>&nbsp;        // (What? Maybe I implemented the fix, but forgot to remove the TODO?)
<b class="nc"><i>1562</i>&nbsp;        final int numChannels = raster.getNumBands();</b>
<b class="nc"><i>1563</i>&nbsp;        final int[] channelMax = new int[numChannels];</b>
<b class="nc"><i>1564</i>&nbsp;        for (int k = 0; k &lt; numChannels; k++) {</b>
<b class="nc"><i>1565</i>&nbsp;            channelMax[k] = (1 &lt;&lt; pSource.getColorModel().getComponentSize(k)) - 1;</b>
<i>1566</i>&nbsp;        }
<i>1567</i>&nbsp;
<b class="nc"><i>1568</i>&nbsp;        for (int xx = 0; xx &lt; dstWidth; xx++) {</b>
<b class="nc"><i>1569</i>&nbsp;            ContributorList contribX = calcXContrib(xscale, fwidth, srcWidth, pFilter, xx);</b>
<i>1570</i>&nbsp;            /* Apply horiz filter to make dst column in tmp. */
<b class="nc"><i>1571</i>&nbsp;            for (int k = 0; k &lt; srcHeight; k++) {</b>
<b class="nc"><i>1572</i>&nbsp;                for (int channel = 0; channel &lt; numChannels; channel++) {</b>
<i>1573</i>&nbsp;
<b class="nc"><i>1574</i>&nbsp;                    double weight = 0.0;</b>
<b class="nc"><i>1575</i>&nbsp;                    boolean bPelDelta = false;</b>
<i>1576</i>&nbsp;                    // TODO: This line throws index out of bounds, if the image
<i>1577</i>&nbsp;                    // is smaller than filter.support()
<b class="nc"><i>1578</i>&nbsp;                    double pel = raster.getSample(contribX.p[0].pixel, k, channel);</b>
<b class="nc"><i>1579</i>&nbsp;                    for (int j = 0; j &lt; contribX.n; j++) {</b>
<b class="nc"><i>1580</i>&nbsp;                        double pel2 = j == 0 ? pel : raster.getSample(contribX.p[j].pixel, k, channel);</b>
<b class="nc"><i>1581</i>&nbsp;                        if (pel2 != pel) {</b>
<b class="nc"><i>1582</i>&nbsp;                            bPelDelta = true;</b>
<i>1583</i>&nbsp;                        }
<b class="nc"><i>1584</i>&nbsp;                        weight += pel2 * contribX.p[j].weight;</b>
<i>1585</i>&nbsp;                    }
<b class="nc"><i>1586</i>&nbsp;                    weight = bPelDelta ? round(weight) : pel;</b>
<i>1587</i>&nbsp;
<b class="nc"><i>1588</i>&nbsp;                    if (weight &lt; 0) {</b>
<b class="nc"><i>1589</i>&nbsp;                        weight = 0;</b>
<i>1590</i>&nbsp;                    }
<b class="nc"><i>1591</i>&nbsp;                    else if (weight &gt; channelMax[channel]) {</b>
<b class="nc"><i>1592</i>&nbsp;                        weight = channelMax[channel];</b>
<i>1593</i>&nbsp;                    }
<i>1594</i>&nbsp;
<b class="nc"><i>1595</i>&nbsp;                    work.setSample(0, k, channel, weight);</b>
<i>1596</i>&nbsp;
<i>1597</i>&nbsp;                }
<i>1598</i>&nbsp;            }/* next row in temp column */
<i>1599</i>&nbsp;
<i>1600</i>&nbsp;            /* The temp column has been built. Now stretch it vertically into dst column. */
<b class="nc"><i>1601</i>&nbsp;            for (int i = 0; i &lt; dstHeight; i++) {</b>
<b class="nc"><i>1602</i>&nbsp;                for (int channel = 0; channel &lt; numChannels; channel++) {</b>
<i>1603</i>&nbsp;
<b class="nc"><i>1604</i>&nbsp;                    double weight = 0.0;</b>
<b class="nc"><i>1605</i>&nbsp;                    boolean bPelDelta = false;</b>
<b class="nc"><i>1606</i>&nbsp;                    double pel = work.getSample(0, contribY[i].p[0].pixel, channel);</b>
<i>1607</i>&nbsp;
<b class="nc"><i>1608</i>&nbsp;                    for (int j = 0; j &lt; contribY[i].n; j++) {</b>
<i>1609</i>&nbsp;                        // TODO: This line throws index out of bounds, if the image
<i>1610</i>&nbsp;                        // is smaller than filter.support()
<b class="nc"><i>1611</i>&nbsp;                        double pel2 = j == 0 ? pel : work.getSample(0, contribY[i].p[j].pixel, channel);</b>
<b class="nc"><i>1612</i>&nbsp;                        if (pel2 != pel) {</b>
<b class="nc"><i>1613</i>&nbsp;                            bPelDelta = true;</b>
<i>1614</i>&nbsp;                        }
<b class="nc"><i>1615</i>&nbsp;                        weight += pel2 * contribY[i].p[j].weight;</b>
<i>1616</i>&nbsp;                    }
<b class="nc"><i>1617</i>&nbsp;                    weight = bPelDelta ? round(weight) : pel;</b>
<b class="nc"><i>1618</i>&nbsp;                    if (weight &lt; 0) {</b>
<b class="nc"><i>1619</i>&nbsp;                        weight = 0;</b>
<i>1620</i>&nbsp;                    }
<b class="nc"><i>1621</i>&nbsp;                    else if (weight &gt; channelMax[channel]) {</b>
<b class="nc"><i>1622</i>&nbsp;                        weight = channelMax[channel];</b>
<i>1623</i>&nbsp;                    }
<i>1624</i>&nbsp;
<b class="nc"><i>1625</i>&nbsp;                    out.setSample(xx, i, channel, weight);</b>
<i>1626</i>&nbsp;                }
<i>1627</i>&nbsp;            }/* next dst row */
<i>1628</i>&nbsp;        }/* next dst column */
<b class="nc"><i>1629</i>&nbsp;        return pDest;</b>
<i>1630</i>&nbsp;    }/* resample */
<i>1631</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2021-02-23 16:49</div>
</div>
</body>
</html>
