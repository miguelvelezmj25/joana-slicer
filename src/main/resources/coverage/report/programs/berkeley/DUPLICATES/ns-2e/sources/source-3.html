


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > DbCacheSize</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
    @import "../../.css/highlight-idea.css";
  </style>
  <script type="text/javascript" src="../../.js/highlight.pack.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.sleepycat.je.util</a>
</div>

<h1>Coverage Summary for Class: DbCacheSize (com.sleepycat.je.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DbCacheSize</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/731)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DbCacheSize$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DbCacheSize$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DbCacheSize$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DbCacheSize$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DbCacheSize$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DbCacheSize$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/64)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/757)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<div class="sourceCode" id="sourceCode"><i class="no-highlight">1</i>&nbsp;/*-
<i class="no-highlight">2</i>&nbsp; * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.
<i class="no-highlight">3</i>&nbsp; *
<i class="no-highlight">4</i>&nbsp; * This file was distributed by Oracle as part of a version of Oracle Berkeley
<i class="no-highlight">5</i>&nbsp; * DB Java Edition made available at:
<i class="no-highlight">6</i>&nbsp; *
<i class="no-highlight">7</i>&nbsp; * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html
<i class="no-highlight">8</i>&nbsp; *
<i class="no-highlight">9</i>&nbsp; * Please see the LICENSE file included in the top-level directory of the
<i class="no-highlight">10</i>&nbsp; * appropriate version of Oracle Berkeley DB Java Edition for a copy of the
<i class="no-highlight">11</i>&nbsp; * license and additional information.
<i class="no-highlight">12</i>&nbsp; */
<i class="no-highlight">13</i>&nbsp;
<i class="no-highlight">14</i>&nbsp;package com.sleepycat.je.util;
<i class="no-highlight">15</i>&nbsp;
<i class="no-highlight">16</i>&nbsp;import java.io.File;
<i class="no-highlight">17</i>&nbsp;import java.io.IOException;
<i class="no-highlight">18</i>&nbsp;import java.io.PrintStream;
<i class="no-highlight">19</i>&nbsp;import java.math.BigInteger;
<i class="no-highlight">20</i>&nbsp;import java.text.NumberFormat;
<i class="no-highlight">21</i>&nbsp;import java.util.ArrayList;
<i class="no-highlight">22</i>&nbsp;import java.util.Collections;
<i class="no-highlight">23</i>&nbsp;import java.util.HashMap;
<i class="no-highlight">24</i>&nbsp;import java.util.List;
<i class="no-highlight">25</i>&nbsp;import java.util.Map;
<i class="no-highlight">26</i>&nbsp;import java.util.Random;
<i class="no-highlight">27</i>&nbsp;import java.util.concurrent.TimeUnit;
<i class="no-highlight">28</i>&nbsp;
<i class="no-highlight">29</i>&nbsp;import com.sleepycat.je.CacheMode;
<i class="no-highlight">30</i>&nbsp;import com.sleepycat.je.CheckpointConfig;
<i class="no-highlight">31</i>&nbsp;import com.sleepycat.je.Cursor;
<i class="no-highlight">32</i>&nbsp;import com.sleepycat.je.Database;
<i class="no-highlight">33</i>&nbsp;import com.sleepycat.je.DatabaseConfig;
<i class="no-highlight">34</i>&nbsp;import com.sleepycat.je.DatabaseEntry;
<i class="no-highlight">35</i>&nbsp;import com.sleepycat.je.DbInternal;
<i class="no-highlight">36</i>&nbsp;import com.sleepycat.je.Durability;
<i class="no-highlight">37</i>&nbsp;import com.sleepycat.je.Environment;
<i class="no-highlight">38</i>&nbsp;import com.sleepycat.je.EnvironmentConfig;
<i class="no-highlight">39</i>&nbsp;import com.sleepycat.je.EnvironmentStats;
<i class="no-highlight">40</i>&nbsp;import com.sleepycat.je.Get;
<i class="no-highlight">41</i>&nbsp;import com.sleepycat.je.LockMode;
<i class="no-highlight">42</i>&nbsp;import com.sleepycat.je.OperationResult;
<i class="no-highlight">43</i>&nbsp;import com.sleepycat.je.OperationStatus;
<i class="no-highlight">44</i>&nbsp;import com.sleepycat.je.PreloadConfig;
<i class="no-highlight">45</i>&nbsp;import com.sleepycat.je.PreloadStats;
<i class="no-highlight">46</i>&nbsp;import com.sleepycat.je.PreloadStatus;
<i class="no-highlight">47</i>&nbsp;import com.sleepycat.je.Put;
<i class="no-highlight">48</i>&nbsp;import com.sleepycat.je.ReadOptions;
<i class="no-highlight">49</i>&nbsp;import com.sleepycat.je.StatsConfig;
<i class="no-highlight">50</i>&nbsp;import com.sleepycat.je.Transaction;
<i class="no-highlight">51</i>&nbsp;import com.sleepycat.je.WriteOptions;
<i class="no-highlight">52</i>&nbsp;import com.sleepycat.je.dbi.EnvironmentImpl;
<i class="no-highlight">53</i>&nbsp;import com.sleepycat.je.evictor.Evictor;
<i class="no-highlight">54</i>&nbsp;import com.sleepycat.je.evictor.OffHeapCache;
<i class="no-highlight">55</i>&nbsp;import com.sleepycat.je.tree.BIN;
<i class="no-highlight">56</i>&nbsp;import com.sleepycat.je.tree.IN;
<i class="no-highlight">57</i>&nbsp;import com.sleepycat.je.utilint.CmdUtil;
<i class="no-highlight">58</i>&nbsp;import com.sleepycat.je.utilint.DbCacheSizeRepEnv;
<i class="no-highlight">59</i>&nbsp;import com.sleepycat.util.RuntimeExceptionWrapper;
<i class="no-highlight">60</i>&nbsp;
<i class="no-highlight">61</i>&nbsp;/**
<i class="no-highlight">62</i>&nbsp; * Estimates the in-memory cache size needed to hold a specified data set.
<i class="no-highlight">63</i>&nbsp; *
<i class="no-highlight">64</i>&nbsp; * To get an estimate of the in-memory footprint for a given database,
<i class="no-highlight">65</i>&nbsp; * specify the number of records and database characteristics and DbCacheSize
<i class="no-highlight">66</i>&nbsp; * will return an estimate of the cache size required for holding the
<i class="no-highlight">67</i>&nbsp; * database in memory. Based on this information a JE main cache size can be
<i class="no-highlight">68</i>&nbsp; * chosen and then configured using {@link EnvironmentConfig#setCacheSize} or
<i class="no-highlight">69</i>&nbsp; * using the {@link EnvironmentConfig#MAX_MEMORY} property. An off-heap cache
<i class="no-highlight">70</i>&nbsp; * may also be optionally configured using {@link
<i class="no-highlight">71</i>&nbsp; * EnvironmentConfig#setOffHeapCacheSize} or using the {@link
<i class="no-highlight">72</i>&nbsp; * EnvironmentConfig#MAX_OFF_HEAP_MEMORY} property.
<i class="no-highlight">73</i>&nbsp; *
<i class="no-highlight">74</i>&nbsp; * &lt;h4&gt;Importance of the JE Cache&lt;/h4&gt;
<i class="no-highlight">75</i>&nbsp; *
<i class="no-highlight">76</i>&nbsp; * The JE cache is not an optional cache. It is used to hold the metadata for
<i class="no-highlight">77</i>&nbsp; * accessing JE data.  In fact the JE cache size is probably the most critical
<i class="no-highlight">78</i>&nbsp; * factor to JE performance, since Btree nodes will have to be fetched during a
<i class="no-highlight">79</i>&nbsp; * database read or write operation if they are not in cache. During a single
<i class="no-highlight">80</i>&nbsp; * read or write operation, at each level of the Btree that a fetch is
<i class="no-highlight">81</i>&nbsp; * necessary, an IO may be necessary at a different disk location for each
<i class="no-highlight">82</i>&nbsp; * fetch.  In addition, if internal nodes (INs) are not in cache, then write
<i class="no-highlight">83</i>&nbsp; * operations will cause additional copies of the INs to be written to storage,
<i class="no-highlight">84</i>&nbsp; * as modified INs are moved out of the cache to make room for other parts of
<i class="no-highlight">85</i>&nbsp; * the Btree during subsequent operations.  This additional fetching and
<i class="no-highlight">86</i>&nbsp; * writing means that sizing the cache too small to hold the INs will result in
<i class="no-highlight">87</i>&nbsp; * lower operation performance.
<i class="no-highlight">88</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">89</i>&nbsp; * For best performance, all Btree nodes should fit in the JE cache, including
<i class="no-highlight">90</i>&nbsp; * leaf nodes (LNs), which hold the record data, and INs, which hold record
<i class="no-highlight">91</i>&nbsp; * keys and other metadata.  However, because system memory is limited, it is
<i class="no-highlight">92</i>&nbsp; * sometimes necessary to size the cache to hold all or at least most INs, but
<i class="no-highlight">93</i>&nbsp; * not the LNs.  This utility estimates the size necessary to hold only INs,
<i class="no-highlight">94</i>&nbsp; * and the size to hold INs and LNs.
<i class="no-highlight">95</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">96</i>&nbsp; * In addition, a common problem with large caches is that Java GC overhead
<i class="no-highlight">97</i>&nbsp; * can become significant. When a Btree node is evicted from the JE main
<i class="no-highlight">98</i>&nbsp; * cache based on JE&#39;s LRU algorithm, typically the node will have been
<i class="no-highlight">99</i>&nbsp; * resident in the JVM heap for an extended period of time, and will be
<i class="no-highlight">100</i>&nbsp; * expensive to GC. Therefore, when most or all LNs do &lt;em&gt;not&lt;/em&gt; fit in
<i class="no-highlight">101</i>&nbsp; * the main cache, using {@link CacheMode#EVICT_LN} can be beneficial to
<i class="no-highlight">102</i>&nbsp; * reduce the Java GC cost of collecting the LNs as they are moved out of the
<i class="no-highlight">103</i>&nbsp; * main cache. With EVICT_LN, the LNs only reside in the JVM heap for a short
<i class="no-highlight">104</i>&nbsp; * period and are cheap to collect. A recommended approach is to size the JE
<i class="no-highlight">105</i>&nbsp; * main cache to hold only INs, and size the Java heap to hold that amount plus
<i class="no-highlight">106</i>&nbsp; * the amount needed for GC working space and application objects, leaving
<i class="no-highlight">107</i>&nbsp; * any additional memory for use by the file system cache or the off-heap
<i class="no-highlight">108</i>&nbsp; * cache. Tests show this approach results in lower GC overhead and more
<i class="no-highlight">109</i>&nbsp; * predictable latency.
<i class="no-highlight">110</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">111</i>&nbsp; * Another issue is that 64-bit JVMs store object references using less space
<i class="no-highlight">112</i>&nbsp; * when the heap size is slightly less than 32GiB. When the heap size is 32GiB
<i class="no-highlight">113</i>&nbsp; * or more, object references are larger and less data can be cached per GiB of
<i class="no-highlight">114</i>&nbsp; * memory. This JVM feature is enabled with the
<i class="no-highlight">115</i>&nbsp; * &lt;a href=&quot;http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html#compressedOop&quot;&gt;Compressed Oops&lt;/a&gt;
<i class="no-highlight">116</i>&nbsp; * (&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;) option, although in modern JVMs it is
<i class="no-highlight">117</i>&nbsp; * on by default. Because of this factor, and because Java GC overhead is
<i class="no-highlight">118</i>&nbsp; * usually higher with larger heaps, a maximum heap size slightly less than
<i class="no-highlight">119</i>&nbsp; * 32GiB is recommended, along with Compressed Oops option.
<i class="no-highlight">120</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">121</i>&nbsp; * Of course, the JE main cache size must be less than the heap size since the
<i class="no-highlight">122</i>&nbsp; * main cache is stored in the heap. In fact, around 30% of free space should
<i class="no-highlight">123</i>&nbsp; * normally be reserved in the heap for use by Java GC, to avoid high GC
<i class="no-highlight">124</i>&nbsp; * overheads. For example, if the application uses roughly 2GiB of the heap,
<i class="no-highlight">125</i>&nbsp; * then with a 32GiB heap the JE main cache should normally be no more than
<i class="no-highlight">126</i>&nbsp; * 20GiB.
<i class="no-highlight">127</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">128</i>&nbsp; * As of JE 6.4, an optional off-heap cache may be configured in addition to
<i class="no-highlight">129</i>&nbsp; * the main JE cache. See {@link EnvironmentConfig#setOffHeapCacheSize} for
<i class="no-highlight">130</i>&nbsp; * information about the trade-offs in using an off-heap cache. When the
<i class="no-highlight">131</i>&nbsp; * {@code -offheap} argument is specified, this utility displays sizing
<i class="no-highlight">132</i>&nbsp; * information for both the main and off-heap caches. The portion of the data
<i class="no-highlight">133</i>&nbsp; * set that fits in the main cache, and the off-heap size needed to hold the
<i class="no-highlight">134</i>&nbsp; * rest of the data set, will be shown. The main cache size can be specified
<i class="no-highlight">135</i>&nbsp; * with the {@code -maincache} argument, or is implied to be the amount needed
<i class="no-highlight">136</i>&nbsp; * to hold all internal nodes if this argument is omitted. Omitting this
<i class="no-highlight">137</i>&nbsp; * argument is appropriate when {@link CacheMode#EVICT_LN} is used, since only
<i class="no-highlight">138</i>&nbsp; * internal nodes will be stored in the main cache.
<i class="no-highlight">139</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">140</i>&nbsp; * To reduce Java GC overhead, sometimes a small main cache is used along
<i class="no-highlight">141</i>&nbsp; * with an off-heap cache. Note that it is important that the size the main
<i class="no-highlight">142</i>&nbsp; * cache is at least large enough to hold all the upper INs (the INs at level
<i class="no-highlight">143</i>&nbsp; * 2 and above). This is because the off-heap cache does not contain upper
<i class="no-highlight">144</i>&nbsp; * INs, it only contains LNs and bottom internal nodes (BINs). When a level 2
<i class="no-highlight">145</i>&nbsp; * IN is evicted from the main cache, its children (BINs and LNs) in the
<i class="no-highlight">146</i>&nbsp; * off-heap cache, if any, must also be evicted, which can be undesirable,
<i class="no-highlight">147</i>&nbsp; * especially if the off-heap cache is not full. This utility displays the
<i class="no-highlight">148</i>&nbsp; * main cache size needed to hold all upper INs, and displays a warning if
<i class="no-highlight">149</i>&nbsp; * this is smaller than the main cache size specified.
<i class="no-highlight">150</i>&nbsp; *
<i class="no-highlight">151</i>&nbsp; * &lt;h4&gt;Estimating the JE Cache Size&lt;/h4&gt;
<i class="no-highlight">152</i>&nbsp; *
<i class="no-highlight">153</i>&nbsp; * Estimating JE in-memory sizes is not straightforward for several reasons.
<i class="no-highlight">154</i>&nbsp; * There is some fixed overhead for each Btree internal node, so fanout
<i class="no-highlight">155</i>&nbsp; * (maximum number of child entries per parent node) and degree of node
<i class="no-highlight">156</i>&nbsp; * sparseness impacts memory consumption. In addition, JE uses various compact
<i class="no-highlight">157</i>&nbsp; * in-memory representations that depend on key sizes, data sizes, key
<i class="no-highlight">158</i>&nbsp; * prefixing, how many child nodes are resident, etc. The physical proximity
<i class="no-highlight">159</i>&nbsp; * of node children also allows compaction of child physical address values.
<i class="no-highlight">160</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">161</i>&nbsp; * Therefore, when running this utility it is important to specify all {@link
<i class="no-highlight">162</i>&nbsp; * EnvironmentConfig} and {@link DatabaseConfig} settings that will be used in
<i class="no-highlight">163</i>&nbsp; * a production system.  The {@link EnvironmentConfig} settings are specified
<i class="no-highlight">164</i>&nbsp; * by command line options for each property, using the same names as the
<i class="no-highlight">165</i>&nbsp; * {@link EnvironmentConfig} parameter name values.  For example, {@link
<i class="no-highlight">166</i>&nbsp; * EnvironmentConfig#LOG_FILE_MAX}, which influences the amount of memory used
<i class="no-highlight">167</i>&nbsp; * to store physical record addresses, can be specified on the command line as:
<i class="no-highlight">168</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">169</i>&nbsp; * {@code -je.log.fileMax LENGTH}
<i class="no-highlight">170</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">171</i>&nbsp; * To be sure that this utility takes into account all relevant settings,
<i class="no-highlight">172</i>&nbsp; * especially as the utility is enhanced in future versions, it is best to
<i class="no-highlight">173</i>&nbsp; * specify all {@link EnvironmentConfig} settings used by the application.
<i class="no-highlight">174</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">175</i>&nbsp; * The {@link DatabaseConfig} settings are specified using command line options
<i class="no-highlight">176</i>&nbsp; * defined by this utility.
<i class="no-highlight">177</i>&nbsp; * &lt;ul&gt;
<i class="no-highlight">178</i>&nbsp; *   &lt;li&gt;{@code -nodemax ENTRIES} corresponds to {@link
<i class="no-highlight">179</i>&nbsp; *   DatabaseConfig#setNodeMaxEntries}.&lt;/li&gt;
<i class="no-highlight">180</i>&nbsp; *   &lt;li&gt;{@code -duplicates} corresponds to passing true to {@link
<i class="no-highlight">181</i>&nbsp; *   DatabaseConfig#setSortedDuplicates}.  Note that duplicates are configured
<i class="no-highlight">182</i>&nbsp; *   for DPL MANY_TO_ONE and MANY_TO_MANY secondary indices.&lt;/li&gt;
<i class="no-highlight">183</i>&nbsp; *   &lt;li&gt;{@code -keyprefix LENGTH} corresponds to passing true {@link
<i class="no-highlight">184</i>&nbsp; *   DatabaseConfig#setKeyPrefixing}.  Note that key prefixing is always used
<i class="no-highlight">185</i>&nbsp; *   when duplicates are configured.&lt;/li&gt;
<i class="no-highlight">186</i>&nbsp; * &lt;/ul&gt;
<i class="no-highlight">187</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">188</i>&nbsp; * This utility estimates the JE cache size by creating an in-memory
<i class="no-highlight">189</i>&nbsp; * Environment and Database.  In addition to the size of the Database, the
<i class="no-highlight">190</i>&nbsp; * minimum overhead for the Environment is output.  The Environment overhead
<i class="no-highlight">191</i>&nbsp; * shown is likely to be smaller than actually needed because it doesn&#39;t take
<i class="no-highlight">192</i>&nbsp; * into account use of memory by JE daemon threads (cleaner, checkpointer, etc)
<i class="no-highlight">193</i>&nbsp; * the memory used for locks that are held by application operations and
<i class="no-highlight">194</i>&nbsp; * transactions, the memory for HA network connections, etc. An additional
<i class="no-highlight">195</i>&nbsp; * amount should be added to account for these factors.
<i class="no-highlight">196</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">197</i>&nbsp; * This utility estimates the cache size for a single JE Database, or a logical
<i class="no-highlight">198</i>&nbsp; * table spread across multiple databases (as in the case of Oracle NoSQL DB,
<i class="no-highlight">199</i>&nbsp; * for example).  To estimate the size for multiple databases/tables with
<i class="no-highlight">200</i>&nbsp; * different configuration parameters or different key and data sizes, run
<i class="no-highlight">201</i>&nbsp; * this utility for each database/table and sum the sizes. If you are summing
<i class="no-highlight">202</i>&nbsp; * multiple runs for multiple databases/tables that are opened in a single
<i class="no-highlight">203</i>&nbsp; * Environment, the overhead size for the Environment should only be added once.
<i class="no-highlight">204</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">205</i>&nbsp; * In some applications with databases/tables having variable key and data
<i class="no-highlight">206</i>&nbsp; * sizes, it may be difficult to determine the key and data size input
<i class="no-highlight">207</i>&nbsp; * parameters for this utility.  If a representative data set can be created,
<i class="no-highlight">208</i>&nbsp; * one approach is to use the {@link DbPrintLog} utility with the {@code -S}
<i class="no-highlight">209</i>&nbsp; * option to find the average key and data size for all databases/tables, and
<i class="no-highlight">210</i>&nbsp; * use these values as input parameters, as if there were only a single
<i class="no-highlight">211</i>&nbsp; * database/tables.  With this approach, it is important that the {@code
<i class="no-highlight">212</i>&nbsp; * DatabaseConfig} parameters are the same, or at least similar, for all
<i class="no-highlight">213</i>&nbsp; * databases/tables.
<i class="no-highlight">214</i>&nbsp; *
<i class="no-highlight">215</i>&nbsp; * &lt;h4&gt;Key Prefixing and Compaction&lt;/h4&gt;
<i class="no-highlight">216</i>&nbsp; *
<i class="no-highlight">217</i>&nbsp; * Key prefixing deserves special consideration.  It can significantly reduce
<i class="no-highlight">218</i>&nbsp; * the size of the cache and is generally recommended; however, the benefit can
<i class="no-highlight">219</i>&nbsp; * be difficult to predict.  Key prefixing, in turn, impacts the benefits of
<i class="no-highlight">220</i>&nbsp; * key compaction, and the use of the {@link
<i class="no-highlight">221</i>&nbsp; * EnvironmentConfig#TREE_COMPACT_MAX_KEY_LENGTH} parameter.
<i class="no-highlight">222</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">223</i>&nbsp; * For a given data set, the impact of key prefixing is determined by how many
<i class="no-highlight">224</i>&nbsp; * leading bytes are in common for the keys in a single bottom internal node
<i class="no-highlight">225</i>&nbsp; * (BIN).  For example, if keys are assigned sequentially as long (8 byte)
<i class="no-highlight">226</i>&nbsp; * integers, and the {@link DatabaseConfig#setNodeMaxEntries maximum entries
<i class="no-highlight">227</i>&nbsp; * per node} is 128 (the default value) then 6 or 7 of the 8 bytes of the key
<i class="no-highlight">228</i>&nbsp; * will have a common prefix in each BIN.  Of course, when records are deleted,
<i class="no-highlight">229</i>&nbsp; * the number of prefixed bytes may be reduced because the range of key values
<i class="no-highlight">230</i>&nbsp; * in a BIN will be larger.  For this example we will assume that, on average,
<i class="no-highlight">231</i>&nbsp; * 5 bytes in each BIN are a common prefix leaving 3 bytes per key that are
<i class="no-highlight">232</i>&nbsp; * unprefixed.
<i class="no-highlight">233</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">234</i>&nbsp; * Key compaction is applied when the number of unprefixed bytes is less than a
<i class="no-highlight">235</i>&nbsp; * configured value; see {@link EnvironmentConfig#TREE_COMPACT_MAX_KEY_LENGTH}.
<i class="no-highlight">236</i>&nbsp; * In the example, the 3 unprefixed bytes per key is less than the default used
<i class="no-highlight">237</i>&nbsp; * for key compaction (16 bytes).  This means that each key will use 16 bytes
<i class="no-highlight">238</i>&nbsp; * of memory, in addition to the amount used for the prefix for each BIN.  The
<i class="no-highlight">239</i>&nbsp; * per-key overhead could be reduced by changing the {@code
<i class="no-highlight">240</i>&nbsp; * TREE_COMPACT_MAX_KEY_LENGTH} parameter to a smaller value, but care should
<i class="no-highlight">241</i>&nbsp; * be taken to ensure the compaction will be effective as keys are inserted and
<i class="no-highlight">242</i>&nbsp; * deleted over time.
<i class="no-highlight">243</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">244</i>&nbsp; * Because key prefixing depends so much on the application key format and the
<i class="no-highlight">245</i>&nbsp; * way keys are assigned, the number of expected prefix bytes must be estimated
<i class="no-highlight">246</i>&nbsp; * by the user and specified to DbCacheSize using the {@code -keyprefix}
<i class="no-highlight">247</i>&nbsp; * argument.
<i class="no-highlight">248</i>&nbsp; *
<i class="no-highlight">249</i>&nbsp; * &lt;h4&gt;Key Prefixing and Duplicates&lt;/h4&gt;
<i class="no-highlight">250</i>&nbsp; * 
<i class="no-highlight">251</i>&nbsp; * When {@link DatabaseConfig#setSortedDuplicates duplicates} are configured
<i class="no-highlight">252</i>&nbsp; * for a Database (including DPL MANY_TO_ONE and MANY_TO_MANY secondary
<i class="no-highlight">253</i>&nbsp; * indices), key prefixing is always used.  This is because the internal key in
<i class="no-highlight">254</i>&nbsp; * a duplicates database BIN is formed by concatenating the user-specified key
<i class="no-highlight">255</i>&nbsp; * and data.  In secondary databases with duplicates configured, the data is
<i class="no-highlight">256</i>&nbsp; * the primary key, so the internal key is the concatenation of the secondary
<i class="no-highlight">257</i>&nbsp; * key and the primary key.
<i class="no-highlight">258</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">259</i>&nbsp; * Key prefixing is always used for duplicates databases because prefixing is
<i class="no-highlight">260</i>&nbsp; * necessary to store keys efficiently.  When the number of duplicates per
<i class="no-highlight">261</i>&nbsp; * unique user-specified key is more than the number of entries per BIN, the
<i class="no-highlight">262</i>&nbsp; * entire user-specified key will be the common prefix.
<i class="no-highlight">263</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">264</i>&nbsp; * For example, a database that stores user information may use email address
<i class="no-highlight">265</i>&nbsp; * as the primary key and zip code as a secondary key.  The secondary index
<i class="no-highlight">266</i>&nbsp; * database will be a duplicates database, and the internal key stored in the
<i class="no-highlight">267</i>&nbsp; * BINs will be a two part key containing zip code followed by email address.
<i class="no-highlight">268</i>&nbsp; * If on average there are more users per zip code than the number of entries
<i class="no-highlight">269</i>&nbsp; * in a BIN, then the key prefix will normally be at least as long as the zip
<i class="no-highlight">270</i>&nbsp; * code key.  If there are less (more than one zip code appears in each BIN),
<i class="no-highlight">271</i>&nbsp; * then the prefix will be shorter than the zip code key.
<i class="no-highlight">272</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">273</i>&nbsp; * It is also possible for the key prefix to be larger than the secondary key.
<i class="no-highlight">274</i>&nbsp; * If for one secondary key value (one zip code) there are a large number of
<i class="no-highlight">275</i>&nbsp; * primary keys (email addresses), then a single BIN may contain concatenated
<i class="no-highlight">276</i>&nbsp; * keys that all have the same secondary key (same zip code) and have primary
<i class="no-highlight">277</i>&nbsp; * keys (email addresses) that all have some number of prefix bytes in common.
<i class="no-highlight">278</i>&nbsp; * Therefore, when duplicates are specified it is possible to specify a prefix
<i class="no-highlight">279</i>&nbsp; * size that is larger than the key size.
<i class="no-highlight">280</i>&nbsp; *
<i class="no-highlight">281</i>&nbsp; * &lt;h4&gt;Small Data Sizes and Embedded LNs&lt;/h4&gt;
<i class="no-highlight">282</i>&nbsp; *
<i class="no-highlight">283</i>&nbsp; * Another special data representation involves small data sizes. When the
<i class="no-highlight">284</i>&nbsp; * data size of a record is less than or equal to {@link
<i class="no-highlight">285</i>&nbsp; * EnvironmentConfig#TREE_MAX_EMBEDDED_LN} (16 bytes, by default), the data
<i class="no-highlight">286</i>&nbsp; * is stored (embedded) in the BIN, and the LN is not stored in cache at all.
<i class="no-highlight">287</i>&nbsp; * This increases the size needed to hold all INs in cache, but it decreases
<i class="no-highlight">288</i>&nbsp; * the size needed to hold the complete data set. If the data size specified
<i class="no-highlight">289</i>&nbsp; * when running this utility is less than or equal to TREE_MAX_EMBEDDED_LN,
<i class="no-highlight">290</i>&nbsp; * the size displayed for holding INs only will be the same as the size
<i class="no-highlight">291</i>&nbsp; * displayed for holdings INs and LNs.
<i class="no-highlight">292</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">293</i>&nbsp; * See {@link EnvironmentConfig#TREE_MAX_EMBEDDED_LN} for information about
<i class="no-highlight">294</i>&nbsp; * the trade-offs in using the embedded LNs feature.
<i class="no-highlight">295</i>&nbsp; *
<i class="no-highlight">296</i>&nbsp; * &lt;h4&gt;Record Versions and Oracle NoSQL Database&lt;/h4&gt;
<i class="no-highlight">297</i>&nbsp; *
<i class="no-highlight">298</i>&nbsp; * This note applies only to when JE is used with Oracle NoSQL DB.  In Oracle
<i class="no-highlight">299</i>&nbsp; * NoSQL DB, an internal JE environment configuration parameter is always
<i class="no-highlight">300</i>&nbsp; * used: {@code -je.rep.preserveRecordVersion true}.  This allows using record
<i class="no-highlight">301</i>&nbsp; * versions in operations such as &quot;put if version&quot;, &quot;delete if version&quot;, etc.
<i class="no-highlight">302</i>&nbsp; * This feature performs best when the cache is sized large enough to hold the
<i class="no-highlight">303</i>&nbsp; * record versions.
<i class="no-highlight">304</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">305</i>&nbsp; * When using JE with Oracle NoSQL DB, always add {@code
<i class="no-highlight">306</i>&nbsp; * -je.rep.preserveRecordVersion true} to the command line.  This ensures that
<i class="no-highlight">307</i>&nbsp; * the cache sizes calculated are correct, and also outputs an additional line
<i class="no-highlight">308</i>&nbsp; * showing how much memory is required to hold the internal nodes and record
<i class="no-highlight">309</i>&nbsp; * versions (but not the leaf nodes).  This is the minimum recommended size
<i class="no-highlight">310</i>&nbsp; * when the &quot;... if version&quot; operations are used.
<i class="no-highlight">311</i>&nbsp; *
<i class="no-highlight">312</i>&nbsp; * &lt;h4&gt;Running the DbCacheSize utility&lt;/h4&gt;
<i class="no-highlight">313</i>&nbsp; *
<i class="no-highlight">314</i>&nbsp; * Usage:
<i class="no-highlight">315</i>&nbsp; * &lt;pre&gt;
<i class="no-highlight">316</i>&nbsp; * java { com.sleepycat.je.util.DbCacheSize |
<i class="no-highlight">317</i>&nbsp; *        -jar je-&amp;lt;version&amp;gt;.jar DbCacheSize }
<i class="no-highlight">318</i>&nbsp; *  -records COUNT
<i class="no-highlight">319</i>&nbsp; *      # Total records (key/data pairs); required
<i class="no-highlight">320</i>&nbsp; *  -key BYTES
<i class="no-highlight">321</i>&nbsp; *      # Average key bytes per record; required
<i class="no-highlight">322</i>&nbsp; *  [-data BYTES]
<i class="no-highlight">323</i>&nbsp; *      # Average data bytes per record; if omitted no leaf
<i class="no-highlight">324</i>&nbsp; *      # node sizes are included in the output; required with
<i class="no-highlight">325</i>&nbsp; *      # -duplicates, and specifies the primary key length
<i class="no-highlight">326</i>&nbsp; *  [-offheap]
<i class="no-highlight">327</i>&nbsp; *      # Indicates that an off-heap cache will be used.
<i class="no-highlight">328</i>&nbsp; *  [-maincache BYTES]
<i class="no-highlight">329</i>&nbsp; *      # The size of the main cache (in the JVM heap).
<i class="no-highlight">330</i>&nbsp; *      # The size of the off-heap cache displayed is the
<i class="no-highlight">331</i>&nbsp; *      # additional amount needed to hold the data set.
<i class="no-highlight">332</i>&nbsp; *      # If omitted, the main cache size is implied to
<i class="no-highlight">333</i>&nbsp; *      # be the amount needed to hold all internal nodes.
<i class="no-highlight">334</i>&nbsp; *      # Ignored if -offheap is not also specified.
<i class="no-highlight">335</i>&nbsp; *  [-keyprefix BYTES]
<i class="no-highlight">336</i>&nbsp; *      # Expected size of the prefix for the keys in each
<i class="no-highlight">337</i>&nbsp; *      # BIN; default: key prefixing is not configured;
<i class="no-highlight">338</i>&nbsp; *      # required with -duplicates
<i class="no-highlight">339</i>&nbsp; *  [-nodemax ENTRIES]
<i class="no-highlight">340</i>&nbsp; *      # Number of entries per Btree node; default: 128
<i class="no-highlight">341</i>&nbsp; *  [-orderedinsertion]
<i class="no-highlight">342</i>&nbsp; *      # Assume ordered insertions and no deletions, so BINs
<i class="no-highlight">343</i>&nbsp; *      # are 100% full; default: unordered insertions and/or
<i class="no-highlight">344</i>&nbsp; *      # deletions, BINs are 70% full
<i class="no-highlight">345</i>&nbsp; *  [-duplicates]
<i class="no-highlight">346</i>&nbsp; *      # Indicates that sorted duplicates are used, including
<i class="no-highlight">347</i>&nbsp; *      # MANY_TO_ONE and MANY_TO_MANY secondary indices;
<i class="no-highlight">348</i>&nbsp; *      # default: false
<i class="no-highlight">349</i>&nbsp; *  [-ttl]
<i class="no-highlight">350</i>&nbsp; *      # Indicates that TTL is used; default: false
<i class="no-highlight">351</i>&nbsp; *  [-replicated]
<i class="no-highlight">352</i>&nbsp; *      # Use a ReplicatedEnvironment; default: false
<i class="no-highlight">353</i>&nbsp; *  [-ENV_PARAM_NAME VALUE]...
<i class="no-highlight">354</i>&nbsp; *      # Any number of EnvironmentConfig parameters and
<i class="no-highlight">355</i>&nbsp; *      # ReplicationConfig parameters (if -replicated)
<i class="no-highlight">356</i>&nbsp; *  [-btreeinfo]
<i class="no-highlight">357</i>&nbsp; *      # Outputs additional Btree information
<i class="no-highlight">358</i>&nbsp; *  [-outputproperties]
<i class="no-highlight">359</i>&nbsp; *      # Writes Java properties file to System.out
<i class="no-highlight">360</i>&nbsp; * &lt;/pre&gt;
<i class="no-highlight">361</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">362</i>&nbsp; * You should run DbCacheSize on the same target platform and JVM for which you
<i class="no-highlight">363</i>&nbsp; * are sizing the cache, as cache sizes will vary.  You may also need to
<i class="no-highlight">364</i>&nbsp; * specify -d32 or -d64 depending on your target, if the default JVM mode is
<i class="no-highlight">365</i>&nbsp; * not the same as the mode to be used in production.
<i class="no-highlight">366</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">367</i>&nbsp; * To take full advantage of JE cache memory, it is strongly recommended that
<i class="no-highlight">368</i>&nbsp; * &lt;a href=&quot;http://download.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html#compressedOop&quot;&gt;compressed oops&lt;/a&gt;
<i class="no-highlight">369</i>&nbsp; * (&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;) is specified when a 64-bit JVM is used
<i class="no-highlight">370</i>&nbsp; * and the maximum heap size is less than 32 GB.  As described in the
<i class="no-highlight">371</i>&nbsp; * referenced documentation, compressed oops is sometimes the default JVM mode
<i class="no-highlight">372</i>&nbsp; * even when it is not explicitly specified in the Java command.  However, if
<i class="no-highlight">373</i>&nbsp; * compressed oops is desired then it &lt;em&gt;must&lt;/em&gt; be explicitly specified in
<i class="no-highlight">374</i>&nbsp; * the Java command when running DbCacheSize or a JE application.  If it is not
<i class="no-highlight">375</i>&nbsp; * explicitly specified then JE will not aware of it, even if it is the JVM
<i class="no-highlight">376</i>&nbsp; * default setting, and will not take it into account when calculating cache
<i class="no-highlight">377</i>&nbsp; * memory sizes.
<i class="no-highlight">378</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">379</i>&nbsp; * For example:
<i class="no-highlight">380</i>&nbsp; * &lt;pre&gt;
<i class="no-highlight">381</i>&nbsp; * $ java -jar je-X.Y.Z.jar DbCacheSize -records 554719 -key 16 -data 100
<i class="no-highlight">382</i>&nbsp; *
<i class="no-highlight">383</i>&nbsp; *  === Environment Cache Overhead ===
<i class="no-highlight">384</i>&nbsp; *
<i class="no-highlight">385</i>&nbsp; *  3,157,213 minimum bytes
<i class="no-highlight">386</i>&nbsp; *
<i class="no-highlight">387</i>&nbsp; * To account for JE daemon operation, record locks, HA network connections, etc,
<i class="no-highlight">388</i>&nbsp; * a larger amount is needed in practice.
<i class="no-highlight">389</i>&nbsp; *
<i class="no-highlight">390</i>&nbsp; *  === Database Cache Size ===
<i class="no-highlight">391</i>&nbsp; *
<i class="no-highlight">392</i>&nbsp; *  Number of Bytes  Description
<i class="no-highlight">393</i>&nbsp; *  ---------------  -----------
<i class="no-highlight">394</i>&nbsp; *       23,933,736  Internal nodes only
<i class="no-highlight">395</i>&nbsp; *      107,206,616  Internal nodes and leaf nodes
<i class="no-highlight">396</i>&nbsp; * &lt;/pre&gt;
<i class="no-highlight">397</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">398</i>&nbsp; * This indicates that the minimum memory size to hold only the internal nodes
<i class="no-highlight">399</i>&nbsp; * of the Database Btree is approximately 24MB. The maximum size to hold the
<i class="no-highlight">400</i>&nbsp; * entire database, both internal nodes and data records, is approximately
<i class="no-highlight">401</i>&nbsp; * 107MB.  To either of these amounts, at least 3MB (plus more for locks and
<i class="no-highlight">402</i>&nbsp; * daemons) should be added to account for the environment overhead.
<i class="no-highlight">403</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">404</i>&nbsp; * The following example adds the use of an off-heap cache, where the main
<i class="no-highlight">405</i>&nbsp; * cache size is specified to be 30MB.
<i class="no-highlight">406</i>&nbsp; * &lt;pre&gt;
<i class="no-highlight">407</i>&nbsp; * $ java -jar je-X.Y.Z.jar DbCacheSize -records 554719 -key 16 -data 100 \
<i class="no-highlight">408</i>&nbsp; *      -offheap -maincache 30000000
<i class="no-highlight">409</i>&nbsp; *
<i class="no-highlight">410</i>&nbsp; *  === Environment Cache Overhead ===
<i class="no-highlight">411</i>&nbsp; *
<i class="no-highlight">412</i>&nbsp; *  5,205,309 minimum bytes
<i class="no-highlight">413</i>&nbsp; *
<i class="no-highlight">414</i>&nbsp; * To account for JE daemon operation, record locks, HA network connections, etc,
<i class="no-highlight">415</i>&nbsp; * a larger amount is needed in practice.
<i class="no-highlight">416</i>&nbsp; *
<i class="no-highlight">417</i>&nbsp; *  === Database Cache Size ===
<i class="no-highlight">418</i>&nbsp; *
<i class="no-highlight">419</i>&nbsp; *  Number of Bytes  Description
<i class="no-highlight">420</i>&nbsp; *  ---------------  -----------
<i class="no-highlight">421</i>&nbsp; *       23,933,736  Internal nodes only: MAIN cache
<i class="no-highlight">422</i>&nbsp; *                0  Internal nodes only: OFF-HEAP cache
<i class="no-highlight">423</i>&nbsp; *       24,794,691  Internal nodes and leaf nodes: MAIN cache
<i class="no-highlight">424</i>&nbsp; *       70,463,604  Internal nodes and leaf nodes: OFF-HEAP cache
<i class="no-highlight">425</i>&nbsp; * &lt;/pre&gt;
<i class="no-highlight">426</i>&nbsp; * There are several things of interest in the output.
<i class="no-highlight">427</i>&nbsp; * &lt;ul&gt;
<i class="no-highlight">428</i>&nbsp; *     &lt;li&gt;The environment overhead is larger because of memory used for the
<i class="no-highlight">429</i>&nbsp; *     off-heap LRU.&lt;/li&gt;
<i class="no-highlight">430</i>&nbsp; *     &lt;li&gt;To cache only internal nodes, an off-heap cache is not needed since
<i class="no-highlight">431</i>&nbsp; *     the internal nodes take around 24MB, which when added to the 5MB
<i class="no-highlight">432</i>&nbsp; *     overhead is less than the 30MB main cache specified. This is why the
<i class="no-highlight">433</i>&nbsp; *     number of bytes on the second line is zero.&lt;/li&gt;
<i class="no-highlight">434</i>&nbsp; *     &lt;li&gt;To cache all nodes, the main cache size specified should be used
<i class="no-highlight">435</i>&nbsp; *     (25MB added to the 5MB overhead is 30MB), and an off-heap cache of
<i class="no-highlight">436</i>&nbsp; *     around 71MB should be configured.&lt;/li&gt;
<i class="no-highlight">437</i>&nbsp; * &lt;/ul&gt;
<i class="no-highlight">438</i>&nbsp; *
<i class="no-highlight">439</i>&nbsp; * &lt;h4&gt;Output Properties&lt;/h4&gt;
<i class="no-highlight">440</i>&nbsp; *
<i class="no-highlight">441</i>&nbsp; * &lt;p&gt;
<i class="no-highlight">442</i>&nbsp; * When {@code -outputproperties} is specified, a list of properties in Java
<i class="no-highlight">443</i>&nbsp; * properties file format will be written to System.out, instead of the output
<i class="no-highlight">444</i>&nbsp; * shown above. The properties and their meanings are listed below.
<i class="no-highlight">445</i>&nbsp; * &lt;ul&gt;
<i class="no-highlight">446</i>&nbsp; *     &lt;li&gt;The following properties are always output (except allNodes, see
<i class="no-highlight">447</i>&nbsp; *     below). They describe the estimated size of the main cache.
<i class="no-highlight">448</i>&nbsp; *     &lt;ul&gt;
<i class="no-highlight">449</i>&nbsp; *         &lt;li&gt;&lt;strong&gt;overhead&lt;/strong&gt;: The environment overhead, as shown
<i class="no-highlight">450</i>&nbsp; *         under Environment Cache Overhead above.&lt;/li&gt;
<i class="no-highlight">451</i>&nbsp; *         &lt;li&gt;&lt;strong&gt;internalNodes&lt;/strong&gt;: The Btree size in the main
<i class="no-highlight">452</i>&nbsp; *         cache for holding the internal nodes. This is the &quot;Internal nodes
<i class="no-highlight">453</i>&nbsp; *         only&quot; line above (followed by &quot;MAIN cache&quot; when {@code -offheap} is
<i class="no-highlight">454</i>&nbsp; *         specified).&lt;/li&gt;
<i class="no-highlight">455</i>&nbsp; *         &lt;li&gt;&lt;strong&gt;internalNodesAndVersions&lt;/strong&gt;: The Btree size needed
<i class="no-highlight">456</i>&nbsp; *         to hold the internal nodes and record versions in the main cache.
<i class="no-highlight">457</i>&nbsp; *         This value is zero when {@code -offheap} is specified; currently JE
<i class="no-highlight">458</i>&nbsp; *         does not cache record versions off-heap unless their associated LNs
<i class="no-highlight">459</i>&nbsp; *         are also cached off-heap, so there is no way to calculate this
<i class="no-highlight">460</i>&nbsp; *         property.&lt;/li&gt;
<i class="no-highlight">461</i>&nbsp; *         &lt;li&gt;&lt;strong&gt;allNodes&lt;/strong&gt;: The Btree size in the main cache
<i class="no-highlight">462</i>&nbsp; *         needed to hold all nodes. This is the &quot;Internal nodes and leaf
<i class="no-highlight">463</i>&nbsp; *         nodes&quot; line above (followed by &quot;MAIN cache&quot; when {@code -offheap} is
<i class="no-highlight">464</i>&nbsp; *         specified). This property is not output unless {@code -data} is
<i class="no-highlight">465</i>&nbsp; *         specified.&lt;/li&gt;
<i class="no-highlight">466</i>&nbsp; *     &lt;/ul&gt;
<i class="no-highlight">467</i>&nbsp; *     &lt;li&gt;The following properties are output only when {@code -offheap} is
<i class="no-highlight">468</i>&nbsp; *     specified. They describe the estimated size of the off-heap cache.
<i class="no-highlight">469</i>&nbsp; *     &lt;ul&gt;
<i class="no-highlight">470</i>&nbsp; *         &lt;li&gt;&lt;strong&gt;minMainCache&lt;/strong&gt;: The minimum size of the main
<i class="no-highlight">471</i>&nbsp; *         cache needed to hold all upper INs. When the {@code -maincache}
<i class="no-highlight">472</i>&nbsp; *         value specified is less than this minimum, not all internal nodes
<i class="no-highlight">473</i>&nbsp; *         can be cached. See the discussion further above.&lt;/li&gt;
<i class="no-highlight">474</i>&nbsp; *         &lt;li&gt;&lt;strong&gt;offHeapInternalNodes&lt;/strong&gt;: The size of the off-heap
<i class="no-highlight">475</i>&nbsp; *         cache needed to hold the internal nodes. This is the &quot;Internal nodes
<i class="no-highlight">476</i>&nbsp; *         only: OFF_HEAP cache&quot; line above.&lt;/li&gt;
<i class="no-highlight">477</i>&nbsp; *         &lt;li&gt;&lt;strong&gt;offHeapAllNodes&lt;/strong&gt;: The size of the off-heap cache
<i class="no-highlight">478</i>&nbsp; *         needed to hold all nodes. This is the &quot;Internal nodes and leaf
<i class="no-highlight">479</i>&nbsp; *         nodes: OFF_HEAP cache&quot; line above. This property is not output
<i class="no-highlight">480</i>&nbsp; *         unless {@code -data} is specified.&lt;/li&gt;
<i class="no-highlight">481</i>&nbsp; *     &lt;/ul&gt;
<i class="no-highlight">482</i>&nbsp; *     &lt;li&gt;The following properties are deprecated but are output for
<i class="no-highlight">483</i>&nbsp; *     compatibility with earlier releases.
<i class="no-highlight">484</i>&nbsp; *     &lt;ul&gt;
<i class="no-highlight">485</i>&nbsp; *         &lt;li&gt; minInternalNodes, maxInternalNodes, minAllNodes, and (when
<i class="no-highlight">486</i>&nbsp; *         {@code -data} is specified) maxAllNodes&lt;/li&gt;
<i class="no-highlight">487</i>&nbsp; *     &lt;/ul&gt;
<i class="no-highlight">488</i>&nbsp; * &lt;/ul&gt;
<i class="no-highlight">489</i>&nbsp; *
<i class="no-highlight">490</i>&nbsp; * @see EnvironmentConfig#setCacheSize
<i class="no-highlight">491</i>&nbsp; * @see EnvironmentConfig#setOffHeapCacheSize
<i class="no-highlight">492</i>&nbsp; * @see CacheMode
<i class="no-highlight">493</i>&nbsp; *
<i class="no-highlight">494</i>&nbsp; * @see &lt;a href=&quot;../EnvironmentStats.html#cacheSizing&quot;&gt;Cache Statistics:
<i class="no-highlight">495</i>&nbsp; * Sizing&lt;/a&gt;
<i class="no-highlight">496</i>&nbsp; */
<b class="nc"><i class="no-highlight">497</i>&nbsp;public class DbCacheSize {</b>
<i class="no-highlight">498</i>&nbsp;
<i class="no-highlight">499</i>&nbsp;    /*
<i class="no-highlight">500</i>&nbsp;     * Undocumented command line options, used for comparing calculated to
<i class="no-highlight">501</i>&nbsp;     * actual cache sizes during testing.
<i class="no-highlight">502</i>&nbsp;     *
<i class="no-highlight">503</i>&nbsp;     *  [-measure]
<i class="no-highlight">504</i>&nbsp;     *      # Causes main program to write a database to find
<i class="no-highlight">505</i>&nbsp;     *      # the actual cache size; default: do not measure;
<i class="no-highlight">506</i>&nbsp;     *      # without -data, measures internal nodes only
<i class="no-highlight">507</i>&nbsp;     *
<i class="no-highlight">508</i>&nbsp;     * Only use -measure without -orderedinsertion when record count is 100k or
<i class="no-highlight">509</i>&nbsp;     * less, to avoid endless attempts to find an unused key value via random
<i class="no-highlight">510</i>&nbsp;     * number generation.  Also note that measured amounts will be slightly
<i class="no-highlight">511</i>&nbsp;     * less than calculated amounts because the number of prefix bytes is
<i class="no-highlight">512</i>&nbsp;     * larger for smaller key values, which are sequential integers from zero
<i class="no-highlight">513</i>&nbsp;     * to max records minus one.
<i class="no-highlight">514</i>&nbsp;     */
<i class="no-highlight">515</i>&nbsp;
<i class="no-highlight">516</i>&nbsp;    private static final NumberFormat INT_FORMAT =
<b class="nc"><i class="no-highlight">517</i>&nbsp;        NumberFormat.getIntegerInstance();</b>
<i class="no-highlight">518</i>&nbsp;
<i class="no-highlight">519</i>&nbsp;    private static final String MAIN_HEADER =
<i class="no-highlight">520</i>&nbsp;        &quot;   Number of Bytes  Description\n&quot; +
<i class="no-highlight">521</i>&nbsp;        &quot;   ---------------  -----------&quot;;
<i class="no-highlight">522</i>&nbsp;    //   123456789012345678
<i class="no-highlight">523</i>&nbsp;    //                     12
<i class="no-highlight">524</i>&nbsp;    private static final int MIN_COLUMN_WIDTH = 18;
<i class="no-highlight">525</i>&nbsp;    private static final String COLUMN_SEPARATOR = &quot;  &quot;;
<i class="no-highlight">526</i>&nbsp;
<i class="no-highlight">527</i>&nbsp;    /* IN density for non-ordered insertion. */
<i class="no-highlight">528</i>&nbsp;    private static final int DEFAULT_DENSITY = 70;
<i class="no-highlight">529</i>&nbsp;    /* IN density for ordered insertion. */
<i class="no-highlight">530</i>&nbsp;    private static final int ORDERED_DENSITY = 100;
<i class="no-highlight">531</i>&nbsp;
<i class="no-highlight">532</i>&nbsp;    /* Parameters. */
<b class="nc"><i class="no-highlight">533</i>&nbsp;    private final EnvironmentConfig envConfig = new EnvironmentConfig();</b>
<b class="nc"><i class="no-highlight">534</i>&nbsp;    private final Map&lt;String, String&gt; repParams = new HashMap&lt;&gt;();</b>
<b class="nc"><i class="no-highlight">535</i>&nbsp;    private long records = 0;</b>
<b class="nc"><i class="no-highlight">536</i>&nbsp;    private int keySize = 0;</b>
<b class="nc"><i class="no-highlight">537</i>&nbsp;    private int dataSize = -1;</b>
<b class="nc"><i class="no-highlight">538</i>&nbsp;    private boolean offHeapCache = false;</b>
<b class="nc"><i class="no-highlight">539</i>&nbsp;    private boolean assumeEvictLN = false;</b>
<b class="nc"><i class="no-highlight">540</i>&nbsp;    private long mainCacheSize = 0;</b>
<b class="nc"><i class="no-highlight">541</i>&nbsp;    private long mainDataSize = 0;</b>
<b class="nc"><i class="no-highlight">542</i>&nbsp;    private int nodeMaxEntries = 128;</b>
<b class="nc"><i class="no-highlight">543</i>&nbsp;    private int binMaxEntries = -1;</b>
<b class="nc"><i class="no-highlight">544</i>&nbsp;    private int keyPrefix = 0;</b>
<b class="nc"><i class="no-highlight">545</i>&nbsp;    private boolean orderedInsertion = false;</b>
<b class="nc"><i class="no-highlight">546</i>&nbsp;    private boolean duplicates = false;</b>
<b class="nc"><i class="no-highlight">547</i>&nbsp;    private boolean replicated = false;</b>
<b class="nc"><i class="no-highlight">548</i>&nbsp;    private boolean useTTL = false;</b>
<b class="nc"><i class="no-highlight">549</i>&nbsp;    private boolean outputProperties = false;</b>
<b class="nc"><i class="no-highlight">550</i>&nbsp;    private boolean doMeasure = false;</b>
<b class="nc"><i class="no-highlight">551</i>&nbsp;    private boolean btreeInfo = false;</b>
<i class="no-highlight">552</i>&nbsp;
<i class="no-highlight">553</i>&nbsp;    /* Calculated values. */
<i class="no-highlight">554</i>&nbsp;    private long envOverhead;
<i class="no-highlight">555</i>&nbsp;    private long uinWithTargets;
<i class="no-highlight">556</i>&nbsp;    private long uinNoTargets;
<i class="no-highlight">557</i>&nbsp;    private long uinOffHeapBINIds;
<i class="no-highlight">558</i>&nbsp;    private long binNoLNsOrVLSNs;
<i class="no-highlight">559</i>&nbsp;    private long binNoLNsWithVLSNs;
<i class="no-highlight">560</i>&nbsp;    private long binWithLNsAndVLSNs;
<i class="no-highlight">561</i>&nbsp;    private long binOffHeapWithLNIds;
<i class="no-highlight">562</i>&nbsp;    private long binOffHeapNoLNIds;
<i class="no-highlight">563</i>&nbsp;    private long binOffHeapLNs;
<i class="no-highlight">564</i>&nbsp;    private long binOffHeapLNIds;
<i class="no-highlight">565</i>&nbsp;    private long mainMinDataSize;
<i class="no-highlight">566</i>&nbsp;    private long mainNoLNsOrVLSNs;
<i class="no-highlight">567</i>&nbsp;    private long mainNoLNsWithVLSNs;
<i class="no-highlight">568</i>&nbsp;    private long mainWithLNsAndVLSNs;
<i class="no-highlight">569</i>&nbsp;    private long offHeapNoLNsOrVLSNs;
<i class="no-highlight">570</i>&nbsp;    private long offHeapWithLNsAndVLSNs;
<i class="no-highlight">571</i>&nbsp;    private long nMainBINsNoLNsOrVLSNs;
<i class="no-highlight">572</i>&nbsp;    private long nMainBINsWithLNsAndVLSNs;
<i class="no-highlight">573</i>&nbsp;    private long nMainLNsWithLNsAndVLSNs;
<i class="no-highlight">574</i>&nbsp;    private long measuredMainNoLNsOrVLSNs;
<i class="no-highlight">575</i>&nbsp;    private long measuredMainNoLNsWithVLSNs;
<i class="no-highlight">576</i>&nbsp;    private long measuredMainWithLNsAndVLSNs;
<i class="no-highlight">577</i>&nbsp;    private long measuredOffHeapNoLNsOrVLSNs;
<i class="no-highlight">578</i>&nbsp;    private long measuredOffHeapWithLNsAndVLSNs;
<i class="no-highlight">579</i>&nbsp;    private long preloadMainNoLNsOrVLSNs;
<i class="no-highlight">580</i>&nbsp;    private long preloadMainNoLNsWithVLSNs;
<i class="no-highlight">581</i>&nbsp;    private long preloadMainWithLNsAndVLSNs;
<i class="no-highlight">582</i>&nbsp;    private int nodeAvg;
<i class="no-highlight">583</i>&nbsp;    private int binAvg;
<i class="no-highlight">584</i>&nbsp;    private int btreeLevels;
<i class="no-highlight">585</i>&nbsp;    private long nBinNodes;
<i class="no-highlight">586</i>&nbsp;    private long nUinNodes;
<i class="no-highlight">587</i>&nbsp;    private long nLevel2Nodes;
<i class="no-highlight">588</i>&nbsp;
<i class="no-highlight">589</i>&nbsp;    private File tempDir;
<i class="no-highlight">590</i>&nbsp;
<b class="nc"><i class="no-highlight">591</i>&nbsp;    DbCacheSize() {</b>
<i class="no-highlight">592</i>&nbsp;    }
<i class="no-highlight">593</i>&nbsp;
<i class="no-highlight">594</i>&nbsp;    void parseArgs(String[] args) {
<b class="nc"><i class="no-highlight">595</i>&nbsp;        for (int i = 0; i &lt; args.length; i += 1) {</b>
<b class="nc"><i class="no-highlight">596</i>&nbsp;            String name = args[i];</b>
<b class="nc"><i class="no-highlight">597</i>&nbsp;            String val = null;</b>
<b class="nc"><i class="no-highlight">598</i>&nbsp;            if (i &lt; args.length - 1 &amp;&amp; !args[i + 1].startsWith(&quot;-&quot;)) {</b>
<b class="nc"><i class="no-highlight">599</i>&nbsp;                i += 1;</b>
<b class="nc"><i class="no-highlight">600</i>&nbsp;                val = args[i];</b>
<i class="no-highlight">601</i>&nbsp;            }
<b class="nc"><i class="no-highlight">602</i>&nbsp;            if (name.equals(&quot;-records&quot;)) {</b>
<b class="nc"><i class="no-highlight">603</i>&nbsp;                if (val == null) {</b>
<b class="nc"><i class="no-highlight">604</i>&nbsp;                    usage(&quot;No value after -records&quot;);</b>
<i class="no-highlight">605</i>&nbsp;                }
<i class="no-highlight">606</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">607</i>&nbsp;                    records = Long.parseLong(val);</b>
<b class="nc"><i class="no-highlight">608</i>&nbsp;                } catch (NumberFormatException e) {</b>
<b class="nc"><i class="no-highlight">609</i>&nbsp;                    usage(val + &quot; is not a number&quot;);</b>
<b class="nc"><i class="no-highlight">610</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">611</i>&nbsp;                if (records &lt;= 0) {</b>
<b class="nc"><i class="no-highlight">612</i>&nbsp;                    usage(val + &quot; is not a positive integer&quot;);</b>
<i class="no-highlight">613</i>&nbsp;                }
<b class="nc"><i class="no-highlight">614</i>&nbsp;            } else if (name.equals(&quot;-key&quot;)) {</b>
<b class="nc"><i class="no-highlight">615</i>&nbsp;                if (val == null) {</b>
<b class="nc"><i class="no-highlight">616</i>&nbsp;                    usage(&quot;No value after -key&quot;);</b>
<i class="no-highlight">617</i>&nbsp;                }
<i class="no-highlight">618</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">619</i>&nbsp;                    keySize = Integer.parseInt(val);</b>
<b class="nc"><i class="no-highlight">620</i>&nbsp;                } catch (NumberFormatException e) {</b>
<b class="nc"><i class="no-highlight">621</i>&nbsp;                    usage(val + &quot; is not a number&quot;);</b>
<b class="nc"><i class="no-highlight">622</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">623</i>&nbsp;                if (keySize &lt;= 0) {</b>
<b class="nc"><i class="no-highlight">624</i>&nbsp;                    usage(val + &quot; is not a positive integer&quot;);</b>
<i class="no-highlight">625</i>&nbsp;                }
<b class="nc"><i class="no-highlight">626</i>&nbsp;            } else if (name.equals(&quot;-data&quot;)) {</b>
<b class="nc"><i class="no-highlight">627</i>&nbsp;                if (val == null) {</b>
<b class="nc"><i class="no-highlight">628</i>&nbsp;                    usage(&quot;No value after -data&quot;);</b>
<i class="no-highlight">629</i>&nbsp;                }
<i class="no-highlight">630</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">631</i>&nbsp;                    dataSize = Integer.parseInt(val);</b>
<b class="nc"><i class="no-highlight">632</i>&nbsp;                } catch (NumberFormatException e) {</b>
<b class="nc"><i class="no-highlight">633</i>&nbsp;                    usage(val + &quot; is not a number&quot;);</b>
<b class="nc"><i class="no-highlight">634</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">635</i>&nbsp;                if (dataSize &lt; 0) {</b>
<b class="nc"><i class="no-highlight">636</i>&nbsp;                    usage(val + &quot; is not a non-negative integer&quot;);</b>
<i class="no-highlight">637</i>&nbsp;                }
<b class="nc"><i class="no-highlight">638</i>&nbsp;            } else if (name.equals(&quot;-offheap&quot;)) {</b>
<b class="nc"><i class="no-highlight">639</i>&nbsp;                if (val != null) {</b>
<b class="nc"><i class="no-highlight">640</i>&nbsp;                    usage(&quot;No value allowed after &quot; + name);</b>
<i class="no-highlight">641</i>&nbsp;                }
<b class="nc"><i class="no-highlight">642</i>&nbsp;                offHeapCache = true;</b>
<b class="nc"><i class="no-highlight">643</i>&nbsp;            } else if (name.equals(&quot;-maincache&quot;)) {</b>
<b class="nc"><i class="no-highlight">644</i>&nbsp;                if (val == null) {</b>
<b class="nc"><i class="no-highlight">645</i>&nbsp;                    usage(&quot;No value after -maincache&quot;);</b>
<i class="no-highlight">646</i>&nbsp;                }
<i class="no-highlight">647</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">648</i>&nbsp;                    mainCacheSize = Long.parseLong(val);</b>
<b class="nc"><i class="no-highlight">649</i>&nbsp;                } catch (NumberFormatException e) {</b>
<b class="nc"><i class="no-highlight">650</i>&nbsp;                    usage(val + &quot; is not a number&quot;);</b>
<b class="nc"><i class="no-highlight">651</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">652</i>&nbsp;                if (mainCacheSize &lt;= 0) {</b>
<b class="nc"><i class="no-highlight">653</i>&nbsp;                    usage(val + &quot; is not a positive integer&quot;);</b>
<i class="no-highlight">654</i>&nbsp;                }
<b class="nc"><i class="no-highlight">655</i>&nbsp;            } else if (name.equals(&quot;-keyprefix&quot;)) {</b>
<b class="nc"><i class="no-highlight">656</i>&nbsp;                if (val == null) {</b>
<b class="nc"><i class="no-highlight">657</i>&nbsp;                    usage(&quot;No value after -keyprefix&quot;);</b>
<i class="no-highlight">658</i>&nbsp;                }
<i class="no-highlight">659</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">660</i>&nbsp;                    keyPrefix = Integer.parseInt(val);</b>
<b class="nc"><i class="no-highlight">661</i>&nbsp;                } catch (NumberFormatException e) {</b>
<b class="nc"><i class="no-highlight">662</i>&nbsp;                    usage(val + &quot; is not a number&quot;);</b>
<b class="nc"><i class="no-highlight">663</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">664</i>&nbsp;                if (keyPrefix &lt; 0) {</b>
<b class="nc"><i class="no-highlight">665</i>&nbsp;                    usage(val + &quot; is not a non-negative integer&quot;);</b>
<i class="no-highlight">666</i>&nbsp;                }
<b class="nc"><i class="no-highlight">667</i>&nbsp;            } else if (name.equals(&quot;-orderedinsertion&quot;)) {</b>
<b class="nc"><i class="no-highlight">668</i>&nbsp;                if (val != null) {</b>
<b class="nc"><i class="no-highlight">669</i>&nbsp;                    usage(&quot;No value allowed after &quot; + name);</b>
<i class="no-highlight">670</i>&nbsp;                }
<b class="nc"><i class="no-highlight">671</i>&nbsp;                orderedInsertion = true;</b>
<b class="nc"><i class="no-highlight">672</i>&nbsp;            } else if (name.equals(&quot;-duplicates&quot;)) {</b>
<b class="nc"><i class="no-highlight">673</i>&nbsp;                if (val != null) {</b>
<b class="nc"><i class="no-highlight">674</i>&nbsp;                    usage(&quot;No value allowed after &quot; + name);</b>
<i class="no-highlight">675</i>&nbsp;                }
<b class="nc"><i class="no-highlight">676</i>&nbsp;                duplicates = true;</b>
<b class="nc"><i class="no-highlight">677</i>&nbsp;            } else if (name.equals(&quot;-ttl&quot;)) {</b>
<b class="nc"><i class="no-highlight">678</i>&nbsp;                if (val != null) {</b>
<b class="nc"><i class="no-highlight">679</i>&nbsp;                    usage(&quot;No value allowed after &quot; + name);</b>
<i class="no-highlight">680</i>&nbsp;                }
<b class="nc"><i class="no-highlight">681</i>&nbsp;                useTTL = true;</b>
<b class="nc"><i class="no-highlight">682</i>&nbsp;            } else if (name.equals(&quot;-replicated&quot;)) {</b>
<b class="nc"><i class="no-highlight">683</i>&nbsp;                if (val != null) {</b>
<b class="nc"><i class="no-highlight">684</i>&nbsp;                    usage(&quot;No value allowed after &quot; + name);</b>
<i class="no-highlight">685</i>&nbsp;                }
<b class="nc"><i class="no-highlight">686</i>&nbsp;                replicated = true;</b>
<b class="nc"><i class="no-highlight">687</i>&nbsp;            } else if (name.equals(&quot;-nodemax&quot;)) {</b>
<b class="nc"><i class="no-highlight">688</i>&nbsp;                if (val == null) {</b>
<b class="nc"><i class="no-highlight">689</i>&nbsp;                    usage(&quot;No value after -nodemax&quot;);</b>
<i class="no-highlight">690</i>&nbsp;                }
<i class="no-highlight">691</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">692</i>&nbsp;                    nodeMaxEntries = Integer.parseInt(val);</b>
<b class="nc"><i class="no-highlight">693</i>&nbsp;                } catch (NumberFormatException e) {</b>
<b class="nc"><i class="no-highlight">694</i>&nbsp;                    usage(val + &quot; is not a number&quot;);</b>
<b class="nc"><i class="no-highlight">695</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">696</i>&nbsp;                if (nodeMaxEntries &lt;= 0) {</b>
<b class="nc"><i class="no-highlight">697</i>&nbsp;                    usage(val + &quot; is not a positive integer&quot;);</b>
<i class="no-highlight">698</i>&nbsp;                }
<b class="nc"><i class="no-highlight">699</i>&nbsp;            } else if (name.equals(&quot;-binmax&quot;)) {</b>
<b class="nc"><i class="no-highlight">700</i>&nbsp;                if (val == null) {</b>
<b class="nc"><i class="no-highlight">701</i>&nbsp;                    usage(&quot;No value after -binmax&quot;);</b>
<i class="no-highlight">702</i>&nbsp;                }
<i class="no-highlight">703</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">704</i>&nbsp;                    binMaxEntries = Integer.parseInt(val);</b>
<b class="nc"><i class="no-highlight">705</i>&nbsp;                } catch (NumberFormatException e) {</b>
<b class="nc"><i class="no-highlight">706</i>&nbsp;                    usage(val + &quot; is not a number&quot;);</b>
<b class="nc"><i class="no-highlight">707</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">708</i>&nbsp;                if (binMaxEntries &lt;= 0) {</b>
<b class="nc"><i class="no-highlight">709</i>&nbsp;                    usage(val + &quot; is not a positive integer&quot;);</b>
<i class="no-highlight">710</i>&nbsp;                }
<b class="nc"><i class="no-highlight">711</i>&nbsp;            } else if (name.equals(&quot;-density&quot;)) {</b>
<b class="nc"><i class="no-highlight">712</i>&nbsp;                usage</b>
<b class="nc"><i class="no-highlight">713</i>&nbsp;                    (&quot;-density is no longer supported, see -orderedinsertion&quot;);</b>
<b class="nc"><i class="no-highlight">714</i>&nbsp;            } else if (name.equals(&quot;-overhead&quot;)) {</b>
<b class="nc"><i class="no-highlight">715</i>&nbsp;                usage(&quot;-overhead is no longer supported&quot;);</b>
<b class="nc"><i class="no-highlight">716</i>&nbsp;            } else if (name.startsWith(&quot;-je.&quot;)) {</b>
<b class="nc"><i class="no-highlight">717</i>&nbsp;                if (val == null) {</b>
<b class="nc"><i class="no-highlight">718</i>&nbsp;                    usage(&quot;No value after &quot; + name);</b>
<i class="no-highlight">719</i>&nbsp;                }
<b class="nc"><i class="no-highlight">720</i>&nbsp;                if (name.startsWith(&quot;-je.rep.&quot;)) {</b>
<b class="nc"><i class="no-highlight">721</i>&nbsp;                    repParams.put(name.substring(1), val);</b>
<i class="no-highlight">722</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">723</i>&nbsp;                    envConfig.setConfigParam(name.substring(1), val);</b>
<i class="no-highlight">724</i>&nbsp;                }
<b class="nc"><i class="no-highlight">725</i>&nbsp;            } else if (name.equals(&quot;-measure&quot;)) {</b>
<b class="nc"><i class="no-highlight">726</i>&nbsp;                if (val != null) {</b>
<b class="nc"><i class="no-highlight">727</i>&nbsp;                    usage(&quot;No value allowed after &quot; + name);</b>
<i class="no-highlight">728</i>&nbsp;                }
<b class="nc"><i class="no-highlight">729</i>&nbsp;                doMeasure = true;</b>
<b class="nc"><i class="no-highlight">730</i>&nbsp;            } else if (name.equals(&quot;-outputproperties&quot;)) {</b>
<b class="nc"><i class="no-highlight">731</i>&nbsp;                if (val != null) {</b>
<b class="nc"><i class="no-highlight">732</i>&nbsp;                    usage(&quot;No value allowed after &quot; + name);</b>
<i class="no-highlight">733</i>&nbsp;                }
<b class="nc"><i class="no-highlight">734</i>&nbsp;                outputProperties = true;</b>
<b class="nc"><i class="no-highlight">735</i>&nbsp;            } else if (name.equals(&quot;-btreeinfo&quot;)) {</b>
<b class="nc"><i class="no-highlight">736</i>&nbsp;                if (val != null) {</b>
<b class="nc"><i class="no-highlight">737</i>&nbsp;                    usage(&quot;No value allowed after &quot; + name);</b>
<i class="no-highlight">738</i>&nbsp;                }
<b class="nc"><i class="no-highlight">739</i>&nbsp;                btreeInfo = true;</b>
<i class="no-highlight">740</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">741</i>&nbsp;                usage(&quot;Unknown arg: &quot; + name);</b>
<i class="no-highlight">742</i>&nbsp;            }
<i class="no-highlight">743</i>&nbsp;        }
<i class="no-highlight">744</i>&nbsp;
<b class="nc"><i class="no-highlight">745</i>&nbsp;        if (records == 0) {</b>
<b class="nc"><i class="no-highlight">746</i>&nbsp;            usage(&quot;-records not specified&quot;);</b>
<i class="no-highlight">747</i>&nbsp;        }
<b class="nc"><i class="no-highlight">748</i>&nbsp;        if (keySize == 0) {</b>
<b class="nc"><i class="no-highlight">749</i>&nbsp;            usage(&quot;-key not specified&quot;);</b>
<i class="no-highlight">750</i>&nbsp;        }
<i class="no-highlight">751</i>&nbsp;    }
<i class="no-highlight">752</i>&nbsp;
<i class="no-highlight">753</i>&nbsp;    void cleanup() {
<b class="nc"><i class="no-highlight">754</i>&nbsp;        if (tempDir != null) {</b>
<b class="nc"><i class="no-highlight">755</i>&nbsp;            emptyTempDir();</b>
<b class="nc"><i class="no-highlight">756</i>&nbsp;            tempDir.delete();</b>
<i class="no-highlight">757</i>&nbsp;        }
<i class="no-highlight">758</i>&nbsp;    }
<i class="no-highlight">759</i>&nbsp;
<i class="no-highlight">760</i>&nbsp;    long getMainNoLNsOrVLSNs() {
<b class="nc"><i class="no-highlight">761</i>&nbsp;        return mainNoLNsOrVLSNs;</b>
<i class="no-highlight">762</i>&nbsp;    }
<i class="no-highlight">763</i>&nbsp;
<i class="no-highlight">764</i>&nbsp;    long getMainNoLNsWithVLSNs() {
<b class="nc"><i class="no-highlight">765</i>&nbsp;        return mainNoLNsWithVLSNs;</b>
<i class="no-highlight">766</i>&nbsp;    }
<i class="no-highlight">767</i>&nbsp;
<i class="no-highlight">768</i>&nbsp;    long getOffHeapWithLNsAndVLSNs() {
<b class="nc"><i class="no-highlight">769</i>&nbsp;        return offHeapWithLNsAndVLSNs;</b>
<i class="no-highlight">770</i>&nbsp;    }
<i class="no-highlight">771</i>&nbsp;
<i class="no-highlight">772</i>&nbsp;    long getOffHeapNoLNsOrVLSNs() {
<b class="nc"><i class="no-highlight">773</i>&nbsp;        return offHeapNoLNsOrVLSNs;</b>
<i class="no-highlight">774</i>&nbsp;    }
<i class="no-highlight">775</i>&nbsp;
<i class="no-highlight">776</i>&nbsp;    long getMainWithLNsAndVLSNs() {
<b class="nc"><i class="no-highlight">777</i>&nbsp;        return mainWithLNsAndVLSNs;</b>
<i class="no-highlight">778</i>&nbsp;    }
<i class="no-highlight">779</i>&nbsp;
<i class="no-highlight">780</i>&nbsp;    long getMeasuredMainNoLNsOrVLSNs() {
<b class="nc"><i class="no-highlight">781</i>&nbsp;        return measuredMainNoLNsOrVLSNs;</b>
<i class="no-highlight">782</i>&nbsp;    }
<i class="no-highlight">783</i>&nbsp;
<i class="no-highlight">784</i>&nbsp;    long getMeasuredMainNoLNsWithVLSNs() {
<b class="nc"><i class="no-highlight">785</i>&nbsp;        return measuredMainNoLNsWithVLSNs;</b>
<i class="no-highlight">786</i>&nbsp;    }
<i class="no-highlight">787</i>&nbsp;
<i class="no-highlight">788</i>&nbsp;    long getMeasuredMainWithLNsAndVLSNs() {
<b class="nc"><i class="no-highlight">789</i>&nbsp;        return measuredMainWithLNsAndVLSNs;</b>
<i class="no-highlight">790</i>&nbsp;    }
<i class="no-highlight">791</i>&nbsp;
<i class="no-highlight">792</i>&nbsp;    long getMeasuredOffHeapNoLNsOrVLSNs() {
<b class="nc"><i class="no-highlight">793</i>&nbsp;        return measuredOffHeapNoLNsOrVLSNs;</b>
<i class="no-highlight">794</i>&nbsp;    }
<i class="no-highlight">795</i>&nbsp;
<i class="no-highlight">796</i>&nbsp;    long getMeasuredOffHeapWithLNsAndVLSNs() {
<b class="nc"><i class="no-highlight">797</i>&nbsp;        return measuredOffHeapWithLNsAndVLSNs;</b>
<i class="no-highlight">798</i>&nbsp;    }
<i class="no-highlight">799</i>&nbsp;
<i class="no-highlight">800</i>&nbsp;    long getPreloadMainNoLNsOrVLSNs() {
<b class="nc"><i class="no-highlight">801</i>&nbsp;        return preloadMainNoLNsOrVLSNs;</b>
<i class="no-highlight">802</i>&nbsp;    }
<i class="no-highlight">803</i>&nbsp;
<i class="no-highlight">804</i>&nbsp;    long getPreloadMainNoLNsWithVLSNs() {
<b class="nc"><i class="no-highlight">805</i>&nbsp;        return preloadMainNoLNsWithVLSNs;</b>
<i class="no-highlight">806</i>&nbsp;    }
<i class="no-highlight">807</i>&nbsp;
<i class="no-highlight">808</i>&nbsp;    long getPreloadMainWithLNsAndVLSNs() {
<b class="nc"><i class="no-highlight">809</i>&nbsp;        return preloadMainWithLNsAndVLSNs;</b>
<i class="no-highlight">810</i>&nbsp;    }
<i class="no-highlight">811</i>&nbsp;
<i class="no-highlight">812</i>&nbsp;    /**
<i class="no-highlight">813</i>&nbsp;     * Runs DbCacheSize as a command line utility.
<i class="no-highlight">814</i>&nbsp;     * For command usage, see {@link DbCacheSize class description}.
<i class="no-highlight">815</i>&nbsp;     */
<i class="no-highlight">816</i>&nbsp;    public static void main(final String[] args)
<i class="no-highlight">817</i>&nbsp;        throws Throwable {
<i class="no-highlight">818</i>&nbsp;
<b class="nc"><i class="no-highlight">819</i>&nbsp;        final DbCacheSize dbCacheSize = new DbCacheSize();</b>
<i class="no-highlight">820</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">821</i>&nbsp;            dbCacheSize.parseArgs(args);</b>
<b class="nc"><i class="no-highlight">822</i>&nbsp;            dbCacheSize.calculateCacheSizes();</b>
<b class="nc"><i class="no-highlight">823</i>&nbsp;            if (dbCacheSize.outputProperties) {</b>
<b class="nc"><i class="no-highlight">824</i>&nbsp;                dbCacheSize.printProperties(System.out);</b>
<i class="no-highlight">825</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">826</i>&nbsp;                dbCacheSize.printCacheSizes(System.out);</b>
<i class="no-highlight">827</i>&nbsp;            }
<b class="nc"><i class="no-highlight">828</i>&nbsp;            if (dbCacheSize.doMeasure) {</b>
<b class="nc"><i class="no-highlight">829</i>&nbsp;                dbCacheSize.measure(System.out);</b>
<i class="no-highlight">830</i>&nbsp;            }
<i class="no-highlight">831</i>&nbsp;        } finally {
<b class="nc"><i class="no-highlight">832</i>&nbsp;            dbCacheSize.cleanup();</b>
<b class="nc"><i class="no-highlight">833</i>&nbsp;        }</b>
<i class="no-highlight">834</i>&nbsp;    }
<i class="no-highlight">835</i>&nbsp;
<i class="no-highlight">836</i>&nbsp;    /**
<i class="no-highlight">837</i>&nbsp;     * Prints usage and calls System.exit.
<i class="no-highlight">838</i>&nbsp;     */
<i class="no-highlight">839</i>&nbsp;    private static void usage(final String msg) {
<i class="no-highlight">840</i>&nbsp;
<b class="nc"><i class="no-highlight">841</i>&nbsp;        if (msg != null) {</b>
<b class="nc"><i class="no-highlight">842</i>&nbsp;            System.out.println(msg);</b>
<i class="no-highlight">843</i>&nbsp;        }
<i class="no-highlight">844</i>&nbsp;
<b class="nc"><i class="no-highlight">845</i>&nbsp;        System.out.println</b>
<b class="nc"><i class="no-highlight">846</i>&nbsp;            (&quot;usage:&quot; +</b>
<b class="nc"><i class="no-highlight">847</i>&nbsp;             &quot;\njava &quot;  + CmdUtil.getJavaCommand(DbCacheSize.class) +</b>
<i class="no-highlight">848</i>&nbsp;             &quot;\n   -records &lt;count&gt;&quot; +
<i class="no-highlight">849</i>&nbsp;             &quot;\n      # Total records (key/data pairs); required&quot; +
<i class="no-highlight">850</i>&nbsp;             &quot;\n   -key &lt;bytes&gt; &quot; +
<i class="no-highlight">851</i>&nbsp;             &quot;\n      # Average key bytes per record; required&quot; +
<i class="no-highlight">852</i>&nbsp;             &quot;\n  [-data &lt;bytes&gt;]&quot; +
<i class="no-highlight">853</i>&nbsp;             &quot;\n      # Average data bytes per record; if omitted no leaf&quot; +
<i class="no-highlight">854</i>&nbsp;             &quot;\n      # node sizes are included in the output; required with&quot; +
<i class="no-highlight">855</i>&nbsp;             &quot;\n      # -duplicates, and specifies the primary key length&quot; +
<i class="no-highlight">856</i>&nbsp;             &quot;\n  [-offheap]&quot; +
<i class="no-highlight">857</i>&nbsp;             &quot;\n      # Indicates that an off-heap cache will be used.&quot; +
<i class="no-highlight">858</i>&nbsp;             &quot;\n  [-maincache &lt;bytes&gt;]&quot; +
<i class="no-highlight">859</i>&nbsp;             &quot;\n      # The size of the main cache (in the JVM heap).&quot; +
<i class="no-highlight">860</i>&nbsp;             &quot;\n      # The size of the off-heap cache displayed is the&quot; +
<i class="no-highlight">861</i>&nbsp;             &quot;\n      # additional amount needed to hold the data set.&quot; +
<i class="no-highlight">862</i>&nbsp;             &quot;\n      # If omitted, the main cache size is implied to&quot; +
<i class="no-highlight">863</i>&nbsp;             &quot;\n      # be the amount needed to hold all internal nodes.&quot; +
<i class="no-highlight">864</i>&nbsp;             &quot;\n      # Ignored if -offheap is not also specified.&quot; +
<i class="no-highlight">865</i>&nbsp;             &quot;\n  [-keyprefix &lt;bytes&gt;]&quot; +
<i class="no-highlight">866</i>&nbsp;             &quot;\n      # Expected size of the prefix for the keys in each&quot; +
<i class="no-highlight">867</i>&nbsp;             &quot;\n      # BIN; default: zero, key prefixing is not configured;&quot; +
<i class="no-highlight">868</i>&nbsp;             &quot;\n      # required with -duplicates&quot; +
<i class="no-highlight">869</i>&nbsp;             &quot;\n  [-nodemax &lt;entries&gt;]&quot; +
<i class="no-highlight">870</i>&nbsp;             &quot;\n      # Number of entries per Btree node; default: 128&quot; +
<i class="no-highlight">871</i>&nbsp;             &quot;\n  [-orderedinsertion]&quot; +
<i class="no-highlight">872</i>&nbsp;             &quot;\n      # Assume ordered insertions and no deletions, so BINs&quot; +
<i class="no-highlight">873</i>&nbsp;             &quot;\n      # are 100% full; default: unordered insertions and/or&quot; +
<i class="no-highlight">874</i>&nbsp;             &quot;\n      # deletions, BINs are 70% full&quot; +
<i class="no-highlight">875</i>&nbsp;             &quot;\n  [-duplicates]&quot; +
<i class="no-highlight">876</i>&nbsp;             &quot;\n      # Indicates that sorted duplicates are used, including&quot; +
<i class="no-highlight">877</i>&nbsp;             &quot;\n      # MANY_TO_ONE and MANY_TO_MANY secondary indices;&quot; +
<i class="no-highlight">878</i>&nbsp;             &quot;\n      # default: false&quot; +
<i class="no-highlight">879</i>&nbsp;             &quot;\n  [-ttl]&quot; +
<i class="no-highlight">880</i>&nbsp;             &quot;\n      # Indicates that TTL is used; default: false&quot; +
<i class="no-highlight">881</i>&nbsp;             &quot;\n  [-replicated]&quot; +
<i class="no-highlight">882</i>&nbsp;             &quot;\n      # Use a ReplicatedEnvironment; default: false&quot; +
<i class="no-highlight">883</i>&nbsp;             &quot;\n  [-ENV_PARAM_NAME VALUE]...&quot; +
<i class="no-highlight">884</i>&nbsp;             &quot;\n      # Any number of EnvironmentConfig parameters and&quot; +
<i class="no-highlight">885</i>&nbsp;             &quot;\n      # ReplicationConfig parameters (if -replicated)&quot; +
<i class="no-highlight">886</i>&nbsp;             &quot;\n  [-btreeinfo]&quot; +
<i class="no-highlight">887</i>&nbsp;             &quot;\n      # Outputs additional Btree information&quot; +
<i class="no-highlight">888</i>&nbsp;             &quot;\n  [-outputproperties]&quot; +
<i class="no-highlight">889</i>&nbsp;             &quot;\n      # Writes Java properties to System.out&quot;);
<i class="no-highlight">890</i>&nbsp;
<b class="nc"><i class="no-highlight">891</i>&nbsp;        System.exit(2);</b>
<i class="no-highlight">892</i>&nbsp;    }
<i class="no-highlight">893</i>&nbsp;
<i class="no-highlight">894</i>&nbsp;    /**
<i class="no-highlight">895</i>&nbsp;     * Calculates estimated cache sizes.
<i class="no-highlight">896</i>&nbsp;     */
<i class="no-highlight">897</i>&nbsp;    void calculateCacheSizes() {
<i class="no-highlight">898</i>&nbsp;
<b class="nc"><i class="no-highlight">899</i>&nbsp;        if (binMaxEntries &lt;= 0) {</b>
<b class="nc"><i class="no-highlight">900</i>&nbsp;            binMaxEntries = nodeMaxEntries;</b>
<i class="no-highlight">901</i>&nbsp;        }
<i class="no-highlight">902</i>&nbsp;
<b class="nc"><i class="no-highlight">903</i>&nbsp;        final Environment env = openCalcEnvironment(true);</b>
<b class="nc"><i class="no-highlight">904</i>&nbsp;        boolean success = false;</b>
<i class="no-highlight">905</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">906</i>&nbsp;            IN.ACCUMULATED_LIMIT = 0;</b>
<i class="no-highlight">907</i>&nbsp;
<b class="nc"><i class="no-highlight">908</i>&nbsp;            envOverhead = env.getStats(null).getCacheTotalBytes();</b>
<i class="no-highlight">909</i>&nbsp;
<b class="nc"><i class="no-highlight">910</i>&nbsp;            if (offHeapCache) {</b>
<i class="no-highlight">911</i>&nbsp;
<b class="nc"><i class="no-highlight">912</i>&nbsp;                assumeEvictLN = (mainCacheSize == 0);</b>
<i class="no-highlight">913</i>&nbsp;
<b class="nc"><i class="no-highlight">914</i>&nbsp;                if (mainCacheSize &gt; 0 &amp;&amp;</b>
<i class="no-highlight">915</i>&nbsp;                    mainCacheSize - envOverhead &lt;= 1024 * 1024) {
<i class="no-highlight">916</i>&nbsp;
<b class="nc"><i class="no-highlight">917</i>&nbsp;                    throw new IllegalArgumentException(</b>
<i class="no-highlight">918</i>&nbsp;                        &quot;The -maincache value must be at least 1 MiB larger&quot; +
<i class="no-highlight">919</i>&nbsp;                        &quot; than the environment overhead (&quot; +
<b class="nc"><i class="no-highlight">920</i>&nbsp;                        INT_FORMAT.format(envOverhead) + &#39;)&#39;);</b>
<i class="no-highlight">921</i>&nbsp;                }
<i class="no-highlight">922</i>&nbsp;            }
<i class="no-highlight">923</i>&nbsp;
<b class="nc"><i class="no-highlight">924</i>&nbsp;            final int density =</b>
<i class="no-highlight">925</i>&nbsp;                orderedInsertion ? ORDERED_DENSITY : DEFAULT_DENSITY;
<i class="no-highlight">926</i>&nbsp;
<b class="nc"><i class="no-highlight">927</i>&nbsp;            nodeAvg = (nodeMaxEntries * density) / 100;</b>
<b class="nc"><i class="no-highlight">928</i>&nbsp;            binAvg = (binMaxEntries * density) / 100;</b>
<i class="no-highlight">929</i>&nbsp;
<b class="nc"><i class="no-highlight">930</i>&nbsp;            calcTreeSizes(env);</b>
<b class="nc"><i class="no-highlight">931</i>&nbsp;            calcNNodes();</b>
<b class="nc"><i class="no-highlight">932</i>&nbsp;            calcMainCacheSizes();</b>
<i class="no-highlight">933</i>&nbsp;
<i class="no-highlight">934</i>&nbsp;            /*
<i class="no-highlight">935</i>&nbsp;             * With an off-heap cache, if all UINs don&#39;t fit in main then we
<i class="no-highlight">936</i>&nbsp;             * can&#39;t fit all internal nodes, much less all nodes, in both
<i class="no-highlight">937</i>&nbsp;             * caches. We adjust the number of records downward so all UINs do
<i class="no-highlight">938</i>&nbsp;             * fit in main (there is no point in configuring a cache that can
<i class="no-highlight">939</i>&nbsp;             * never be filled) and then recalculate the number of nodes.
<i class="no-highlight">940</i>&nbsp;             */
<b class="nc"><i class="no-highlight">941</i>&nbsp;            if (offHeapCache) {</b>
<i class="no-highlight">942</i>&nbsp;
<b class="nc"><i class="no-highlight">943</i>&nbsp;                if (mainCacheSize == 0) {</b>
<b class="nc"><i class="no-highlight">944</i>&nbsp;                    mainCacheSize = mainNoLNsOrVLSNs + envOverhead;</b>
<i class="no-highlight">945</i>&nbsp;                }
<i class="no-highlight">946</i>&nbsp;
<b class="nc"><i class="no-highlight">947</i>&nbsp;                mainDataSize = mainCacheSize - envOverhead;</b>
<b class="nc"><i class="no-highlight">948</i>&nbsp;                mainMinDataSize = calcLevel2AndAboveSize();</b>
<i class="no-highlight">949</i>&nbsp;
<b class="nc"><i class="no-highlight">950</i>&nbsp;                if (mainMinDataSize &gt; mainDataSize) {</b>
<b class="nc"><i class="no-highlight">951</i>&nbsp;                    records *= ((double) mainDataSize) / mainMinDataSize;</b>
<b class="nc"><i class="no-highlight">952</i>&nbsp;                    calcNNodes();</b>
<b class="nc"><i class="no-highlight">953</i>&nbsp;                    calcMainCacheSizes();</b>
<i class="no-highlight">954</i>&nbsp;                }
<i class="no-highlight">955</i>&nbsp;
<b class="nc"><i class="no-highlight">956</i>&nbsp;                calcOffHeapNoLNsOrVLSNs();</b>
<b class="nc"><i class="no-highlight">957</i>&nbsp;                calcOffHeapWithLNsAndVLSNs();</b>
<i class="no-highlight">958</i>&nbsp;            }
<i class="no-highlight">959</i>&nbsp;
<b class="nc"><i class="no-highlight">960</i>&nbsp;            success = true;</b>
<i class="no-highlight">961</i>&nbsp;        } finally {
<i class="no-highlight">962</i>&nbsp;
<b class="nc"><i class="no-highlight">963</i>&nbsp;            IN.ACCUMULATED_LIMIT = IN.ACCUMULATED_LIMIT_DEFAULT;</b>
<i class="no-highlight">964</i>&nbsp;
<i class="no-highlight">965</i>&nbsp;            /*
<i class="no-highlight">966</i>&nbsp;             * Do not propagate exception thrown by Environment.close if
<i class="no-highlight">967</i>&nbsp;             * another exception is currently in flight.
<i class="no-highlight">968</i>&nbsp;             */
<i class="no-highlight">969</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">970</i>&nbsp;                env.close();</b>
<b class="nc"><i class="no-highlight">971</i>&nbsp;            } catch (RuntimeException e) {</b>
<b class="nc"><i class="no-highlight">972</i>&nbsp;                if (success) {</b>
<b class="nc"><i class="no-highlight">973</i>&nbsp;                    throw e;</b>
<i class="no-highlight">974</i>&nbsp;                }
<b class="nc"><i class="no-highlight">975</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">976</i>&nbsp;        }</b>
<i class="no-highlight">977</i>&nbsp;    }
<i class="no-highlight">978</i>&nbsp;
<i class="no-highlight">979</i>&nbsp;    private long calcLevel2AndAboveSize() {
<b class="nc"><i class="no-highlight">980</i>&nbsp;        assert offHeapCache;</b>
<i class="no-highlight">981</i>&nbsp;
<b class="nc"><i class="no-highlight">982</i>&nbsp;        return ((nUinNodes - nLevel2Nodes) * uinWithTargets) +</b>
<i class="no-highlight">983</i>&nbsp;               (nLevel2Nodes * (uinNoTargets + uinOffHeapBINIds));
<i class="no-highlight">984</i>&nbsp;    }
<i class="no-highlight">985</i>&nbsp;
<i class="no-highlight">986</i>&nbsp;    private void calcNNodes() {
<i class="no-highlight">987</i>&nbsp;
<b class="nc"><i class="no-highlight">988</i>&nbsp;        nBinNodes = (records + binAvg - 1) / binAvg;</b>
<b class="nc"><i class="no-highlight">989</i>&nbsp;        btreeLevels = 1;</b>
<b class="nc"><i class="no-highlight">990</i>&nbsp;        nUinNodes = 0;</b>
<b class="nc"><i class="no-highlight">991</i>&nbsp;        nLevel2Nodes = 0;</b>
<i class="no-highlight">992</i>&nbsp;
<b class="nc"><i class="no-highlight">993</i>&nbsp;        for (long nodes = nBinNodes / nodeAvg;; nodes /= nodeAvg) {</b>
<i class="no-highlight">994</i>&nbsp;
<b class="nc"><i class="no-highlight">995</i>&nbsp;            if (nodes == 0) {</b>
<b class="nc"><i class="no-highlight">996</i>&nbsp;                nodes = 1; // root</b>
<i class="no-highlight">997</i>&nbsp;            }
<i class="no-highlight">998</i>&nbsp;
<b class="nc"><i class="no-highlight">999</i>&nbsp;            if (btreeLevels == 2) {</b>
<b class="nc"><i class="no-highlight">1000</i>&nbsp;                assert nLevel2Nodes == 0;</b>
<b class="nc"><i class="no-highlight">1001</i>&nbsp;                nLevel2Nodes = nodes;</b>
<i class="no-highlight">1002</i>&nbsp;            }
<i class="no-highlight">1003</i>&nbsp;
<b class="nc"><i class="no-highlight">1004</i>&nbsp;            nUinNodes += nodes;</b>
<b class="nc"><i class="no-highlight">1005</i>&nbsp;            btreeLevels += 1;</b>
<i class="no-highlight">1006</i>&nbsp;
<b class="nc"><i class="no-highlight">1007</i>&nbsp;            if (nodes == 1) {</b>
<b class="nc"><i class="no-highlight">1008</i>&nbsp;                break;</b>
<i class="no-highlight">1009</i>&nbsp;            }
<i class="no-highlight">1010</i>&nbsp;        }
<i class="no-highlight">1011</i>&nbsp;    }
<i class="no-highlight">1012</i>&nbsp;
<i class="no-highlight">1013</i>&nbsp;    /**
<i class="no-highlight">1014</i>&nbsp;     * Calculates main cache sizes as if there were no off-heap cache. During
<i class="no-highlight">1015</i>&nbsp;     * off-heap cache size calculations, these numbers may be revised.
<i class="no-highlight">1016</i>&nbsp;     */
<i class="no-highlight">1017</i>&nbsp;    private void calcMainCacheSizes() {
<i class="no-highlight">1018</i>&nbsp;
<b class="nc"><i class="no-highlight">1019</i>&nbsp;        final long mainUINs = nUinNodes * uinWithTargets;</b>
<i class="no-highlight">1020</i>&nbsp;
<b class="nc"><i class="no-highlight">1021</i>&nbsp;        mainNoLNsOrVLSNs =</b>
<i class="no-highlight">1022</i>&nbsp;            (nBinNodes * binNoLNsOrVLSNs) + mainUINs;
<i class="no-highlight">1023</i>&nbsp;
<b class="nc"><i class="no-highlight">1024</i>&nbsp;        mainNoLNsWithVLSNs =</b>
<i class="no-highlight">1025</i>&nbsp;            (nBinNodes * binNoLNsWithVLSNs) + mainUINs;
<i class="no-highlight">1026</i>&nbsp;
<b class="nc"><i class="no-highlight">1027</i>&nbsp;        mainWithLNsAndVLSNs =</b>
<i class="no-highlight">1028</i>&nbsp;            (nBinNodes * binWithLNsAndVLSNs) + mainUINs;
<i class="no-highlight">1029</i>&nbsp;    }
<i class="no-highlight">1030</i>&nbsp;
<i class="no-highlight">1031</i>&nbsp;    private void calcOffHeapNoLNsOrVLSNs() {
<b class="nc"><i class="no-highlight">1032</i>&nbsp;        assert offHeapCache;</b>
<i class="no-highlight">1033</i>&nbsp;
<b class="nc"><i class="no-highlight">1034</i>&nbsp;        mainNoLNsWithVLSNs = 0;</b>
<i class="no-highlight">1035</i>&nbsp;
<i class="no-highlight">1036</i>&nbsp;        /*
<i class="no-highlight">1037</i>&nbsp;         * If all INs fit in main, then no off-heap cache is needed.
<i class="no-highlight">1038</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1039</i>&nbsp;        if (mainNoLNsOrVLSNs &lt;= mainDataSize) {</b>
<b class="nc"><i class="no-highlight">1040</i>&nbsp;            offHeapNoLNsOrVLSNs = 0;</b>
<b class="nc"><i class="no-highlight">1041</i>&nbsp;            nMainBINsNoLNsOrVLSNs = nBinNodes;</b>
<i class="no-highlight">1042</i>&nbsp;            return;
<i class="no-highlight">1043</i>&nbsp;        }
<i class="no-highlight">1044</i>&nbsp;
<b class="nc"><i class="no-highlight">1045</i>&nbsp;        mainNoLNsOrVLSNs = mainDataSize;</b>
<i class="no-highlight">1046</i>&nbsp;
<i class="no-highlight">1047</i>&nbsp;        /*
<i class="no-highlight">1048</i>&nbsp;         * If not all BINs fit in main, then put as many BINs in main as
<i class="no-highlight">1049</i>&nbsp;         * possible, and the rest off-heap.
<i class="no-highlight">1050</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1051</i>&nbsp;        final long mainSpare = (mainDataSize &gt; calcLevel2AndAboveSize()) ?</b>
<b class="nc"><i class="no-highlight">1052</i>&nbsp;            (mainDataSize - calcLevel2AndAboveSize()) : 0;</b>
<i class="no-highlight">1053</i>&nbsp;
<b class="nc"><i class="no-highlight">1054</i>&nbsp;        final long nMainBINs = mainSpare / binNoLNsOrVLSNs;</b>
<b class="nc"><i class="no-highlight">1055</i>&nbsp;        final long nOffHeapBins = nBinNodes - nMainBINs;</b>
<i class="no-highlight">1056</i>&nbsp;
<b class="nc"><i class="no-highlight">1057</i>&nbsp;        offHeapNoLNsOrVLSNs = nOffHeapBins * binOffHeapNoLNIds;</b>
<b class="nc"><i class="no-highlight">1058</i>&nbsp;        nMainBINsNoLNsOrVLSNs = nMainBINs;</b>
<i class="no-highlight">1059</i>&nbsp;    }
<i class="no-highlight">1060</i>&nbsp;
<i class="no-highlight">1061</i>&nbsp;    private void calcOffHeapWithLNsAndVLSNs() {
<b class="nc"><i class="no-highlight">1062</i>&nbsp;        assert offHeapCache;</b>
<i class="no-highlight">1063</i>&nbsp;
<i class="no-highlight">1064</i>&nbsp;        /*
<i class="no-highlight">1065</i>&nbsp;         * If everything fits in main, then no off-heap cache is needed.
<i class="no-highlight">1066</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1067</i>&nbsp;        if (mainWithLNsAndVLSNs &lt;= mainDataSize) {</b>
<b class="nc"><i class="no-highlight">1068</i>&nbsp;            offHeapWithLNsAndVLSNs = 0;</b>
<b class="nc"><i class="no-highlight">1069</i>&nbsp;            nMainBINsWithLNsAndVLSNs = nBinNodes;</b>
<b class="nc"><i class="no-highlight">1070</i>&nbsp;            nMainLNsWithLNsAndVLSNs = (binOffHeapLNs == 0) ? 0 : records;</b>
<i class="no-highlight">1071</i>&nbsp;            return;
<i class="no-highlight">1072</i>&nbsp;        }
<i class="no-highlight">1073</i>&nbsp;
<b class="nc"><i class="no-highlight">1074</i>&nbsp;        mainWithLNsAndVLSNs = mainDataSize;</b>
<i class="no-highlight">1075</i>&nbsp;
<i class="no-highlight">1076</i>&nbsp;        /*
<i class="no-highlight">1077</i>&nbsp;         * If LNs are not stored separately (they are embedded or duplicates
<i class="no-highlight">1078</i>&nbsp;         * are configured), then only internal nodes are relevant.
<i class="no-highlight">1079</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1080</i>&nbsp;        if (binOffHeapLNs == 0) {</b>
<b class="nc"><i class="no-highlight">1081</i>&nbsp;            offHeapWithLNsAndVLSNs = offHeapNoLNsOrVLSNs;</b>
<b class="nc"><i class="no-highlight">1082</i>&nbsp;            nMainBINsWithLNsAndVLSNs = nMainBINsNoLNsOrVLSNs;</b>
<b class="nc"><i class="no-highlight">1083</i>&nbsp;            nMainLNsWithLNsAndVLSNs = 0;</b>
<i class="no-highlight">1084</i>&nbsp;            return;
<i class="no-highlight">1085</i>&nbsp;        }
<i class="no-highlight">1086</i>&nbsp;
<i class="no-highlight">1087</i>&nbsp;        /*
<i class="no-highlight">1088</i>&nbsp;         * If all BINs fit in main, then compute how many BINs will have main
<i class="no-highlight">1089</i>&nbsp;         * LNs and how many off-heap LNs. The number that have main LNs is
<i class="no-highlight">1090</i>&nbsp;         * the amount of main cache to spare (if all BINs had off-heap LNs)
<i class="no-highlight">1091</i>&nbsp;         * divided by the added size required to hold the LNs in one BIN.
<i class="no-highlight">1092</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1093</i>&nbsp;        final long mainWithOffHeapLNIds =</b>
<i class="no-highlight">1094</i>&nbsp;            mainNoLNsOrVLSNs + (nBinNodes * binOffHeapLNIds);
<i class="no-highlight">1095</i>&nbsp;
<b class="nc"><i class="no-highlight">1096</i>&nbsp;        if (mainWithOffHeapLNIds &lt;= mainDataSize) {</b>
<i class="no-highlight">1097</i>&nbsp;
<b class="nc"><i class="no-highlight">1098</i>&nbsp;            final long mainSpare = (mainDataSize &gt; mainNoLNsOrVLSNs) ?</b>
<i class="no-highlight">1099</i>&nbsp;                (mainDataSize - mainNoLNsOrVLSNs) : 0;
<i class="no-highlight">1100</i>&nbsp;
<b class="nc"><i class="no-highlight">1101</i>&nbsp;            final long nBINsWithMainLNs = mainSpare /</b>
<i class="no-highlight">1102</i>&nbsp;                (binWithLNsAndVLSNs - binNoLNsOrVLSNs);
<i class="no-highlight">1103</i>&nbsp;
<b class="nc"><i class="no-highlight">1104</i>&nbsp;            final long nBINsWithOffHeapLNs = nBinNodes - nBINsWithMainLNs;</b>
<i class="no-highlight">1105</i>&nbsp;
<b class="nc"><i class="no-highlight">1106</i>&nbsp;            offHeapWithLNsAndVLSNs = nBINsWithOffHeapLNs * binOffHeapLNs;</b>
<b class="nc"><i class="no-highlight">1107</i>&nbsp;            nMainBINsWithLNsAndVLSNs = nMainBINsNoLNsOrVLSNs;</b>
<b class="nc"><i class="no-highlight">1108</i>&nbsp;            nMainLNsWithLNsAndVLSNs = nBINsWithMainLNs * nodeAvg;</b>
<i class="no-highlight">1109</i>&nbsp;            return;
<i class="no-highlight">1110</i>&nbsp;        }
<i class="no-highlight">1111</i>&nbsp;
<i class="no-highlight">1112</i>&nbsp;        /*
<i class="no-highlight">1113</i>&nbsp;         * If not all BINs fit in main, then put as many BINs in main as
<i class="no-highlight">1114</i>&nbsp;         * possible, and the rest off-heap. Put all LNs off-heap.
<i class="no-highlight">1115</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1116</i>&nbsp;        final long mainSpare = (mainDataSize &gt; calcLevel2AndAboveSize()) ?</b>
<b class="nc"><i class="no-highlight">1117</i>&nbsp;            (mainDataSize - calcLevel2AndAboveSize()) : 0;</b>
<i class="no-highlight">1118</i>&nbsp;
<b class="nc"><i class="no-highlight">1119</i>&nbsp;        final long nMainBINs = mainSpare / (binNoLNsOrVLSNs + binOffHeapLNIds);</b>
<b class="nc"><i class="no-highlight">1120</i>&nbsp;        final long nOffHeapBins = nBinNodes - nMainBINs;</b>
<i class="no-highlight">1121</i>&nbsp;
<b class="nc"><i class="no-highlight">1122</i>&nbsp;        offHeapWithLNsAndVLSNs =</b>
<i class="no-highlight">1123</i>&nbsp;            (nOffHeapBins * binOffHeapWithLNIds) +
<i class="no-highlight">1124</i>&nbsp;            (nBinNodes * binOffHeapLNs);
<i class="no-highlight">1125</i>&nbsp;
<b class="nc"><i class="no-highlight">1126</i>&nbsp;        nMainBINsWithLNsAndVLSNs = nMainBINs;</b>
<b class="nc"><i class="no-highlight">1127</i>&nbsp;        nMainLNsWithLNsAndVLSNs = 0;</b>
<i class="no-highlight">1128</i>&nbsp;    }
<i class="no-highlight">1129</i>&nbsp;
<i class="no-highlight">1130</i>&nbsp;    private void calcTreeSizes(final Environment env) {
<i class="no-highlight">1131</i>&nbsp;
<b class="nc"><i class="no-highlight">1132</i>&nbsp;        if (nodeMaxEntries != binMaxEntries) {</b>
<b class="nc"><i class="no-highlight">1133</i>&nbsp;            throw new IllegalArgumentException(</b>
<i class="no-highlight">1134</i>&nbsp;                &quot;-binmax not currently supported because a per-BIN max is&quot; +
<i class="no-highlight">1135</i>&nbsp;                &quot; not implemented in the Btree, so we can&#39;t measure&quot; +
<i class="no-highlight">1136</i>&nbsp;                &quot; an actual BIN node with the given -binmax value&quot;);
<i class="no-highlight">1137</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1138</i>&nbsp;        assert nodeAvg == binAvg;</b>
<i class="no-highlight">1139</i>&nbsp;
<b class="nc"><i class="no-highlight">1140</i>&nbsp;        if (nodeAvg &gt; 0xFFFF) {</b>
<b class="nc"><i class="no-highlight">1141</i>&nbsp;            throw new IllegalArgumentException(</b>
<i class="no-highlight">1142</i>&nbsp;                &quot;Entries per node (&quot; + nodeAvg + &quot;) is greater than 0xFFFF&quot;);
<i class="no-highlight">1143</i>&nbsp;        }
<i class="no-highlight">1144</i>&nbsp;
<b class="nc"><i class="no-highlight">1145</i>&nbsp;        final EnvironmentImpl envImpl = DbInternal.getNonNullEnvImpl(env);</b>
<i class="no-highlight">1146</i>&nbsp;
<i class="no-highlight">1147</i>&nbsp;        /*
<i class="no-highlight">1148</i>&nbsp;         * Either a one or two byte key is used, depending on whether a single
<i class="no-highlight">1149</i>&nbsp;         * byte can hold the key for nodeAvg entries.
<i class="no-highlight">1150</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1151</i>&nbsp;        final byte[] keyBytes = new byte[(nodeAvg &lt;= 0xFF) ? 1 : 2];</b>
<b class="nc"><i class="no-highlight">1152</i>&nbsp;        final DatabaseEntry keyEntry = new DatabaseEntry();</b>
<b class="nc"><i class="no-highlight">1153</i>&nbsp;        final DatabaseEntry dataEntry = new DatabaseEntry();</b>
<i class="no-highlight">1154</i>&nbsp;
<b class="nc"><i class="no-highlight">1155</i>&nbsp;        final WriteOptions options = new WriteOptions();</b>
<b class="nc"><i class="no-highlight">1156</i>&nbsp;        if (useTTL) {</b>
<b class="nc"><i class="no-highlight">1157</i>&nbsp;            options.setTTL(30, TimeUnit.DAYS);</b>
<i class="no-highlight">1158</i>&nbsp;        }
<i class="no-highlight">1159</i>&nbsp;
<i class="no-highlight">1160</i>&nbsp;        /* Insert nodeAvg records into a single BIN. */
<b class="nc"><i class="no-highlight">1161</i>&nbsp;        final Database db = openDatabase(env, true);</b>
<b class="nc"><i class="no-highlight">1162</i>&nbsp;        for (int i = 0; i &lt; nodeAvg; i += 1) {</b>
<i class="no-highlight">1163</i>&nbsp;
<b class="nc"><i class="no-highlight">1164</i>&nbsp;            if (keyBytes.length == 1) {</b>
<b class="nc"><i class="no-highlight">1165</i>&nbsp;                keyBytes[0] = (byte) i;</b>
<i class="no-highlight">1166</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">1167</i>&nbsp;                assert keyBytes.length == 2;</b>
<b class="nc"><i class="no-highlight">1168</i>&nbsp;                keyBytes[0] = (byte) (i &gt;&gt; 8);</b>
<b class="nc"><i class="no-highlight">1169</i>&nbsp;                keyBytes[1] = (byte) i;</b>
<i class="no-highlight">1170</i>&nbsp;            }
<i class="no-highlight">1171</i>&nbsp;
<b class="nc"><i class="no-highlight">1172</i>&nbsp;            setKeyData(keyBytes, keyPrefix, keyEntry, dataEntry);</b>
<i class="no-highlight">1173</i>&nbsp;
<b class="nc"><i class="no-highlight">1174</i>&nbsp;            final OperationResult result = db.put(</b>
<i class="no-highlight">1175</i>&nbsp;                null, keyEntry, dataEntry,
<i class="no-highlight">1176</i>&nbsp;                duplicates ? Put.NO_DUP_DATA : Put.NO_OVERWRITE,
<i class="no-highlight">1177</i>&nbsp;                options);
<i class="no-highlight">1178</i>&nbsp;
<b class="nc"><i class="no-highlight">1179</i>&nbsp;            if (result == null) {</b>
<b class="nc"><i class="no-highlight">1180</i>&nbsp;                throw new IllegalStateException();</b>
<i class="no-highlight">1181</i>&nbsp;            }
<i class="no-highlight">1182</i>&nbsp;        }
<i class="no-highlight">1183</i>&nbsp;
<i class="no-highlight">1184</i>&nbsp;        /* Position a cursor at the first record to get the BIN. */
<b class="nc"><i class="no-highlight">1185</i>&nbsp;        final Cursor cursor = db.openCursor(null, null);</b>
<b class="nc"><i class="no-highlight">1186</i>&nbsp;        OperationStatus status = cursor.getFirst(keyEntry, dataEntry, null);</b>
<b class="nc"><i class="no-highlight">1187</i>&nbsp;        assert status == OperationStatus.SUCCESS;</b>
<b class="nc"><i class="no-highlight">1188</i>&nbsp;        final BIN bin = DbInternal.getCursorImpl(cursor).getBIN();</b>
<b class="nc"><i class="no-highlight">1189</i>&nbsp;        cursor.close();</b>
<b class="nc"><i class="no-highlight">1190</i>&nbsp;        bin.latchNoUpdateLRU();</b>
<i class="no-highlight">1191</i>&nbsp;
<i class="no-highlight">1192</i>&nbsp;        /*
<i class="no-highlight">1193</i>&nbsp;         * Calculate BIN size including LNs. The recalcKeyPrefix and
<i class="no-highlight">1194</i>&nbsp;         * compactMemory methods are called to simulate normal operation.
<i class="no-highlight">1195</i>&nbsp;         * Normally prefixes are recalculated when a IN is split, and
<i class="no-highlight">1196</i>&nbsp;         * compactMemory is called after fetching a IN or evicting an LN.
<i class="no-highlight">1197</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1198</i>&nbsp;        bin.recalcKeyPrefix();</b>
<b class="nc"><i class="no-highlight">1199</i>&nbsp;        bin.compactMemory();</b>
<b class="nc"><i class="no-highlight">1200</i>&nbsp;        binWithLNsAndVLSNs = bin.getInMemorySize();</b>
<i class="no-highlight">1201</i>&nbsp;
<i class="no-highlight">1202</i>&nbsp;        /*
<i class="no-highlight">1203</i>&nbsp;         * Evict all LNs so we can calculate BIN size without LNs.  This is
<i class="no-highlight">1204</i>&nbsp;         * simulated by calling partialEviction directly.
<i class="no-highlight">1205</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1206</i>&nbsp;        if (offHeapCache) {</b>
<b class="nc"><i class="no-highlight">1207</i>&nbsp;            final long prevSize = getOffHeapCacheSize(envImpl);</b>
<i class="no-highlight">1208</i>&nbsp;
<b class="nc"><i class="no-highlight">1209</i>&nbsp;            bin.partialEviction();</b>
<i class="no-highlight">1210</i>&nbsp;
<b class="nc"><i class="no-highlight">1211</i>&nbsp;            binOffHeapLNs = 0;</b>
<b class="nc"><i class="no-highlight">1212</i>&nbsp;            for (int i = 0; i &lt; nodeAvg; i += 1) {</b>
<b class="nc"><i class="no-highlight">1213</i>&nbsp;                binOffHeapLNs += getOffHeapLNSize(bin, 0);</b>
<i class="no-highlight">1214</i>&nbsp;            }
<i class="no-highlight">1215</i>&nbsp;
<b class="nc"><i class="no-highlight">1216</i>&nbsp;            assert getOffHeapCacheSize(envImpl) - prevSize == binOffHeapLNs;</b>
<i class="no-highlight">1217</i>&nbsp;
<b class="nc"><i class="no-highlight">1218</i>&nbsp;            binOffHeapLNIds = bin.getOffHeapLNIdsMemorySize();</b>
<i class="no-highlight">1219</i>&nbsp;
<b class="nc"><i class="no-highlight">1220</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">1221</i>&nbsp;            bin.partialEviction();</b>
<i class="no-highlight">1222</i>&nbsp;
<b class="nc"><i class="no-highlight">1223</i>&nbsp;            binOffHeapLNs = 0;</b>
<b class="nc"><i class="no-highlight">1224</i>&nbsp;            binOffHeapLNIds = 0;</b>
<i class="no-highlight">1225</i>&nbsp;        }
<i class="no-highlight">1226</i>&nbsp;
<b class="nc"><i class="no-highlight">1227</i>&nbsp;        assert !bin.hasCachedChildren();</b>
<i class="no-highlight">1228</i>&nbsp;
<b class="nc"><i class="no-highlight">1229</i>&nbsp;        binNoLNsWithVLSNs = bin.getInMemorySize() - binOffHeapLNIds;</b>
<i class="no-highlight">1230</i>&nbsp;
<i class="no-highlight">1231</i>&nbsp;        /*
<i class="no-highlight">1232</i>&nbsp;         * Another variant is when VLSNs are cached, since they are evicted
<i class="no-highlight">1233</i>&nbsp;         * after the LNs in a separate step.  This is simulated by calling
<i class="no-highlight">1234</i>&nbsp;         * partialEviction a second time.
<i class="no-highlight">1235</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1236</i>&nbsp;        if (duplicates || !envImpl.getCacheVLSN()) {</b>
<b class="nc"><i class="no-highlight">1237</i>&nbsp;            assert bin.getVLSNCache().getMemorySize() == 0;</b>
<i class="no-highlight">1238</i>&nbsp;
<i class="no-highlight">1239</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">1240</i>&nbsp;            assert bin.getVLSNCache().getMemorySize() &gt; 0;</b>
<i class="no-highlight">1241</i>&nbsp;
<b class="nc"><i class="no-highlight">1242</i>&nbsp;            bin.partialEviction();</b>
<i class="no-highlight">1243</i>&nbsp;
<b class="nc"><i class="no-highlight">1244</i>&nbsp;            if (dataSize &lt;= bin.getEnv().getMaxEmbeddedLN()) {</b>
<b class="nc"><i class="no-highlight">1245</i>&nbsp;                assert bin.getVLSNCache().getMemorySize() &gt; 0;</b>
<i class="no-highlight">1246</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">1247</i>&nbsp;                assert bin.getVLSNCache().getMemorySize() == 0;</b>
<i class="no-highlight">1248</i>&nbsp;            }
<i class="no-highlight">1249</i>&nbsp;        }
<i class="no-highlight">1250</i>&nbsp;
<i class="no-highlight">1251</i>&nbsp;        /* There are no LNs or VLSNs remaining. */
<b class="nc"><i class="no-highlight">1252</i>&nbsp;        binNoLNsOrVLSNs = bin.getInMemorySize() - binOffHeapLNIds;</b>
<i class="no-highlight">1253</i>&nbsp;
<i class="no-highlight">1254</i>&nbsp;        /*
<i class="no-highlight">1255</i>&nbsp;         * To calculate IN size, get parent/root IN and artificially fill the
<i class="no-highlight">1256</i>&nbsp;         * slots with nodeAvg entries.
<i class="no-highlight">1257</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1258</i>&nbsp;        final IN in = DbInternal.getDbImpl(db).</b>
<b class="nc"><i class="no-highlight">1259</i>&nbsp;                                 getTree().</b>
<b class="nc"><i class="no-highlight">1260</i>&nbsp;                                 getRootINLatchedExclusive(CacheMode.DEFAULT);</b>
<b class="nc"><i class="no-highlight">1261</i>&nbsp;        assert bin == in.getTarget(0);</b>
<i class="no-highlight">1262</i>&nbsp;
<b class="nc"><i class="no-highlight">1263</i>&nbsp;        for (int i = 1; i &lt; nodeAvg; i += 1) {</b>
<i class="no-highlight">1264</i>&nbsp;
<b class="nc"><i class="no-highlight">1265</i>&nbsp;            final int result = in.insertEntry1(</b>
<b class="nc"><i class="no-highlight">1266</i>&nbsp;                bin, bin.getKey(i), null, bin.getLsn(i),</b>
<i class="no-highlight">1267</i>&nbsp;                false/*blindInsertion*/);
<i class="no-highlight">1268</i>&nbsp;
<b class="nc"><i class="no-highlight">1269</i>&nbsp;            assert (result &amp; IN.INSERT_SUCCESS) != 0;</b>
<b class="nc"><i class="no-highlight">1270</i>&nbsp;            assert i == (result &amp; ~IN.INSERT_SUCCESS);</b>
<i class="no-highlight">1271</i>&nbsp;        }
<i class="no-highlight">1272</i>&nbsp;
<b class="nc"><i class="no-highlight">1273</i>&nbsp;        in.recalcKeyPrefix();</b>
<b class="nc"><i class="no-highlight">1274</i>&nbsp;        in.compactMemory();</b>
<b class="nc"><i class="no-highlight">1275</i>&nbsp;        uinWithTargets = in.getInMemorySize();</b>
<b class="nc"><i class="no-highlight">1276</i>&nbsp;        uinNoTargets = uinWithTargets - in.getTargets().calculateMemorySize();</b>
<i class="no-highlight">1277</i>&nbsp;
<b class="nc"><i class="no-highlight">1278</i>&nbsp;        if (offHeapCache) {</b>
<i class="no-highlight">1279</i>&nbsp;
<b class="nc"><i class="no-highlight">1280</i>&nbsp;            in.releaseLatch();</b>
<i class="no-highlight">1281</i>&nbsp;
<b class="nc"><i class="no-highlight">1282</i>&nbsp;            long bytesFreed = envImpl.getEvictor().doTestEvict(</b>
<i class="no-highlight">1283</i>&nbsp;                bin, Evictor.EvictionSource.CACHEMODE);
<i class="no-highlight">1284</i>&nbsp;
<b class="nc"><i class="no-highlight">1285</i>&nbsp;            assert bytesFreed &gt; 0;</b>
<i class="no-highlight">1286</i>&nbsp;
<b class="nc"><i class="no-highlight">1287</i>&nbsp;            in.latchNoUpdateLRU();</b>
<i class="no-highlight">1288</i>&nbsp;
<b class="nc"><i class="no-highlight">1289</i>&nbsp;            final int binId = in.getOffHeapBINId(0);</b>
<b class="nc"><i class="no-highlight">1290</i>&nbsp;            assert binId &gt;= 0;</b>
<i class="no-highlight">1291</i>&nbsp;
<b class="nc"><i class="no-highlight">1292</i>&nbsp;            binOffHeapWithLNIds = getOffHeapBINSize(in, 0);</b>
<i class="no-highlight">1293</i>&nbsp;
<b class="nc"><i class="no-highlight">1294</i>&nbsp;            bytesFreed = envImpl.getOffHeapCache().stripLNs(in, 0);</b>
<i class="no-highlight">1295</i>&nbsp;
<b class="nc"><i class="no-highlight">1296</i>&nbsp;            binOffHeapNoLNIds = getOffHeapBINSize(in, 0);</b>
<i class="no-highlight">1297</i>&nbsp;
<b class="nc"><i class="no-highlight">1298</i>&nbsp;            assert bytesFreed ==</b>
<i class="no-highlight">1299</i>&nbsp;                binOffHeapLNs + (binOffHeapWithLNIds - binOffHeapNoLNIds);
<i class="no-highlight">1300</i>&nbsp;
<b class="nc"><i class="no-highlight">1301</i>&nbsp;            for (int i = 1; i &lt; nodeAvg; i += 1) {</b>
<b class="nc"><i class="no-highlight">1302</i>&nbsp;                in.setOffHeapBINId(i, binId, false, false);</b>
<i class="no-highlight">1303</i>&nbsp;            }
<i class="no-highlight">1304</i>&nbsp;
<b class="nc"><i class="no-highlight">1305</i>&nbsp;            uinOffHeapBINIds = in.getOffHeapBINIdsMemorySize();</b>
<i class="no-highlight">1306</i>&nbsp;
<i class="no-highlight">1307</i>&nbsp;            /* Cleanup to avoid assertions during env close. */
<b class="nc"><i class="no-highlight">1308</i>&nbsp;            for (int i = 1; i &lt; nodeAvg; i += 1) {</b>
<b class="nc"><i class="no-highlight">1309</i>&nbsp;                in.clearOffHeapBINId(i);</b>
<i class="no-highlight">1310</i>&nbsp;            }
<i class="no-highlight">1311</i>&nbsp;
<b class="nc"><i class="no-highlight">1312</i>&nbsp;            in.releaseLatch();</b>
<i class="no-highlight">1313</i>&nbsp;
<b class="nc"><i class="no-highlight">1314</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">1315</i>&nbsp;            binOffHeapWithLNIds = 0;</b>
<b class="nc"><i class="no-highlight">1316</i>&nbsp;            uinOffHeapBINIds = 0;</b>
<i class="no-highlight">1317</i>&nbsp;
<b class="nc"><i class="no-highlight">1318</i>&nbsp;            bin.releaseLatch();</b>
<b class="nc"><i class="no-highlight">1319</i>&nbsp;            in.releaseLatch();</b>
<i class="no-highlight">1320</i>&nbsp;        }
<i class="no-highlight">1321</i>&nbsp;
<b class="nc"><i class="no-highlight">1322</i>&nbsp;        db.close();</b>
<i class="no-highlight">1323</i>&nbsp;    }
<i class="no-highlight">1324</i>&nbsp;
<i class="no-highlight">1325</i>&nbsp;    private long getMainDataSize(final Environment env) {
<b class="nc"><i class="no-highlight">1326</i>&nbsp;        return DbInternal.getNonNullEnvImpl(env).</b>
<b class="nc"><i class="no-highlight">1327</i>&nbsp;            getMemoryBudget().getTreeMemoryUsage();</b>
<i class="no-highlight">1328</i>&nbsp;    }
<i class="no-highlight">1329</i>&nbsp;
<i class="no-highlight">1330</i>&nbsp;    private long getOffHeapCacheSize(final EnvironmentImpl envImpl) {
<b class="nc"><i class="no-highlight">1331</i>&nbsp;        assert offHeapCache;</b>
<b class="nc"><i class="no-highlight">1332</i>&nbsp;        return envImpl.getOffHeapCache().getAllocator().getUsedBytes();</b>
<i class="no-highlight">1333</i>&nbsp;    }
<i class="no-highlight">1334</i>&nbsp;
<i class="no-highlight">1335</i>&nbsp;    private long getOffHeapLNSize(final BIN bin, final int i) {
<b class="nc"><i class="no-highlight">1336</i>&nbsp;        assert offHeapCache;</b>
<i class="no-highlight">1337</i>&nbsp;
<b class="nc"><i class="no-highlight">1338</i>&nbsp;        final OffHeapCache ohCache = bin.getEnv().getOffHeapCache();</b>
<i class="no-highlight">1339</i>&nbsp;
<b class="nc"><i class="no-highlight">1340</i>&nbsp;        final long memId = bin.getOffHeapLNId(i);</b>
<b class="nc"><i class="no-highlight">1341</i>&nbsp;        if (memId == 0) {</b>
<b class="nc"><i class="no-highlight">1342</i>&nbsp;            return 0;</b>
<i class="no-highlight">1343</i>&nbsp;        }
<i class="no-highlight">1344</i>&nbsp;
<b class="nc"><i class="no-highlight">1345</i>&nbsp;        return ohCache.getAllocator().totalSize(memId);</b>
<i class="no-highlight">1346</i>&nbsp;    }
<i class="no-highlight">1347</i>&nbsp;
<i class="no-highlight">1348</i>&nbsp;    private long getOffHeapBINSize(final IN parent, final int i) {
<b class="nc"><i class="no-highlight">1349</i>&nbsp;        assert offHeapCache;</b>
<i class="no-highlight">1350</i>&nbsp;
<b class="nc"><i class="no-highlight">1351</i>&nbsp;        final OffHeapCache ohCache = parent.getEnv().getOffHeapCache();</b>
<i class="no-highlight">1352</i>&nbsp;
<b class="nc"><i class="no-highlight">1353</i>&nbsp;        final int lruId = parent.getOffHeapBINId(0);</b>
<b class="nc"><i class="no-highlight">1354</i>&nbsp;        assert lruId &gt;= 0;</b>
<i class="no-highlight">1355</i>&nbsp;
<b class="nc"><i class="no-highlight">1356</i>&nbsp;        final long memId = ohCache.getMemId(lruId);</b>
<b class="nc"><i class="no-highlight">1357</i>&nbsp;        assert memId != 0;</b>
<i class="no-highlight">1358</i>&nbsp;
<b class="nc"><i class="no-highlight">1359</i>&nbsp;        return ohCache.getAllocator().totalSize(memId);</b>
<i class="no-highlight">1360</i>&nbsp;    }
<i class="no-highlight">1361</i>&nbsp;
<i class="no-highlight">1362</i>&nbsp;    private void setKeyData(final byte[] keyBytes,
<i class="no-highlight">1363</i>&nbsp;                            final int keyOffset,
<i class="no-highlight">1364</i>&nbsp;                            final DatabaseEntry keyEntry,
<i class="no-highlight">1365</i>&nbsp;                            final DatabaseEntry dataEntry) {
<i class="no-highlight">1366</i>&nbsp;        final byte[] fullKey;
<b class="nc"><i class="no-highlight">1367</i>&nbsp;        if (duplicates) {</b>
<b class="nc"><i class="no-highlight">1368</i>&nbsp;            fullKey = new byte[keySize + dataSize];</b>
<i class="no-highlight">1369</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">1370</i>&nbsp;            fullKey = new byte[keySize];</b>
<i class="no-highlight">1371</i>&nbsp;        }
<i class="no-highlight">1372</i>&nbsp;
<b class="nc"><i class="no-highlight">1373</i>&nbsp;        if (keyPrefix + keyBytes.length &gt; fullKey.length) {</b>
<b class="nc"><i class="no-highlight">1374</i>&nbsp;            throw new IllegalArgumentException(</b>
<i class="no-highlight">1375</i>&nbsp;                &quot;Key doesn&#39;t fit, allowedLen=&quot; + fullKey.length +
<i class="no-highlight">1376</i>&nbsp;                &quot; keyLen=&quot; + keyBytes.length + &quot; prefixLen=&quot; + keyPrefix);
<i class="no-highlight">1377</i>&nbsp;        }
<i class="no-highlight">1378</i>&nbsp;
<b class="nc"><i class="no-highlight">1379</i>&nbsp;        System.arraycopy(keyBytes, 0, fullKey, keyOffset, keyBytes.length);</b>
<i class="no-highlight">1380</i>&nbsp;
<i class="no-highlight">1381</i>&nbsp;        final byte[] finalKey;
<i class="no-highlight">1382</i>&nbsp;        final byte[] finalData;
<b class="nc"><i class="no-highlight">1383</i>&nbsp;        if (duplicates) {</b>
<b class="nc"><i class="no-highlight">1384</i>&nbsp;            finalKey = new byte[keySize];</b>
<b class="nc"><i class="no-highlight">1385</i>&nbsp;            finalData = new byte[dataSize];</b>
<b class="nc"><i class="no-highlight">1386</i>&nbsp;            System.arraycopy(fullKey, 0, finalKey, 0, keySize);</b>
<b class="nc"><i class="no-highlight">1387</i>&nbsp;            System.arraycopy(fullKey, keySize, finalData, 0, dataSize);</b>
<i class="no-highlight">1388</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">1389</i>&nbsp;            finalKey = fullKey;</b>
<b class="nc"><i class="no-highlight">1390</i>&nbsp;            finalData = new byte[Math.max(0, dataSize)];</b>
<i class="no-highlight">1391</i>&nbsp;        }
<i class="no-highlight">1392</i>&nbsp;
<b class="nc"><i class="no-highlight">1393</i>&nbsp;        keyEntry.setData(finalKey);</b>
<b class="nc"><i class="no-highlight">1394</i>&nbsp;        dataEntry.setData(finalData);</b>
<i class="no-highlight">1395</i>&nbsp;    }
<i class="no-highlight">1396</i>&nbsp;
<i class="no-highlight">1397</i>&nbsp;    /**
<i class="no-highlight">1398</i>&nbsp;     * Prints Java properties for information collected by calculateCacheSizes.
<i class="no-highlight">1399</i>&nbsp;     * Min/max sizes are output for compatibility with earlier versions; in the
<i class="no-highlight">1400</i>&nbsp;     * past, min and max were different values.
<i class="no-highlight">1401</i>&nbsp;     */
<i class="no-highlight">1402</i>&nbsp;    private void printProperties(final PrintStream out) {
<b class="nc"><i class="no-highlight">1403</i>&nbsp;        out.println(&quot;overhead=&quot; + envOverhead);</b>
<b class="nc"><i class="no-highlight">1404</i>&nbsp;        out.println(&quot;internalNodes=&quot; + mainNoLNsOrVLSNs);</b>
<b class="nc"><i class="no-highlight">1405</i>&nbsp;        out.println(&quot;internalNodesAndVersions=&quot; + mainNoLNsWithVLSNs);</b>
<b class="nc"><i class="no-highlight">1406</i>&nbsp;        if (dataSize &gt;= 0) {</b>
<b class="nc"><i class="no-highlight">1407</i>&nbsp;            out.println(&quot;allNodes=&quot; + mainWithLNsAndVLSNs);</b>
<i class="no-highlight">1408</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1409</i>&nbsp;        if (offHeapCache) {</b>
<b class="nc"><i class="no-highlight">1410</i>&nbsp;            out.println(&quot;minMainCache=&quot; + (mainMinDataSize + envOverhead));</b>
<b class="nc"><i class="no-highlight">1411</i>&nbsp;            out.println(&quot;offHeapInternalNodes=&quot; + offHeapNoLNsOrVLSNs);</b>
<b class="nc"><i class="no-highlight">1412</i>&nbsp;            if (dataSize &gt;= 0) {</b>
<b class="nc"><i class="no-highlight">1413</i>&nbsp;                out.println(&quot;offHeapAllNodes=&quot; + offHeapWithLNsAndVLSNs);</b>
<i class="no-highlight">1414</i>&nbsp;            }
<i class="no-highlight">1415</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1416</i>&nbsp;        out.println(&quot;# Following are deprecated&quot;);</b>
<b class="nc"><i class="no-highlight">1417</i>&nbsp;        out.println(&quot;minInternalNodes=&quot; + mainNoLNsOrVLSNs);</b>
<b class="nc"><i class="no-highlight">1418</i>&nbsp;        out.println(&quot;maxInternalNodes=&quot; + mainNoLNsOrVLSNs);</b>
<b class="nc"><i class="no-highlight">1419</i>&nbsp;        if (dataSize &gt;= 0) {</b>
<b class="nc"><i class="no-highlight">1420</i>&nbsp;            out.println(&quot;minAllNodes=&quot; + mainWithLNsAndVLSNs);</b>
<b class="nc"><i class="no-highlight">1421</i>&nbsp;            out.println(&quot;maxAllNodes=&quot; + mainWithLNsAndVLSNs);</b>
<i class="no-highlight">1422</i>&nbsp;        }
<i class="no-highlight">1423</i>&nbsp;    }
<i class="no-highlight">1424</i>&nbsp;
<i class="no-highlight">1425</i>&nbsp;    /**
<i class="no-highlight">1426</i>&nbsp;     * Prints information collected by calculateCacheSizes.
<i class="no-highlight">1427</i>&nbsp;     */
<i class="no-highlight">1428</i>&nbsp;    void printCacheSizes(final PrintStream out) {
<i class="no-highlight">1429</i>&nbsp;
<b class="nc"><i class="no-highlight">1430</i>&nbsp;        final String mainSuffix = offHeapCache ? &quot;: MAIN cache&quot; : &quot;&quot;;</b>
<b class="nc"><i class="no-highlight">1431</i>&nbsp;        final String offHeapSuffix = &quot;: OFF-HEAP cache&quot;;</b>
<i class="no-highlight">1432</i>&nbsp;
<b class="nc"><i class="no-highlight">1433</i>&nbsp;        out.println();</b>
<b class="nc"><i class="no-highlight">1434</i>&nbsp;        out.println(&quot;=== Environment Cache Overhead ===&quot;);</b>
<b class="nc"><i class="no-highlight">1435</i>&nbsp;        out.println();</b>
<b class="nc"><i class="no-highlight">1436</i>&nbsp;        out.print(INT_FORMAT.format(envOverhead));</b>
<b class="nc"><i class="no-highlight">1437</i>&nbsp;        out.println(&quot; minimum bytes&quot;);</b>
<b class="nc"><i class="no-highlight">1438</i>&nbsp;        out.println();</b>
<b class="nc"><i class="no-highlight">1439</i>&nbsp;        out.println(</b>
<i class="no-highlight">1440</i>&nbsp;            &quot;To account for JE daemon operation, record locks, HA network &quot; +
<i class="no-highlight">1441</i>&nbsp;            &quot;connections, etc,&quot;);
<b class="nc"><i class="no-highlight">1442</i>&nbsp;        out.println(&quot;a larger amount is needed in practice.&quot;);</b>
<b class="nc"><i class="no-highlight">1443</i>&nbsp;        out.println();</b>
<b class="nc"><i class="no-highlight">1444</i>&nbsp;        out.println(&quot;=== Database Cache Size ===&quot;);</b>
<b class="nc"><i class="no-highlight">1445</i>&nbsp;        out.println();</b>
<b class="nc"><i class="no-highlight">1446</i>&nbsp;        out.println(MAIN_HEADER);</b>
<i class="no-highlight">1447</i>&nbsp;
<b class="nc"><i class="no-highlight">1448</i>&nbsp;        out.println(line(</b>
<i class="no-highlight">1449</i>&nbsp;            mainNoLNsOrVLSNs, &quot;Internal nodes only&quot; + mainSuffix));
<i class="no-highlight">1450</i>&nbsp;
<b class="nc"><i class="no-highlight">1451</i>&nbsp;        if (offHeapCache) {</b>
<b class="nc"><i class="no-highlight">1452</i>&nbsp;            out.println(line(</b>
<i class="no-highlight">1453</i>&nbsp;                offHeapNoLNsOrVLSNs, &quot;Internal nodes only&quot; + offHeapSuffix));
<i class="no-highlight">1454</i>&nbsp;        }
<i class="no-highlight">1455</i>&nbsp;
<b class="nc"><i class="no-highlight">1456</i>&nbsp;        if (dataSize &gt;= 0) {</b>
<b class="nc"><i class="no-highlight">1457</i>&nbsp;            if (!offHeapCache &amp;&amp; mainNoLNsWithVLSNs != mainNoLNsOrVLSNs) {</b>
<b class="nc"><i class="no-highlight">1458</i>&nbsp;                out.println(line(</b>
<i class="no-highlight">1459</i>&nbsp;                    mainNoLNsWithVLSNs,
<i class="no-highlight">1460</i>&nbsp;                    &quot;Internal nodes and record versions&quot; + mainSuffix));
<i class="no-highlight">1461</i>&nbsp;            }
<i class="no-highlight">1462</i>&nbsp;
<b class="nc"><i class="no-highlight">1463</i>&nbsp;            out.println(line(</b>
<i class="no-highlight">1464</i>&nbsp;                mainWithLNsAndVLSNs,
<i class="no-highlight">1465</i>&nbsp;                &quot;Internal nodes and leaf nodes&quot; + mainSuffix));
<i class="no-highlight">1466</i>&nbsp;
<b class="nc"><i class="no-highlight">1467</i>&nbsp;            if (offHeapCache) {</b>
<b class="nc"><i class="no-highlight">1468</i>&nbsp;                out.println(line(</b>
<i class="no-highlight">1469</i>&nbsp;                    offHeapWithLNsAndVLSNs,
<i class="no-highlight">1470</i>&nbsp;                    &quot;Internal nodes and leaf nodes&quot; + offHeapSuffix));
<i class="no-highlight">1471</i>&nbsp;            }
<i class="no-highlight">1472</i>&nbsp;
<b class="nc"><i class="no-highlight">1473</i>&nbsp;            if (mainNoLNsOrVLSNs == mainWithLNsAndVLSNs &amp;&amp;</b>
<i class="no-highlight">1474</i>&nbsp;                offHeapNoLNsOrVLSNs == offHeapWithLNsAndVLSNs){
<i class="no-highlight">1475</i>&nbsp;
<b class="nc"><i class="no-highlight">1476</i>&nbsp;                if (duplicates) {</b>
<b class="nc"><i class="no-highlight">1477</i>&nbsp;                    out.println(</b>
<i class="no-highlight">1478</i>&nbsp;                        &quot;\nNote that leaf nodes do not use additional memory&quot; +
<i class="no-highlight">1479</i>&nbsp;                        &quot; because the database is&quot; +
<i class="no-highlight">1480</i>&nbsp;                        &quot;\nconfigured for duplicates. In addition, record&quot; +
<i class="no-highlight">1481</i>&nbsp;                        &quot; versions are not applicable.&quot;);
<i class="no-highlight">1482</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">1483</i>&nbsp;                    out.println(</b>
<i class="no-highlight">1484</i>&nbsp;                        &quot;\nNote that leaf nodes do not use additional memory&quot; +
<i class="no-highlight">1485</i>&nbsp;                        &quot; because with a small&quot; +
<i class="no-highlight">1486</i>&nbsp;                        &quot;\ndata size, the LNs are embedded in the BINs.&quot; +
<i class="no-highlight">1487</i>&nbsp;                        &quot; In addition, record versions&quot; +
<i class="no-highlight">1488</i>&nbsp;                        &quot;\n(if configured) are always cached in this mode.&quot;);
<i class="no-highlight">1489</i>&nbsp;                }
<i class="no-highlight">1490</i>&nbsp;
<i class="no-highlight">1491</i>&nbsp;            }
<i class="no-highlight">1492</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">1493</i>&nbsp;            if (!duplicates) {</b>
<b class="nc"><i class="no-highlight">1494</i>&nbsp;                out.println(&quot;\nTo get leaf node sizing specify -data&quot;);</b>
<i class="no-highlight">1495</i>&nbsp;            }
<i class="no-highlight">1496</i>&nbsp;        }
<i class="no-highlight">1497</i>&nbsp;
<b class="nc"><i class="no-highlight">1498</i>&nbsp;        if (offHeapCache &amp;&amp; mainMinDataSize &gt; mainDataSize) {</b>
<b class="nc"><i class="no-highlight">1499</i>&nbsp;            out.println(</b>
<i class="no-highlight">1500</i>&nbsp;                &quot;\nWARNING: The information above applies to a data set of &quot; +
<b class="nc"><i class="no-highlight">1501</i>&nbsp;                INT_FORMAT.format(records) + &quot; records,&quot; +</b>
<i class="no-highlight">1502</i>&nbsp;                &quot;\nnot the number of records specified, because the main&quot; +
<i class="no-highlight">1503</i>&nbsp;                &quot; cache size specified is &quot; +
<i class="no-highlight">1504</i>&nbsp;                &quot;\ntoo small to hold all upper INs. This prevents all&quot; +
<i class="no-highlight">1505</i>&nbsp;                &quot; internal nodes (or leaf&quot; +
<i class="no-highlight">1506</i>&nbsp;                &quot;\nnodes) from fitting into cache, and the data set was&quot; +
<i class="no-highlight">1507</i>&nbsp;                &quot; reduced accordingly. To&quot; +
<i class="no-highlight">1508</i>&nbsp;                &quot;\nfit all internal nodes in cache with the specified &quot; +
<i class="no-highlight">1509</i>&nbsp;                &quot; number of records, specify&quot; +
<i class="no-highlight">1510</i>&nbsp;                &quot;\na main cache size of at least &quot; +
<b class="nc"><i class="no-highlight">1511</i>&nbsp;                INT_FORMAT.format(mainMinDataSize + envOverhead) + &quot; bytes.&quot;);</b>
<i class="no-highlight">1512</i>&nbsp;        }
<i class="no-highlight">1513</i>&nbsp;
<b class="nc"><i class="no-highlight">1514</i>&nbsp;        if (btreeInfo) {</b>
<b class="nc"><i class="no-highlight">1515</i>&nbsp;            out.println();</b>
<b class="nc"><i class="no-highlight">1516</i>&nbsp;            out.println(&quot;=== Calculated Btree Information ===&quot;);</b>
<b class="nc"><i class="no-highlight">1517</i>&nbsp;            out.println();</b>
<b class="nc"><i class="no-highlight">1518</i>&nbsp;            out.println(line(btreeLevels, &quot;Btree levels&quot;));</b>
<b class="nc"><i class="no-highlight">1519</i>&nbsp;            out.println(line(nUinNodes, &quot;Upper internal nodes&quot;));</b>
<b class="nc"><i class="no-highlight">1520</i>&nbsp;            out.println(line(nBinNodes, &quot;Bottom internal nodes&quot;));</b>
<i class="no-highlight">1521</i>&nbsp;
<b class="nc"><i class="no-highlight">1522</i>&nbsp;            if (offHeapCache) {</b>
<b class="nc"><i class="no-highlight">1523</i>&nbsp;                out.println();</b>
<b class="nc"><i class="no-highlight">1524</i>&nbsp;                out.println(&quot;--- BINs and LNs in Main Cache vs Off-heap ---&quot;);</b>
<b class="nc"><i class="no-highlight">1525</i>&nbsp;                out.println();</b>
<b class="nc"><i class="no-highlight">1526</i>&nbsp;                out.println(line(</b>
<i class="no-highlight">1527</i>&nbsp;                    nMainBINsNoLNsOrVLSNs,
<i class="no-highlight">1528</i>&nbsp;                    &quot;Internal nodes only, BINs&quot; + mainSuffix));
<b class="nc"><i class="no-highlight">1529</i>&nbsp;                out.println(line(</b>
<i class="no-highlight">1530</i>&nbsp;                    nBinNodes - nMainBINsNoLNsOrVLSNs,
<i class="no-highlight">1531</i>&nbsp;                    &quot;Internal nodes only, BINs&quot; + offHeapSuffix));
<b class="nc"><i class="no-highlight">1532</i>&nbsp;                out.println(line(</b>
<i class="no-highlight">1533</i>&nbsp;                    nMainBINsWithLNsAndVLSNs,
<i class="no-highlight">1534</i>&nbsp;                    &quot;Internal nodes and leaf nodes, BINs&quot; + mainSuffix));
<b class="nc"><i class="no-highlight">1535</i>&nbsp;                out.println(line(</b>
<i class="no-highlight">1536</i>&nbsp;                    nBinNodes - nMainBINsWithLNsAndVLSNs,
<i class="no-highlight">1537</i>&nbsp;                    &quot;Internal nodes and leaf nodes, BINs&quot; + offHeapSuffix));
<b class="nc"><i class="no-highlight">1538</i>&nbsp;                out.println(line(</b>
<i class="no-highlight">1539</i>&nbsp;                    nMainLNsWithLNsAndVLSNs,
<i class="no-highlight">1540</i>&nbsp;                    &quot;Internal nodes and leaf nodes, LNs&quot; + mainSuffix));
<b class="nc"><i class="no-highlight">1541</i>&nbsp;                out.println(line(</b>
<i class="no-highlight">1542</i>&nbsp;                    records - nMainLNsWithLNsAndVLSNs,
<i class="no-highlight">1543</i>&nbsp;                    &quot;Internal nodes and leaf nodes, LNs&quot; + offHeapSuffix));
<i class="no-highlight">1544</i>&nbsp;            }
<i class="no-highlight">1545</i>&nbsp;        }
<i class="no-highlight">1546</i>&nbsp;
<b class="nc"><i class="no-highlight">1547</i>&nbsp;        out.println();</b>
<b class="nc"><i class="no-highlight">1548</i>&nbsp;        out.println(&quot;For further information see the DbCacheSize javadoc.&quot;);</b>
<i class="no-highlight">1549</i>&nbsp;    }
<i class="no-highlight">1550</i>&nbsp;
<i class="no-highlight">1551</i>&nbsp;    private String line(final long num, final String comment) {
<i class="no-highlight">1552</i>&nbsp;
<b class="nc"><i class="no-highlight">1553</i>&nbsp;        final StringBuilder buf = new StringBuilder(100);</b>
<i class="no-highlight">1554</i>&nbsp;
<b class="nc"><i class="no-highlight">1555</i>&nbsp;        column(buf, INT_FORMAT.format(num));</b>
<b class="nc"><i class="no-highlight">1556</i>&nbsp;        buf.append(COLUMN_SEPARATOR);</b>
<b class="nc"><i class="no-highlight">1557</i>&nbsp;        buf.append(comment);</b>
<i class="no-highlight">1558</i>&nbsp;
<b class="nc"><i class="no-highlight">1559</i>&nbsp;        return buf.toString();</b>
<i class="no-highlight">1560</i>&nbsp;    }
<i class="no-highlight">1561</i>&nbsp;
<i class="no-highlight">1562</i>&nbsp;    private void column(final StringBuilder buf, final String str) {
<i class="no-highlight">1563</i>&nbsp;
<b class="nc"><i class="no-highlight">1564</i>&nbsp;        int start = buf.length();</b>
<i class="no-highlight">1565</i>&nbsp;
<b class="nc"><i class="no-highlight">1566</i>&nbsp;        while (buf.length() - start + str.length() &lt; MIN_COLUMN_WIDTH) {</b>
<b class="nc"><i class="no-highlight">1567</i>&nbsp;            buf.append(&#39; &#39;);</b>
<i class="no-highlight">1568</i>&nbsp;        }
<i class="no-highlight">1569</i>&nbsp;
<b class="nc"><i class="no-highlight">1570</i>&nbsp;        buf.append(str);</b>
<i class="no-highlight">1571</i>&nbsp;    }
<i class="no-highlight">1572</i>&nbsp;
<i class="no-highlight">1573</i>&nbsp;    /**
<i class="no-highlight">1574</i>&nbsp;     * For testing, insert the specified data set and initialize
<i class="no-highlight">1575</i>&nbsp;     * measuredMainNoLNsWithVLSNs and measuredMainWithLNsAndVLSNs.
<i class="no-highlight">1576</i>&nbsp;     */
<i class="no-highlight">1577</i>&nbsp;    void measure(final PrintStream out) {
<i class="no-highlight">1578</i>&nbsp;
<b class="nc"><i class="no-highlight">1579</i>&nbsp;        Environment env = openMeasureEnvironment(</b>
<i class="no-highlight">1580</i>&nbsp;            true /*createNew*/, false /*setMainSize*/);
<i class="no-highlight">1581</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">1582</i>&nbsp;            IN.ACCUMULATED_LIMIT = 0;</b>
<i class="no-highlight">1583</i>&nbsp;
<b class="nc"><i class="no-highlight">1584</i>&nbsp;            Database db = openDatabase(env, true);</b>
<i class="no-highlight">1585</i>&nbsp;
<b class="nc"><i class="no-highlight">1586</i>&nbsp;            if (out != null) {</b>
<b class="nc"><i class="no-highlight">1587</i>&nbsp;                out.println(</b>
<i class="no-highlight">1588</i>&nbsp;                    &quot;Measuring with maximum cache size: &quot; +
<b class="nc"><i class="no-highlight">1589</i>&nbsp;                    INT_FORMAT.format(env.getConfig().getCacheSize()) +</b>
<i class="no-highlight">1590</i>&nbsp;                    &quot; and (for off-heap) main data size: &quot; +
<b class="nc"><i class="no-highlight">1591</i>&nbsp;                    INT_FORMAT.format(mainDataSize));</b>
<i class="no-highlight">1592</i>&nbsp;            }
<i class="no-highlight">1593</i>&nbsp;
<b class="nc"><i class="no-highlight">1594</i>&nbsp;            insertRecords(out, env, db);</b>
<i class="no-highlight">1595</i>&nbsp;
<b class="nc"><i class="no-highlight">1596</i>&nbsp;            if (offHeapCache) {</b>
<b class="nc"><i class="no-highlight">1597</i>&nbsp;                db.close();</b>
<b class="nc"><i class="no-highlight">1598</i>&nbsp;                env.close();</b>
<b class="nc"><i class="no-highlight">1599</i>&nbsp;                env = null;</b>
<b class="nc"><i class="no-highlight">1600</i>&nbsp;                env = openMeasureEnvironment(</b>
<i class="no-highlight">1601</i>&nbsp;                    false /*createNew*/, false /*setMainSize*/);
<b class="nc"><i class="no-highlight">1602</i>&nbsp;                db = openDatabase(env, false);</b>
<i class="no-highlight">1603</i>&nbsp;
<b class="nc"><i class="no-highlight">1604</i>&nbsp;                readRecords(out, env, db, false /*readData*/);</b>
<b class="nc"><i class="no-highlight">1605</i>&nbsp;                evictMainToDataSize(db, mainDataSize);</b>
<i class="no-highlight">1606</i>&nbsp;
<b class="nc"><i class="no-highlight">1607</i>&nbsp;                measuredMainNoLNsOrVLSNs = getStats(</b>
<i class="no-highlight">1608</i>&nbsp;                    out, env, &quot;After read keys only, evict main to size&quot;);
<i class="no-highlight">1609</i>&nbsp;
<b class="nc"><i class="no-highlight">1610</i>&nbsp;                measuredOffHeapNoLNsOrVLSNs =</b>
<b class="nc"><i class="no-highlight">1611</i>&nbsp;                    getOffHeapCacheSize(DbInternal.getNonNullEnvImpl(env));</b>
<i class="no-highlight">1612</i>&nbsp;
<b class="nc"><i class="no-highlight">1613</i>&nbsp;                readRecords(out, env, db, true /*readData*/);</b>
<b class="nc"><i class="no-highlight">1614</i>&nbsp;                evictMainToDataSize(db, mainDataSize);</b>
<i class="no-highlight">1615</i>&nbsp;
<b class="nc"><i class="no-highlight">1616</i>&nbsp;                measuredMainWithLNsAndVLSNs = getStats(</b>
<i class="no-highlight">1617</i>&nbsp;                    out, env, &quot;After read all, evict main to size&quot;);
<i class="no-highlight">1618</i>&nbsp;
<b class="nc"><i class="no-highlight">1619</i>&nbsp;                measuredOffHeapWithLNsAndVLSNs =</b>
<b class="nc"><i class="no-highlight">1620</i>&nbsp;                    getOffHeapCacheSize(DbInternal.getNonNullEnvImpl(env));</b>
<i class="no-highlight">1621</i>&nbsp;
<i class="no-highlight">1622</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">1623</i>&nbsp;                measuredMainWithLNsAndVLSNs = getStats(</b>
<i class="no-highlight">1624</i>&nbsp;                    out, env, &quot;After insert&quot;);
<i class="no-highlight">1625</i>&nbsp;
<b class="nc"><i class="no-highlight">1626</i>&nbsp;                trimLNs(db);</b>
<i class="no-highlight">1627</i>&nbsp;
<b class="nc"><i class="no-highlight">1628</i>&nbsp;                measuredMainNoLNsWithVLSNs = getStats(</b>
<i class="no-highlight">1629</i>&nbsp;                    out, env, &quot;After trimLNs&quot;);
<i class="no-highlight">1630</i>&nbsp;
<b class="nc"><i class="no-highlight">1631</i>&nbsp;                trimVLSNs(db);</b>
<i class="no-highlight">1632</i>&nbsp;
<b class="nc"><i class="no-highlight">1633</i>&nbsp;                measuredMainNoLNsOrVLSNs = getStats(</b>
<i class="no-highlight">1634</i>&nbsp;                    out, env, &quot;After trimVLSNs&quot;);
<i class="no-highlight">1635</i>&nbsp;            }
<i class="no-highlight">1636</i>&nbsp;
<b class="nc"><i class="no-highlight">1637</i>&nbsp;            db.close();</b>
<b class="nc"><i class="no-highlight">1638</i>&nbsp;            env.close();</b>
<b class="nc"><i class="no-highlight">1639</i>&nbsp;            env = null;</b>
<i class="no-highlight">1640</i>&nbsp;
<b class="nc"><i class="no-highlight">1641</i>&nbsp;            env = openMeasureEnvironment(</b>
<i class="no-highlight">1642</i>&nbsp;                false /*createNew*/, offHeapCache /*setMainSize*/);
<b class="nc"><i class="no-highlight">1643</i>&nbsp;            db = openDatabase(env, false);</b>
<i class="no-highlight">1644</i>&nbsp;
<b class="nc"><i class="no-highlight">1645</i>&nbsp;            PreloadStatus status = preloadRecords(out, db, false /*loadLNs*/);</b>
<i class="no-highlight">1646</i>&nbsp;
<b class="nc"><i class="no-highlight">1647</i>&nbsp;            preloadMainNoLNsOrVLSNs = getStats(</b>
<i class="no-highlight">1648</i>&nbsp;                out, env,
<i class="no-highlight">1649</i>&nbsp;                &quot;Internal nodes only after preload (&quot; +
<i class="no-highlight">1650</i>&nbsp;                status + &quot;)&quot;);
<i class="no-highlight">1651</i>&nbsp;
<b class="nc"><i class="no-highlight">1652</i>&nbsp;            if (assumeEvictLN) {</b>
<b class="nc"><i class="no-highlight">1653</i>&nbsp;                preloadMainWithLNsAndVLSNs = preloadMainNoLNsOrVLSNs;</b>
<i class="no-highlight">1654</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">1655</i>&nbsp;                status = preloadRecords(out, db, true /*loadLNs*/);</b>
<i class="no-highlight">1656</i>&nbsp;
<b class="nc"><i class="no-highlight">1657</i>&nbsp;                preloadMainWithLNsAndVLSNs = getStats(</b>
<i class="no-highlight">1658</i>&nbsp;                    out, env,
<i class="no-highlight">1659</i>&nbsp;                    &quot;All nodes after preload (&quot; +
<i class="no-highlight">1660</i>&nbsp;                        status + &quot;)&quot;);
<i class="no-highlight">1661</i>&nbsp;            }
<i class="no-highlight">1662</i>&nbsp;
<b class="nc"><i class="no-highlight">1663</i>&nbsp;            if (!offHeapCache) {</b>
<b class="nc"><i class="no-highlight">1664</i>&nbsp;                trimLNs(db);</b>
<i class="no-highlight">1665</i>&nbsp;
<b class="nc"><i class="no-highlight">1666</i>&nbsp;                preloadMainNoLNsWithVLSNs = getStats(</b>
<i class="no-highlight">1667</i>&nbsp;                    out, env,
<i class="no-highlight">1668</i>&nbsp;                    &quot;Internal nodes plus VLSNs after preload (&quot; +
<i class="no-highlight">1669</i>&nbsp;                    status + &quot;)&quot;);
<i class="no-highlight">1670</i>&nbsp;            }
<i class="no-highlight">1671</i>&nbsp;
<b class="nc"><i class="no-highlight">1672</i>&nbsp;            db.close();</b>
<b class="nc"><i class="no-highlight">1673</i>&nbsp;            env.close();</b>
<b class="nc"><i class="no-highlight">1674</i>&nbsp;            env = null;</b>
<i class="no-highlight">1675</i>&nbsp;
<i class="no-highlight">1676</i>&nbsp;        } finally {
<i class="no-highlight">1677</i>&nbsp;
<b class="nc"><i class="no-highlight">1678</i>&nbsp;            IN.ACCUMULATED_LIMIT = IN.ACCUMULATED_LIMIT_DEFAULT;</b>
<i class="no-highlight">1679</i>&nbsp;
<i class="no-highlight">1680</i>&nbsp;            /*
<i class="no-highlight">1681</i>&nbsp;             * Do not propagate exception thrown by Environment.close if
<i class="no-highlight">1682</i>&nbsp;             * another exception is currently in flight.
<i class="no-highlight">1683</i>&nbsp;             */
<b class="nc"><i class="no-highlight">1684</i>&nbsp;            if (env != null) {</b>
<i class="no-highlight">1685</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">1686</i>&nbsp;                    env.close();</b>
<b class="nc"><i class="no-highlight">1687</i>&nbsp;                } catch (RuntimeException ignore) {</b>
<b class="nc"><i class="no-highlight">1688</i>&nbsp;                }</b>
<i class="no-highlight">1689</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1690</i>&nbsp;        }</b>
<i class="no-highlight">1691</i>&nbsp;    }
<i class="no-highlight">1692</i>&nbsp;
<i class="no-highlight">1693</i>&nbsp;    private Environment openMeasureEnvironment(final boolean createNew,
<i class="no-highlight">1694</i>&nbsp;                                               final boolean setMainSize) {
<i class="no-highlight">1695</i>&nbsp;
<b class="nc"><i class="no-highlight">1696</i>&nbsp;        final EnvironmentConfig config = envConfig.clone();</b>
<i class="no-highlight">1697</i>&nbsp;
<b class="nc"><i class="no-highlight">1698</i>&nbsp;        if (setMainSize) {</b>
<b class="nc"><i class="no-highlight">1699</i>&nbsp;            config.setCacheSize(mainCacheSize);</b>
<i class="no-highlight">1700</i>&nbsp;
<i class="no-highlight">1701</i>&nbsp;            /*
<i class="no-highlight">1702</i>&nbsp;             * Normally the main cache size is left &quot;unlimited&quot;, meaning that
<i class="no-highlight">1703</i>&nbsp;             * log buffers will be maximum sized (1 MB each). Here we limit the
<i class="no-highlight">1704</i>&nbsp;             * main cache size in order to use the off-heap cache. But with a
<i class="no-highlight">1705</i>&nbsp;             * smaller main cache, the log buffers will be smaller. Use maximum
<i class="no-highlight">1706</i>&nbsp;             * sized log buffers so we can compare totals with the case where
<i class="no-highlight">1707</i>&nbsp;             * we don&#39;t set the cache size.
<i class="no-highlight">1708</i>&nbsp;             */
<b class="nc"><i class="no-highlight">1709</i>&nbsp;            config.setConfigParam(</b>
<i class="no-highlight">1710</i>&nbsp;                EnvironmentConfig.LOG_TOTAL_BUFFER_BYTES,
<b class="nc"><i class="no-highlight">1711</i>&nbsp;                String.valueOf(3 &lt;&lt; 20));</b>
<i class="no-highlight">1712</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">1713</i>&nbsp;            config.setCachePercent(90);</b>
<i class="no-highlight">1714</i>&nbsp;        }
<i class="no-highlight">1715</i>&nbsp;
<b class="nc"><i class="no-highlight">1716</i>&nbsp;        if (offHeapCache) {</b>
<b class="nc"><i class="no-highlight">1717</i>&nbsp;            config.setOffHeapCacheSize(1024 * 1024 * 1024);</b>
<i class="no-highlight">1718</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">1719</i>&nbsp;            config.setOffHeapCacheSize(0);</b>
<i class="no-highlight">1720</i>&nbsp;        }
<i class="no-highlight">1721</i>&nbsp;
<b class="nc"><i class="no-highlight">1722</i>&nbsp;        return openEnvironment(config, createNew);</b>
<i class="no-highlight">1723</i>&nbsp;    }
<i class="no-highlight">1724</i>&nbsp;
<i class="no-highlight">1725</i>&nbsp;    private Environment openCalcEnvironment(final boolean createNew) {
<i class="no-highlight">1726</i>&nbsp;
<b class="nc"><i class="no-highlight">1727</i>&nbsp;        final EnvironmentConfig config = envConfig.clone();</b>
<i class="no-highlight">1728</i>&nbsp;
<b class="nc"><i class="no-highlight">1729</i>&nbsp;        if (offHeapCache) {</b>
<b class="nc"><i class="no-highlight">1730</i>&nbsp;            config.setOffHeapCacheSize(1024 * 1024 * 1024);</b>
<i class="no-highlight">1731</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">1732</i>&nbsp;            config.setOffHeapCacheSize(0);</b>
<i class="no-highlight">1733</i>&nbsp;        }
<i class="no-highlight">1734</i>&nbsp;
<i class="no-highlight">1735</i>&nbsp;        /* The amount of disk space needed is quite small. */
<b class="nc"><i class="no-highlight">1736</i>&nbsp;        config.setConfigParam(</b>
<b class="nc"><i class="no-highlight">1737</i>&nbsp;            EnvironmentConfig.FREE_DISK, String.valueOf(1L &lt;&lt; 20));</b>
<i class="no-highlight">1738</i>&nbsp;
<b class="nc"><i class="no-highlight">1739</i>&nbsp;        return openEnvironment(config, createNew);</b>
<i class="no-highlight">1740</i>&nbsp;    }
<i class="no-highlight">1741</i>&nbsp;
<i class="no-highlight">1742</i>&nbsp;    private Environment openEnvironment(final EnvironmentConfig config,
<i class="no-highlight">1743</i>&nbsp;                                        final boolean createNew) {
<b class="nc"><i class="no-highlight">1744</i>&nbsp;        mkTempDir();</b>
<i class="no-highlight">1745</i>&nbsp;
<b class="nc"><i class="no-highlight">1746</i>&nbsp;        if (createNew) {</b>
<b class="nc"><i class="no-highlight">1747</i>&nbsp;            emptyTempDir();</b>
<i class="no-highlight">1748</i>&nbsp;        }
<i class="no-highlight">1749</i>&nbsp;
<b class="nc"><i class="no-highlight">1750</i>&nbsp;        config.setTransactional(true);</b>
<b class="nc"><i class="no-highlight">1751</i>&nbsp;        config.setDurability(Durability.COMMIT_NO_SYNC);</b>
<b class="nc"><i class="no-highlight">1752</i>&nbsp;        config.setAllowCreate(createNew);</b>
<i class="no-highlight">1753</i>&nbsp;
<i class="no-highlight">1754</i>&nbsp;        /* Daemons interfere with cache size measurements. */
<b class="nc"><i class="no-highlight">1755</i>&nbsp;        config.setConfigParam(</b>
<i class="no-highlight">1756</i>&nbsp;            EnvironmentConfig.ENV_RUN_CLEANER, &quot;false&quot;);
<b class="nc"><i class="no-highlight">1757</i>&nbsp;        config.setConfigParam(</b>
<i class="no-highlight">1758</i>&nbsp;            EnvironmentConfig.ENV_RUN_CHECKPOINTER, &quot;false&quot;);
<b class="nc"><i class="no-highlight">1759</i>&nbsp;        config.setConfigParam(</b>
<i class="no-highlight">1760</i>&nbsp;            EnvironmentConfig.ENV_RUN_IN_COMPRESSOR, &quot;false&quot;);
<b class="nc"><i class="no-highlight">1761</i>&nbsp;        config.setConfigParam(</b>
<i class="no-highlight">1762</i>&nbsp;            EnvironmentConfig.ENV_RUN_EVICTOR, &quot;false&quot;);
<b class="nc"><i class="no-highlight">1763</i>&nbsp;        config.setConfigParam(</b>
<i class="no-highlight">1764</i>&nbsp;            EnvironmentConfig.ENV_RUN_OFFHEAP_EVICTOR, &quot;false&quot;);
<b class="nc"><i class="no-highlight">1765</i>&nbsp;        config.setConfigParam(EnvironmentConfig.ENV_RUN_VERIFIER, &quot;false&quot;);</b>
<i class="no-highlight">1766</i>&nbsp;
<i class="no-highlight">1767</i>&nbsp;        /* Evict in small chunks. */
<b class="nc"><i class="no-highlight">1768</i>&nbsp;        config.setConfigParam(</b>
<i class="no-highlight">1769</i>&nbsp;            EnvironmentConfig.EVICTOR_EVICT_BYTES, &quot;1024&quot;);
<i class="no-highlight">1770</i>&nbsp;
<i class="no-highlight">1771</i>&nbsp;        final Environment newEnv;
<i class="no-highlight">1772</i>&nbsp;
<b class="nc"><i class="no-highlight">1773</i>&nbsp;        if (replicated) {</b>
<i class="no-highlight">1774</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">1775</i>&nbsp;                final Class repEnvClass = Class.forName</b>
<b class="nc"><i class="no-highlight">1776</i>&nbsp;                    (&quot;com.sleepycat.je.rep.utilint.DbCacheSizeRepEnv&quot;);</b>
<b class="nc"><i class="no-highlight">1777</i>&nbsp;                final DbCacheSizeRepEnv repEnv =</b>
<b class="nc"><i class="no-highlight">1778</i>&nbsp;                    (DbCacheSizeRepEnv) repEnvClass.newInstance();</b>
<b class="nc"><i class="no-highlight">1779</i>&nbsp;                newEnv = repEnv.open(tempDir, config, repParams);</b>
<b class="nc"><i class="no-highlight">1780</i>&nbsp;            } catch (ClassNotFoundException |</b>
<i class="no-highlight">1781</i>&nbsp;                     InstantiationException |
<i class="no-highlight">1782</i>&nbsp;                     IllegalAccessException e) {
<b class="nc"><i class="no-highlight">1783</i>&nbsp;                throw new IllegalStateException(e);</b>
<b class="nc"><i class="no-highlight">1784</i>&nbsp;            }</b>
<i class="no-highlight">1785</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">1786</i>&nbsp;            if (!repParams.isEmpty()) {</b>
<b class="nc"><i class="no-highlight">1787</i>&nbsp;                throw new IllegalArgumentException(</b>
<i class="no-highlight">1788</i>&nbsp;                    &quot;Cannot set replication params in a standalone &quot; +
<i class="no-highlight">1789</i>&nbsp;                    &quot;environment.  May add -replicated.&quot;);
<i class="no-highlight">1790</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1791</i>&nbsp;            newEnv = new Environment(tempDir, config);</b>
<i class="no-highlight">1792</i>&nbsp;        }
<i class="no-highlight">1793</i>&nbsp;
<i class="no-highlight">1794</i>&nbsp;        /*
<i class="no-highlight">1795</i>&nbsp;         * LSN compaction is typically effective (in a realistic data set) only
<i class="no-highlight">1796</i>&nbsp;         * when the file size fits in 3 bytes and sequential keys are written.
<i class="no-highlight">1797</i>&nbsp;         * Since a tiny data set is use for estimating, and a small data set
<i class="no-highlight">1798</i>&nbsp;         * for testing, we disable the compact representation when it is
<i class="no-highlight">1799</i>&nbsp;         * unlikely to be effective.
<i class="no-highlight">1800</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1801</i>&nbsp;        final long fileSize = Integer.parseInt(</b>
<b class="nc"><i class="no-highlight">1802</i>&nbsp;            newEnv.getConfig().getConfigParam(EnvironmentConfig.LOG_FILE_MAX));</b>
<i class="no-highlight">1803</i>&nbsp;
<b class="nc"><i class="no-highlight">1804</i>&nbsp;        if ((fileSize &gt; IN.MAX_FILE_OFFSET) || !orderedInsertion) {</b>
<b class="nc"><i class="no-highlight">1805</i>&nbsp;            IN.disableCompactLsns = true;</b>
<i class="no-highlight">1806</i>&nbsp;        }
<i class="no-highlight">1807</i>&nbsp;
<i class="no-highlight">1808</i>&nbsp;        /*
<i class="no-highlight">1809</i>&nbsp;         * Preallocate 1st chunk of LRU entries, so it is counted in env
<i class="no-highlight">1810</i>&nbsp;         * overhead.
<i class="no-highlight">1811</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1812</i>&nbsp;        if (offHeapCache) {</b>
<b class="nc"><i class="no-highlight">1813</i>&nbsp;            DbInternal.getNonNullEnvImpl(newEnv).</b>
<b class="nc"><i class="no-highlight">1814</i>&nbsp;                getOffHeapCache().preallocateLRUEntries();</b>
<i class="no-highlight">1815</i>&nbsp;        }
<i class="no-highlight">1816</i>&nbsp;
<b class="nc"><i class="no-highlight">1817</i>&nbsp;        return newEnv;</b>
<i class="no-highlight">1818</i>&nbsp;    }
<i class="no-highlight">1819</i>&nbsp;
<i class="no-highlight">1820</i>&nbsp;    private void mkTempDir() {
<b class="nc"><i class="no-highlight">1821</i>&nbsp;        if (tempDir == null) {</b>
<i class="no-highlight">1822</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">1823</i>&nbsp;                tempDir = File.createTempFile(&quot;DbCacheSize&quot;, null);</b>
<b class="nc"><i class="no-highlight">1824</i>&nbsp;            } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">1825</i>&nbsp;                throw new IllegalStateException(e);</b>
<b class="nc"><i class="no-highlight">1826</i>&nbsp;            }</b>
<i class="no-highlight">1827</i>&nbsp;            /* createTempFile creates a file, but we want a directory. */
<b class="nc"><i class="no-highlight">1828</i>&nbsp;            tempDir.delete();</b>
<b class="nc"><i class="no-highlight">1829</i>&nbsp;            tempDir.mkdir();</b>
<i class="no-highlight">1830</i>&nbsp;        }
<i class="no-highlight">1831</i>&nbsp;    }
<i class="no-highlight">1832</i>&nbsp;
<i class="no-highlight">1833</i>&nbsp;    private void emptyTempDir() {
<b class="nc"><i class="no-highlight">1834</i>&nbsp;        if (tempDir == null) {</b>
<i class="no-highlight">1835</i>&nbsp;            return;
<i class="no-highlight">1836</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1837</i>&nbsp;        final File[] children = tempDir.listFiles();</b>
<b class="nc"><i class="no-highlight">1838</i>&nbsp;        if (children != null) {</b>
<b class="nc"><i class="no-highlight">1839</i>&nbsp;            for (File child : children) {</b>
<b class="nc"><i class="no-highlight">1840</i>&nbsp;                child.delete();</b>
<i class="no-highlight">1841</i>&nbsp;            }
<i class="no-highlight">1842</i>&nbsp;        }
<i class="no-highlight">1843</i>&nbsp;    }
<i class="no-highlight">1844</i>&nbsp;
<i class="no-highlight">1845</i>&nbsp;    private Database openDatabase(final Environment env,
<i class="no-highlight">1846</i>&nbsp;                                  final boolean createNew) {
<b class="nc"><i class="no-highlight">1847</i>&nbsp;        final DatabaseConfig dbConfig = new DatabaseConfig();</b>
<b class="nc"><i class="no-highlight">1848</i>&nbsp;        dbConfig.setTransactional(true);</b>
<b class="nc"><i class="no-highlight">1849</i>&nbsp;        dbConfig.setAllowCreate(createNew);</b>
<b class="nc"><i class="no-highlight">1850</i>&nbsp;        dbConfig.setExclusiveCreate(createNew);</b>
<b class="nc"><i class="no-highlight">1851</i>&nbsp;        dbConfig.setNodeMaxEntries(nodeMaxEntries);</b>
<b class="nc"><i class="no-highlight">1852</i>&nbsp;        dbConfig.setKeyPrefixing(keyPrefix &gt; 0);</b>
<b class="nc"><i class="no-highlight">1853</i>&nbsp;        dbConfig.setSortedDuplicates(duplicates);</b>
<b class="nc"><i class="no-highlight">1854</i>&nbsp;        return env.openDatabase(null, &quot;foo&quot;, dbConfig);</b>
<i class="no-highlight">1855</i>&nbsp;    }
<i class="no-highlight">1856</i>&nbsp;
<i class="no-highlight">1857</i>&nbsp;    /**
<i class="no-highlight">1858</i>&nbsp;     * Inserts records and ensures that no eviction occurs.  LNs (and VLSNs)
<i class="no-highlight">1859</i>&nbsp;     * are left intact.
<i class="no-highlight">1860</i>&nbsp;     */
<i class="no-highlight">1861</i>&nbsp;    private void insertRecords(final PrintStream out,
<i class="no-highlight">1862</i>&nbsp;                               final Environment env,
<i class="no-highlight">1863</i>&nbsp;                               final Database db) {
<b class="nc"><i class="no-highlight">1864</i>&nbsp;        final DatabaseEntry keyEntry = new DatabaseEntry();</b>
<b class="nc"><i class="no-highlight">1865</i>&nbsp;        final DatabaseEntry dataEntry = new DatabaseEntry();</b>
<i class="no-highlight">1866</i>&nbsp;
<b class="nc"><i class="no-highlight">1867</i>&nbsp;        final int lastKey = (int) (records - 1);</b>
<b class="nc"><i class="no-highlight">1868</i>&nbsp;        final byte[] lastKeyBytes = BigInteger.valueOf(lastKey).toByteArray();</b>
<b class="nc"><i class="no-highlight">1869</i>&nbsp;        final int maxKeyBytes = lastKeyBytes.length;</b>
<i class="no-highlight">1870</i>&nbsp;
<i class="no-highlight">1871</i>&nbsp;        final int keyOffset;
<b class="nc"><i class="no-highlight">1872</i>&nbsp;        if (keyPrefix == 0) {</b>
<b class="nc"><i class="no-highlight">1873</i>&nbsp;            keyOffset = 0;</b>
<i class="no-highlight">1874</i>&nbsp;        } else {
<i class="no-highlight">1875</i>&nbsp;
<i class="no-highlight">1876</i>&nbsp;            /*
<i class="no-highlight">1877</i>&nbsp;             * Calculate prefix length for generated keys and adjust key offset
<i class="no-highlight">1878</i>&nbsp;             * to produce the desired prefix length.
<i class="no-highlight">1879</i>&nbsp;             */
<b class="nc"><i class="no-highlight">1880</i>&nbsp;            final int nodeAvg = orderedInsertion ?</b>
<i class="no-highlight">1881</i>&nbsp;                nodeMaxEntries :
<i class="no-highlight">1882</i>&nbsp;                ((nodeMaxEntries * DEFAULT_DENSITY) / 100);
<b class="nc"><i class="no-highlight">1883</i>&nbsp;            final int prevKey = lastKey - (nodeAvg * 2);</b>
<b class="nc"><i class="no-highlight">1884</i>&nbsp;            final byte[] prevKeyBytes =</b>
<b class="nc"><i class="no-highlight">1885</i>&nbsp;                padLeft(BigInteger.valueOf(prevKey).toByteArray(),</b>
<i class="no-highlight">1886</i>&nbsp;                        maxKeyBytes);
<b class="nc"><i class="no-highlight">1887</i>&nbsp;            int calcPrefix = 0;</b>
<b class="nc"><i class="no-highlight">1888</i>&nbsp;            while (calcPrefix &lt; lastKeyBytes.length &amp;&amp;</b>
<i class="no-highlight">1889</i>&nbsp;                   calcPrefix &lt; prevKeyBytes.length &amp;&amp;
<i class="no-highlight">1890</i>&nbsp;                   lastKeyBytes[calcPrefix] == prevKeyBytes[calcPrefix]) {
<b class="nc"><i class="no-highlight">1891</i>&nbsp;                calcPrefix += 1;</b>
<i class="no-highlight">1892</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1893</i>&nbsp;            keyOffset = keyPrefix - calcPrefix;</b>
<i class="no-highlight">1894</i>&nbsp;        }
<i class="no-highlight">1895</i>&nbsp;
<i class="no-highlight">1896</i>&nbsp;        /* Generate random keys. */
<b class="nc"><i class="no-highlight">1897</i>&nbsp;        List&lt;Integer&gt; rndKeys = null;</b>
<b class="nc"><i class="no-highlight">1898</i>&nbsp;        if (!orderedInsertion) {</b>
<b class="nc"><i class="no-highlight">1899</i>&nbsp;            rndKeys = new ArrayList&lt;Integer&gt;(lastKey + 1);</b>
<b class="nc"><i class="no-highlight">1900</i>&nbsp;            for (int i = 0; i &lt;= lastKey; i += 1) {</b>
<b class="nc"><i class="no-highlight">1901</i>&nbsp;                rndKeys.add(i);</b>
<i class="no-highlight">1902</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1903</i>&nbsp;            Collections.shuffle(rndKeys, new Random(123));</b>
<i class="no-highlight">1904</i>&nbsp;        }
<i class="no-highlight">1905</i>&nbsp;
<b class="nc"><i class="no-highlight">1906</i>&nbsp;        final WriteOptions options = new WriteOptions();</b>
<b class="nc"><i class="no-highlight">1907</i>&nbsp;        if (useTTL) {</b>
<b class="nc"><i class="no-highlight">1908</i>&nbsp;            options.setTTL(30, TimeUnit.DAYS);</b>
<i class="no-highlight">1909</i>&nbsp;        }
<i class="no-highlight">1910</i>&nbsp;
<b class="nc"><i class="no-highlight">1911</i>&nbsp;        final Transaction txn = env.beginTransaction(null, null);</b>
<b class="nc"><i class="no-highlight">1912</i>&nbsp;        final Cursor cursor = db.openCursor(txn, null);</b>
<b class="nc"><i class="no-highlight">1913</i>&nbsp;        boolean success = false;</b>
<i class="no-highlight">1914</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">1915</i>&nbsp;            for (int i = 0; i &lt;= lastKey; i += 1) {</b>
<b class="nc"><i class="no-highlight">1916</i>&nbsp;                final int keyVal = orderedInsertion ? i : rndKeys.get(i);</b>
<b class="nc"><i class="no-highlight">1917</i>&nbsp;                final byte[] keyBytes = padLeft(</b>
<b class="nc"><i class="no-highlight">1918</i>&nbsp;                    BigInteger.valueOf(keyVal).toByteArray(), maxKeyBytes);</b>
<b class="nc"><i class="no-highlight">1919</i>&nbsp;                setKeyData(keyBytes, keyOffset, keyEntry, dataEntry);</b>
<i class="no-highlight">1920</i>&nbsp;
<b class="nc"><i class="no-highlight">1921</i>&nbsp;                final OperationResult result = cursor.put(</b>
<i class="no-highlight">1922</i>&nbsp;                    keyEntry, dataEntry,
<i class="no-highlight">1923</i>&nbsp;                    duplicates ? Put.NO_DUP_DATA : Put.NO_OVERWRITE,
<i class="no-highlight">1924</i>&nbsp;                    options);
<i class="no-highlight">1925</i>&nbsp;
<b class="nc"><i class="no-highlight">1926</i>&nbsp;                if (result == null &amp;&amp; !orderedInsertion) {</b>
<b class="nc"><i class="no-highlight">1927</i>&nbsp;                    i -= 1;</b>
<b class="nc"><i class="no-highlight">1928</i>&nbsp;                    continue;</b>
<i class="no-highlight">1929</i>&nbsp;                }
<b class="nc"><i class="no-highlight">1930</i>&nbsp;                if (result == null) {</b>
<b class="nc"><i class="no-highlight">1931</i>&nbsp;                    throw new IllegalStateException(&quot;Could not insert&quot;);</b>
<i class="no-highlight">1932</i>&nbsp;                }
<i class="no-highlight">1933</i>&nbsp;
<b class="nc"><i class="no-highlight">1934</i>&nbsp;                if (i % 10000 == 0) {</b>
<b class="nc"><i class="no-highlight">1935</i>&nbsp;                    checkForEviction(env, i);</b>
<b class="nc"><i class="no-highlight">1936</i>&nbsp;                    if (out != null) {</b>
<b class="nc"><i class="no-highlight">1937</i>&nbsp;                        out.print(&quot;.&quot;);</b>
<b class="nc"><i class="no-highlight">1938</i>&nbsp;                        out.flush();</b>
<i class="no-highlight">1939</i>&nbsp;                    }
<i class="no-highlight">1940</i>&nbsp;                }
<i class="no-highlight">1941</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1942</i>&nbsp;            success = true;</b>
<i class="no-highlight">1943</i>&nbsp;        } finally {
<b class="nc"><i class="no-highlight">1944</i>&nbsp;            cursor.close();</b>
<b class="nc"><i class="no-highlight">1945</i>&nbsp;            if (success) {</b>
<b class="nc"><i class="no-highlight">1946</i>&nbsp;                txn.commit();</b>
<i class="no-highlight">1947</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">1948</i>&nbsp;                txn.abort();</b>
<i class="no-highlight">1949</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1950</i>&nbsp;        }</b>
<i class="no-highlight">1951</i>&nbsp;
<b class="nc"><i class="no-highlight">1952</i>&nbsp;        checkForEviction(env, lastKey);</b>
<i class="no-highlight">1953</i>&nbsp;
<i class="no-highlight">1954</i>&nbsp;        /* Checkpoint to speed recovery and reset the memory budget. */
<b class="nc"><i class="no-highlight">1955</i>&nbsp;        env.checkpoint(new CheckpointConfig().setForce(true));</b>
<i class="no-highlight">1956</i>&nbsp;
<i class="no-highlight">1957</i>&nbsp;        /* Let&#39;s be sure the memory budget is updated. */
<b class="nc"><i class="no-highlight">1958</i>&nbsp;        iterateBINs(db, new BINVisitor() {</b>
<i class="no-highlight">1959</i>&nbsp;            @Override
<i class="no-highlight">1960</i>&nbsp;            public boolean visitBIN(final BIN bin) {
<b class="nc"><i class="no-highlight">1961</i>&nbsp;                bin.updateMemoryBudget();</b>
<b class="nc"><i class="no-highlight">1962</i>&nbsp;                return true;</b>
<i class="no-highlight">1963</i>&nbsp;            }
<i class="no-highlight">1964</i>&nbsp;        });
<i class="no-highlight">1965</i>&nbsp;    }
<i class="no-highlight">1966</i>&nbsp;
<i class="no-highlight">1967</i>&nbsp;    /**
<i class="no-highlight">1968</i>&nbsp;     * Reads all keys, optionally reading the data.
<i class="no-highlight">1969</i>&nbsp;     */
<i class="no-highlight">1970</i>&nbsp;    private void readRecords(final PrintStream out,
<i class="no-highlight">1971</i>&nbsp;                             final Environment env,
<i class="no-highlight">1972</i>&nbsp;                             final Database db,
<i class="no-highlight">1973</i>&nbsp;                             final boolean readData) {
<i class="no-highlight">1974</i>&nbsp;
<b class="nc"><i class="no-highlight">1975</i>&nbsp;        final DatabaseEntry keyEntry = new DatabaseEntry();</b>
<b class="nc"><i class="no-highlight">1976</i>&nbsp;        final DatabaseEntry dataEntry = new DatabaseEntry();</b>
<i class="no-highlight">1977</i>&nbsp;
<b class="nc"><i class="no-highlight">1978</i>&nbsp;        if (!readData) {</b>
<b class="nc"><i class="no-highlight">1979</i>&nbsp;            dataEntry.setPartial(0, 0, true);</b>
<i class="no-highlight">1980</i>&nbsp;        }
<i class="no-highlight">1981</i>&nbsp;
<b class="nc"><i class="no-highlight">1982</i>&nbsp;        final ReadOptions options = new ReadOptions();</b>
<i class="no-highlight">1983</i>&nbsp;
<b class="nc"><i class="no-highlight">1984</i>&nbsp;        if (assumeEvictLN) {</b>
<b class="nc"><i class="no-highlight">1985</i>&nbsp;            options.setCacheMode(CacheMode.EVICT_LN);</b>
<i class="no-highlight">1986</i>&nbsp;        }
<i class="no-highlight">1987</i>&nbsp;
<b class="nc"><i class="no-highlight">1988</i>&nbsp;        try (final Cursor cursor = db.openCursor(null, null)) {</b>
<b class="nc"><i class="no-highlight">1989</i>&nbsp;            while (cursor.get(keyEntry, dataEntry, Get.NEXT, options) !=</b>
<i class="no-highlight">1990</i>&nbsp;                    null) {
<i class="no-highlight">1991</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1992</i>&nbsp;        }</b>
<i class="no-highlight">1993</i>&nbsp;    }
<i class="no-highlight">1994</i>&nbsp;
<i class="no-highlight">1995</i>&nbsp;
<i class="no-highlight">1996</i>&nbsp;    private void checkForEviction(Environment env, int recNum) {
<b class="nc"><i class="no-highlight">1997</i>&nbsp;        final EnvironmentStats stats = env.getStats(null);</b>
<b class="nc"><i class="no-highlight">1998</i>&nbsp;        if (stats.getOffHeapNodesTargeted() &gt; 0) {</b>
<b class="nc"><i class="no-highlight">1999</i>&nbsp;            getStats(System.out, env, &quot;Out of off-heap cache&quot;);</b>
<b class="nc"><i class="no-highlight">2000</i>&nbsp;            throw new IllegalStateException(</b>
<i class="no-highlight">2001</i>&nbsp;                &quot;*** Ran out of off-heap cache at record &quot; + recNum +
<i class="no-highlight">2002</i>&nbsp;                &quot; -- try increasing off-heap cache size ***&quot;);
<i class="no-highlight">2003</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2004</i>&nbsp;        if (stats.getNNodesTargeted() &gt; 0) {</b>
<b class="nc"><i class="no-highlight">2005</i>&nbsp;            getStats(System.out, env, &quot;Out of main cache&quot;);</b>
<b class="nc"><i class="no-highlight">2006</i>&nbsp;            throw new IllegalStateException(</b>
<i class="no-highlight">2007</i>&nbsp;                &quot;*** Ran out of main cache at record &quot; + recNum +
<i class="no-highlight">2008</i>&nbsp;                &quot; -- try increasing Java heap size ***&quot;);
<i class="no-highlight">2009</i>&nbsp;        }
<i class="no-highlight">2010</i>&nbsp;    }
<i class="no-highlight">2011</i>&nbsp;
<i class="no-highlight">2012</i>&nbsp;    private void trimLNs(final Database db) {
<b class="nc"><i class="no-highlight">2013</i>&nbsp;        iterateBINs(db, new BINVisitor() {</b>
<i class="no-highlight">2014</i>&nbsp;            @Override
<i class="no-highlight">2015</i>&nbsp;            public boolean visitBIN(final BIN bin) {
<b class="nc"><i class="no-highlight">2016</i>&nbsp;                bin.evictLNs();</b>
<b class="nc"><i class="no-highlight">2017</i>&nbsp;                bin.updateMemoryBudget();</b>
<b class="nc"><i class="no-highlight">2018</i>&nbsp;                return true;</b>
<i class="no-highlight">2019</i>&nbsp;            }
<i class="no-highlight">2020</i>&nbsp;        });
<i class="no-highlight">2021</i>&nbsp;    }
<i class="no-highlight">2022</i>&nbsp;
<i class="no-highlight">2023</i>&nbsp;    private void trimVLSNs(final Database db) {
<b class="nc"><i class="no-highlight">2024</i>&nbsp;        iterateBINs(db, new BINVisitor() {</b>
<i class="no-highlight">2025</i>&nbsp;            @Override
<i class="no-highlight">2026</i>&nbsp;            public boolean visitBIN(final BIN bin) {
<b class="nc"><i class="no-highlight">2027</i>&nbsp;                bin.discardVLSNCache();</b>
<b class="nc"><i class="no-highlight">2028</i>&nbsp;                bin.updateMemoryBudget();</b>
<b class="nc"><i class="no-highlight">2029</i>&nbsp;                return true;</b>
<i class="no-highlight">2030</i>&nbsp;            }
<i class="no-highlight">2031</i>&nbsp;        });
<i class="no-highlight">2032</i>&nbsp;    }
<i class="no-highlight">2033</i>&nbsp;
<i class="no-highlight">2034</i>&nbsp;    private void evictMainToDataSize(final Database db,
<i class="no-highlight">2035</i>&nbsp;                                     final long dataSize) {
<i class="no-highlight">2036</i>&nbsp;
<b class="nc"><i class="no-highlight">2037</i>&nbsp;        if (getMainDataSize(db.getEnvironment()) &lt;= dataSize) {</b>
<i class="no-highlight">2038</i>&nbsp;            return;
<i class="no-highlight">2039</i>&nbsp;        }
<i class="no-highlight">2040</i>&nbsp;
<b class="nc"><i class="no-highlight">2041</i>&nbsp;        boolean keepGoing = iterateBINs(db, new BINVisitor() {</b>
<i class="no-highlight">2042</i>&nbsp;            @Override
<i class="no-highlight">2043</i>&nbsp;            public boolean visitBIN(final BIN bin) {
<b class="nc"><i class="no-highlight">2044</i>&nbsp;                bin.evictLNs();</b>
<b class="nc"><i class="no-highlight">2045</i>&nbsp;                bin.discardVLSNCache();</b>
<b class="nc"><i class="no-highlight">2046</i>&nbsp;                bin.updateMemoryBudget();</b>
<b class="nc"><i class="no-highlight">2047</i>&nbsp;                return getMainDataSize(db.getEnvironment()) &gt; dataSize;</b>
<i class="no-highlight">2048</i>&nbsp;            }
<i class="no-highlight">2049</i>&nbsp;        });
<i class="no-highlight">2050</i>&nbsp;
<b class="nc"><i class="no-highlight">2051</i>&nbsp;        if (!keepGoing) {</b>
<i class="no-highlight">2052</i>&nbsp;            return;
<i class="no-highlight">2053</i>&nbsp;        }
<i class="no-highlight">2054</i>&nbsp;
<b class="nc"><i class="no-highlight">2055</i>&nbsp;        final Evictor evictor =</b>
<b class="nc"><i class="no-highlight">2056</i>&nbsp;            DbInternal.getNonNullEnvImpl(db.getEnvironment()).getEvictor();</b>
<i class="no-highlight">2057</i>&nbsp;
<b class="nc"><i class="no-highlight">2058</i>&nbsp;        keepGoing = iterateBINs(db, new BINVisitor() {</b>
<i class="no-highlight">2059</i>&nbsp;            @Override
<i class="no-highlight">2060</i>&nbsp;            public boolean visitBIN(final BIN bin) {
<b class="nc"><i class="no-highlight">2061</i>&nbsp;                evictor.doTestEvict(bin, Evictor.EvictionSource.CACHEMODE);</b>
<b class="nc"><i class="no-highlight">2062</i>&nbsp;                return getMainDataSize(db.getEnvironment()) &gt; dataSize;</b>
<i class="no-highlight">2063</i>&nbsp;            }
<i class="no-highlight">2064</i>&nbsp;        });
<i class="no-highlight">2065</i>&nbsp;
<b class="nc"><i class="no-highlight">2066</i>&nbsp;        assert !keepGoing;</b>
<i class="no-highlight">2067</i>&nbsp;    }
<i class="no-highlight">2068</i>&nbsp;
<i class="no-highlight">2069</i>&nbsp;    private interface BINVisitor {
<i class="no-highlight">2070</i>&nbsp;        boolean visitBIN(BIN bin);
<i class="no-highlight">2071</i>&nbsp;    }
<i class="no-highlight">2072</i>&nbsp;
<i class="no-highlight">2073</i>&nbsp;    private boolean iterateBINs(final Database db, final BINVisitor visitor) {
<i class="no-highlight">2074</i>&nbsp;
<b class="nc"><i class="no-highlight">2075</i>&nbsp;        final DatabaseEntry key = new DatabaseEntry();</b>
<b class="nc"><i class="no-highlight">2076</i>&nbsp;        final DatabaseEntry data = new DatabaseEntry();</b>
<b class="nc"><i class="no-highlight">2077</i>&nbsp;        data.setPartial(0, 0, true);</b>
<i class="no-highlight">2078</i>&nbsp;
<b class="nc"><i class="no-highlight">2079</i>&nbsp;        final Cursor c = db.openCursor(null, null);</b>
<b class="nc"><i class="no-highlight">2080</i>&nbsp;        BIN prevBin = null;</b>
<b class="nc"><i class="no-highlight">2081</i>&nbsp;        boolean keepGoing = true;</b>
<i class="no-highlight">2082</i>&nbsp;
<b class="nc"><i class="no-highlight">2083</i>&nbsp;        while (keepGoing &amp;&amp;</b>
<b class="nc"><i class="no-highlight">2084</i>&nbsp;               c.getNext(key, data, LockMode.READ_UNCOMMITTED) ==</b>
<i class="no-highlight">2085</i>&nbsp;               OperationStatus.SUCCESS) {
<i class="no-highlight">2086</i>&nbsp;
<b class="nc"><i class="no-highlight">2087</i>&nbsp;            final BIN bin = DbInternal.getCursorImpl(c).getBIN();</b>
<i class="no-highlight">2088</i>&nbsp;
<b class="nc"><i class="no-highlight">2089</i>&nbsp;            if (bin == prevBin) {</b>
<b class="nc"><i class="no-highlight">2090</i>&nbsp;                continue;</b>
<i class="no-highlight">2091</i>&nbsp;            }
<i class="no-highlight">2092</i>&nbsp;
<b class="nc"><i class="no-highlight">2093</i>&nbsp;            if (prevBin != null) {</b>
<b class="nc"><i class="no-highlight">2094</i>&nbsp;                prevBin.latch();</b>
<b class="nc"><i class="no-highlight">2095</i>&nbsp;                keepGoing = visitor.visitBIN(prevBin);</b>
<b class="nc"><i class="no-highlight">2096</i>&nbsp;                prevBin.releaseLatchIfOwner();</b>
<i class="no-highlight">2097</i>&nbsp;            }
<i class="no-highlight">2098</i>&nbsp;
<b class="nc"><i class="no-highlight">2099</i>&nbsp;            prevBin = bin;</b>
<b class="nc"><i class="no-highlight">2100</i>&nbsp;        }</b>
<i class="no-highlight">2101</i>&nbsp;
<b class="nc"><i class="no-highlight">2102</i>&nbsp;        c.close();</b>
<i class="no-highlight">2103</i>&nbsp;
<b class="nc"><i class="no-highlight">2104</i>&nbsp;        if (keepGoing &amp;&amp; prevBin != null) {</b>
<b class="nc"><i class="no-highlight">2105</i>&nbsp;            prevBin.latch();</b>
<b class="nc"><i class="no-highlight">2106</i>&nbsp;            visitor.visitBIN(prevBin);</b>
<b class="nc"><i class="no-highlight">2107</i>&nbsp;            prevBin.releaseLatch();</b>
<i class="no-highlight">2108</i>&nbsp;        }
<i class="no-highlight">2109</i>&nbsp;
<b class="nc"><i class="no-highlight">2110</i>&nbsp;        return keepGoing;</b>
<i class="no-highlight">2111</i>&nbsp;    }
<i class="no-highlight">2112</i>&nbsp;
<i class="no-highlight">2113</i>&nbsp;    /**
<i class="no-highlight">2114</i>&nbsp;     * Pads the given array with zeros on the left, and returns an array of
<i class="no-highlight">2115</i>&nbsp;     * the given size.
<i class="no-highlight">2116</i>&nbsp;     */
<i class="no-highlight">2117</i>&nbsp;    private byte[] padLeft(byte[] data, int size) {
<b class="nc"><i class="no-highlight">2118</i>&nbsp;        assert data.length &lt;= size;</b>
<b class="nc"><i class="no-highlight">2119</i>&nbsp;        if (data.length == size) {</b>
<b class="nc"><i class="no-highlight">2120</i>&nbsp;            return data;</b>
<i class="no-highlight">2121</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2122</i>&nbsp;        final byte[] b = new byte[size];</b>
<b class="nc"><i class="no-highlight">2123</i>&nbsp;        System.arraycopy(data, 0, b, size - data.length, data.length);</b>
<b class="nc"><i class="no-highlight">2124</i>&nbsp;        return b;</b>
<i class="no-highlight">2125</i>&nbsp;    }
<i class="no-highlight">2126</i>&nbsp;
<i class="no-highlight">2127</i>&nbsp;    /**
<i class="no-highlight">2128</i>&nbsp;     * Preloads the database.
<i class="no-highlight">2129</i>&nbsp;     */
<i class="no-highlight">2130</i>&nbsp;    private PreloadStatus preloadRecords(final PrintStream out,
<i class="no-highlight">2131</i>&nbsp;                                         final Database db,
<i class="no-highlight">2132</i>&nbsp;                                         final boolean loadLNs) {
<b class="nc"><i class="no-highlight">2133</i>&nbsp;        Thread thread = null;</b>
<b class="nc"><i class="no-highlight">2134</i>&nbsp;        if (out != null) {</b>
<b class="nc"><i class="no-highlight">2135</i>&nbsp;            thread = new Thread() {</b>
<i class="no-highlight">2136</i>&nbsp;                @Override
<i class="no-highlight">2137</i>&nbsp;                public void run() {
<i class="no-highlight">2138</i>&nbsp;                    while (true) {
<i class="no-highlight">2139</i>&nbsp;                        try {
<b class="nc"><i class="no-highlight">2140</i>&nbsp;                            out.print(&quot;.&quot;);</b>
<b class="nc"><i class="no-highlight">2141</i>&nbsp;                            out.flush();</b>
<b class="nc"><i class="no-highlight">2142</i>&nbsp;                            Thread.sleep(5 * 1000);</b>
<b class="nc"><i class="no-highlight">2143</i>&nbsp;                        } catch (InterruptedException e) {</b>
<b class="nc"><i class="no-highlight">2144</i>&nbsp;                            break;</b>
<b class="nc"><i class="no-highlight">2145</i>&nbsp;                        }</b>
<i class="no-highlight">2146</i>&nbsp;                    }
<i class="no-highlight">2147</i>&nbsp;                }
<i class="no-highlight">2148</i>&nbsp;            };
<b class="nc"><i class="no-highlight">2149</i>&nbsp;            thread.start();</b>
<i class="no-highlight">2150</i>&nbsp;        }
<i class="no-highlight">2151</i>&nbsp;        final PreloadStats stats;
<i class="no-highlight">2152</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">2153</i>&nbsp;            stats = db.preload(new PreloadConfig().setLoadLNs(loadLNs));</b>
<i class="no-highlight">2154</i>&nbsp;        } finally {
<b class="nc"><i class="no-highlight">2155</i>&nbsp;            if (thread != null) {</b>
<b class="nc"><i class="no-highlight">2156</i>&nbsp;                thread.interrupt();</b>
<i class="no-highlight">2157</i>&nbsp;            }
<b class="nc"><i class="no-highlight">2158</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2159</i>&nbsp;        if (thread != null) {</b>
<i class="no-highlight">2160</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">2161</i>&nbsp;                thread.join();</b>
<b class="nc"><i class="no-highlight">2162</i>&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc"><i class="no-highlight">2163</i>&nbsp;                throw new RuntimeExceptionWrapper(e);</b>
<b class="nc"><i class="no-highlight">2164</i>&nbsp;            }</b>
<i class="no-highlight">2165</i>&nbsp;        }
<i class="no-highlight">2166</i>&nbsp;
<i class="no-highlight">2167</i>&nbsp;        /*
<i class="no-highlight">2168</i>&nbsp;         * When preloading with an off-heap cache, the main cache will overflow
<i class="no-highlight">2169</i>&nbsp;         * a little by design. We evict here to bring it down below the
<i class="no-highlight">2170</i>&nbsp;         * maximum, and clear the stats so that the getStats method in this
<i class="no-highlight">2171</i>&nbsp;         * class doesn&#39;t complain about the eviction later on.
<i class="no-highlight">2172</i>&nbsp;         */
<b class="nc"><i class="no-highlight">2173</i>&nbsp;        final Environment env = db.getEnvironment();</b>
<b class="nc"><i class="no-highlight">2174</i>&nbsp;        if (offHeapCache) {</b>
<b class="nc"><i class="no-highlight">2175</i>&nbsp;            env.evictMemory();</b>
<b class="nc"><i class="no-highlight">2176</i>&nbsp;            env.getStats(StatsConfig.CLEAR);</b>
<i class="no-highlight">2177</i>&nbsp;        }
<i class="no-highlight">2178</i>&nbsp;
<b class="nc"><i class="no-highlight">2179</i>&nbsp;        return stats.getStatus();</b>
<i class="no-highlight">2180</i>&nbsp;    }
<i class="no-highlight">2181</i>&nbsp;
<i class="no-highlight">2182</i>&nbsp;    /**
<i class="no-highlight">2183</i>&nbsp;     * Returns the Btree size, and prints a few other stats for testing.
<i class="no-highlight">2184</i>&nbsp;     */
<i class="no-highlight">2185</i>&nbsp;    private long getStats(final PrintStream out,
<i class="no-highlight">2186</i>&nbsp;                          final Environment env,
<i class="no-highlight">2187</i>&nbsp;                          final String msg) {
<b class="nc"><i class="no-highlight">2188</i>&nbsp;        if (out != null) {</b>
<b class="nc"><i class="no-highlight">2189</i>&nbsp;            out.println();</b>
<b class="nc"><i class="no-highlight">2190</i>&nbsp;            out.println(msg + &#39;:&#39;);</b>
<i class="no-highlight">2191</i>&nbsp;        }
<i class="no-highlight">2192</i>&nbsp;
<b class="nc"><i class="no-highlight">2193</i>&nbsp;        final EnvironmentStats stats = env.getStats(null);</b>
<i class="no-highlight">2194</i>&nbsp;
<b class="nc"><i class="no-highlight">2195</i>&nbsp;        final long dataSize = getMainDataSize(env);</b>
<i class="no-highlight">2196</i>&nbsp;
<b class="nc"><i class="no-highlight">2197</i>&nbsp;        if (out != null) {</b>
<b class="nc"><i class="no-highlight">2198</i>&nbsp;            out.println(</b>
<b class="nc"><i class="no-highlight">2199</i>&nbsp;                &quot;MainCache= &quot; + INT_FORMAT.format(stats.getCacheTotalBytes()) +</b>
<b class="nc"><i class="no-highlight">2200</i>&nbsp;                &quot; Data= &quot; + INT_FORMAT.format(dataSize)  +</b>
<b class="nc"><i class="no-highlight">2201</i>&nbsp;                &quot; BINs= &quot; + INT_FORMAT.format(stats.getNCachedBINs()) +</b>
<b class="nc"><i class="no-highlight">2202</i>&nbsp;                &quot; UINs= &quot; + INT_FORMAT.format(stats.getNCachedUpperINs()) +</b>
<b class="nc"><i class="no-highlight">2203</i>&nbsp;                &quot; CacheMiss= &quot; + INT_FORMAT.format(stats.getNCacheMiss()) +</b>
<i class="no-highlight">2204</i>&nbsp;                &quot; OffHeapCache= &quot; +
<b class="nc"><i class="no-highlight">2205</i>&nbsp;                INT_FORMAT.format(stats.getOffHeapTotalBytes()) +</b>
<b class="nc"><i class="no-highlight">2206</i>&nbsp;                &quot; OhLNs= &quot; + INT_FORMAT.format(stats.getOffHeapCachedLNs()) +</b>
<b class="nc"><i class="no-highlight">2207</i>&nbsp;                &quot; OhBIN= &quot; + INT_FORMAT.format(stats.getOffHeapCachedBINs()) +</b>
<i class="no-highlight">2208</i>&nbsp;                &quot; OhBINDeltas= &quot; +
<b class="nc"><i class="no-highlight">2209</i>&nbsp;                INT_FORMAT.format(stats.getOffHeapCachedBINDeltas()));</b>
<i class="no-highlight">2210</i>&nbsp;        }
<i class="no-highlight">2211</i>&nbsp;
<b class="nc"><i class="no-highlight">2212</i>&nbsp;        if (stats.getNNodesTargeted() &gt; 0) {</b>
<b class="nc"><i class="no-highlight">2213</i>&nbsp;            throw new IllegalStateException(</b>
<i class="no-highlight">2214</i>&nbsp;                &quot;*** All records did not fit in the cache ***&quot;);
<i class="no-highlight">2215</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2216</i>&nbsp;        if (stats.getOffHeapNodesTargeted() &gt; 0) {</b>
<b class="nc"><i class="no-highlight">2217</i>&nbsp;            throw new IllegalStateException(</b>
<i class="no-highlight">2218</i>&nbsp;                &quot;*** All records did not fit in the off-heap cache ***&quot;);
<i class="no-highlight">2219</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2220</i>&nbsp;        return dataSize;</b>
<i class="no-highlight">2221</i>&nbsp;    }
<i class="no-highlight">2222</i>&nbsp;}
</div>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
        var codeBlock = document.getElementById('sourceCode');

        if (codeBlock) {
            hljs.highlightBlock(codeBlock);
        }
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2021-04-19 13:44</div>
</div>
</body>
</html>
