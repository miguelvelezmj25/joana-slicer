


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > IN</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
    @import "../../.css/highlight-idea.css";
  </style>
  <script type="text/javascript" src="../../.js/highlight.pack.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.sleepycat.je.tree</a>
</div>

<h1>Coverage Summary for Class: IN (com.sleepycat.je.tree)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">IN</td>
<td class="coverageStat">
  <span class="percent">
    66.4%
  </span>
  <span class="absValue">
    (180/271)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52.2%
  </span>
  <span class="absValue">
    (1107/2121)
  </span>
</td>
</tr>
  <tr>
    <td class="name">IN$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    66.5%
  </span>
  <span class="absValue">
    (181/272)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52.2%
  </span>
  <span class="absValue">
    (1108/2122)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<div class="sourceCode" id="sourceCode"><i class="no-highlight">1</i>&nbsp;/*-
<i class="no-highlight">2</i>&nbsp; * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.
<i class="no-highlight">3</i>&nbsp; *
<i class="no-highlight">4</i>&nbsp; * This file was distributed by Oracle as part of a version of Oracle Berkeley
<i class="no-highlight">5</i>&nbsp; * DB Java Edition made available at:
<i class="no-highlight">6</i>&nbsp; *
<i class="no-highlight">7</i>&nbsp; * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html
<i class="no-highlight">8</i>&nbsp; *
<i class="no-highlight">9</i>&nbsp; * Please see the LICENSE file included in the top-level directory of the
<i class="no-highlight">10</i>&nbsp; * appropriate version of Oracle Berkeley DB Java Edition for a copy of the
<i class="no-highlight">11</i>&nbsp; * license and additional information.
<i class="no-highlight">12</i>&nbsp; */
<i class="no-highlight">13</i>&nbsp;
<i class="no-highlight">14</i>&nbsp;package com.sleepycat.je.tree;
<i class="no-highlight">15</i>&nbsp;
<i class="no-highlight">16</i>&nbsp;import static com.sleepycat.je.EnvironmentFailureException.unexpectedState;
<i class="no-highlight">17</i>&nbsp;
<i class="no-highlight">18</i>&nbsp;import java.io.FileNotFoundException;
<i class="no-highlight">19</i>&nbsp;import java.nio.ByteBuffer;
<i class="no-highlight">20</i>&nbsp;import java.util.Arrays;
<i class="no-highlight">21</i>&nbsp;import java.util.Comparator;
<i class="no-highlight">22</i>&nbsp;import java.util.concurrent.atomic.AtomicLong;
<i class="no-highlight">23</i>&nbsp;import java.util.logging.Level;
<i class="no-highlight">24</i>&nbsp;import java.util.logging.Logger;
<i class="no-highlight">25</i>&nbsp;
<i class="no-highlight">26</i>&nbsp;import com.sleepycat.je.CacheMode;
<i class="no-highlight">27</i>&nbsp;import com.sleepycat.je.DatabaseException;
<i class="no-highlight">28</i>&nbsp;import com.sleepycat.je.EnvironmentFailureException;
<i class="no-highlight">29</i>&nbsp;import com.sleepycat.je.cleaner.PackedObsoleteInfo;
<i class="no-highlight">30</i>&nbsp;import com.sleepycat.je.dbi.DatabaseId;
<i class="no-highlight">31</i>&nbsp;import com.sleepycat.je.dbi.DatabaseImpl;
<i class="no-highlight">32</i>&nbsp;import com.sleepycat.je.dbi.DbTree;
<i class="no-highlight">33</i>&nbsp;import com.sleepycat.je.dbi.EnvironmentFailureReason;
<i class="no-highlight">34</i>&nbsp;import com.sleepycat.je.dbi.EnvironmentImpl;
<i class="no-highlight">35</i>&nbsp;import com.sleepycat.je.dbi.INList;
<i class="no-highlight">36</i>&nbsp;import com.sleepycat.je.dbi.MemoryBudget;
<i class="no-highlight">37</i>&nbsp;import com.sleepycat.je.dbi.TTL;
<i class="no-highlight">38</i>&nbsp;import com.sleepycat.je.evictor.Evictor;
<i class="no-highlight">39</i>&nbsp;import com.sleepycat.je.evictor.OffHeapCache;
<i class="no-highlight">40</i>&nbsp;import com.sleepycat.je.latch.LatchContext;
<i class="no-highlight">41</i>&nbsp;import com.sleepycat.je.latch.LatchFactory;
<i class="no-highlight">42</i>&nbsp;import com.sleepycat.je.latch.LatchSupport;
<i class="no-highlight">43</i>&nbsp;import com.sleepycat.je.latch.LatchTable;
<i class="no-highlight">44</i>&nbsp;import com.sleepycat.je.latch.SharedLatch;
<i class="no-highlight">45</i>&nbsp;import com.sleepycat.je.log.LogEntryType;
<i class="no-highlight">46</i>&nbsp;import com.sleepycat.je.log.LogItem;
<i class="no-highlight">47</i>&nbsp;import com.sleepycat.je.log.LogParams;
<i class="no-highlight">48</i>&nbsp;import com.sleepycat.je.log.LogUtils;
<i class="no-highlight">49</i>&nbsp;import com.sleepycat.je.log.Loggable;
<i class="no-highlight">50</i>&nbsp;import com.sleepycat.je.log.Provisional;
<i class="no-highlight">51</i>&nbsp;import com.sleepycat.je.log.ReplicationContext;
<i class="no-highlight">52</i>&nbsp;import com.sleepycat.je.log.WholeEntry;
<i class="no-highlight">53</i>&nbsp;import com.sleepycat.je.log.entry.BINDeltaLogEntry;
<i class="no-highlight">54</i>&nbsp;import com.sleepycat.je.log.entry.INLogEntry;
<i class="no-highlight">55</i>&nbsp;import com.sleepycat.je.log.entry.LNLogEntry;
<i class="no-highlight">56</i>&nbsp;import com.sleepycat.je.log.entry.LogEntry;
<i class="no-highlight">57</i>&nbsp;import com.sleepycat.je.tree.dupConvert.DBIN;
<i class="no-highlight">58</i>&nbsp;import com.sleepycat.je.tree.dupConvert.DIN;
<i class="no-highlight">59</i>&nbsp;import com.sleepycat.je.tree.dupConvert.DupConvert;
<i class="no-highlight">60</i>&nbsp;import com.sleepycat.je.utilint.DbLsn;
<i class="no-highlight">61</i>&nbsp;import com.sleepycat.je.utilint.LoggerUtils;
<i class="no-highlight">62</i>&nbsp;import com.sleepycat.je.utilint.SizeofMarker;
<i class="no-highlight">63</i>&nbsp;import com.sleepycat.je.utilint.TestHook;
<i class="no-highlight">64</i>&nbsp;import com.sleepycat.je.utilint.TestHookExecute;
<i class="no-highlight">65</i>&nbsp;import com.sleepycat.je.utilint.VLSN;
<i class="no-highlight">66</i>&nbsp;
<i class="no-highlight">67</i>&nbsp;/**
<i class="no-highlight">68</i>&nbsp; * An IN represents an Internal Node in the JE tree.
<i class="no-highlight">69</i>&nbsp; *
<i class="no-highlight">70</i>&nbsp; * Explanation of KD (KnownDeleted) and PD (PendingDelete) entry flags
<i class="no-highlight">71</i>&nbsp; * ===================================================================
<i class="no-highlight">72</i>&nbsp; *
<i class="no-highlight">73</i>&nbsp; * PD: set for all LN entries that are deleted, even before the LN is
<i class="no-highlight">74</i>&nbsp; * committed.  Is used as an authoritative (transactionally correct) indication
<i class="no-highlight">75</i>&nbsp; * that an LN is deleted. PD will be cleared if the txn for the deleted LN is
<i class="no-highlight">76</i>&nbsp; * aborted.
<i class="no-highlight">77</i>&nbsp; *
<i class="no-highlight">78</i>&nbsp; * KD: set under special conditions for entries containing LNs which are known
<i class="no-highlight">79</i>&nbsp; * to be obsolete.  Not used for entries in an active/uncommitted transaction.
<i class="no-highlight">80</i>&nbsp; *
<i class="no-highlight">81</i>&nbsp; * First notice that IN.fetchLN will allow a FileNotFoundException when the
<i class="no-highlight">82</i>&nbsp; * PD or KD flag is set on the entry.  And it will allow a NULL_LSN when the KD
<i class="no-highlight">83</i>&nbsp; * flag is set.
<i class="no-highlight">84</i>&nbsp; *
<i class="no-highlight">85</i>&nbsp; * KD was implemented first, and was originally used when the cleaner attempts
<i class="no-highlight">86</i>&nbsp; * to migrate an LN and discovers it is deleted (see Cleaner.migrateLN). We
<i class="no-highlight">87</i>&nbsp; * need KD because the INCompressor may not have run, and may not have
<i class="no-highlight">88</i>&nbsp; * compressed the BIN. There&#39;s the danger that we&#39;ll try to fetch that entry,
<i class="no-highlight">89</i>&nbsp; * and that the file was deleted by the cleaner.
<i class="no-highlight">90</i>&nbsp; *
<i class="no-highlight">91</i>&nbsp; * KD was used more recently when an unexpected exception occurs while logging
<i class="no-highlight">92</i>&nbsp; * an LN, after inserting the entry.  Rather than delete the entry to clean up,
<i class="no-highlight">93</i>&nbsp; * we mark the entry KD so it won&#39;t cause a fetch error later.  In this case
<i class="no-highlight">94</i>&nbsp; * the entry LSN is NULL_LSN. See Tree.insertNewSlot.
<i class="no-highlight">95</i>&nbsp; *
<i class="no-highlight">96</i>&nbsp; * PD is closely related to the first use of KD above (for cleaned deleted LNs)
<i class="no-highlight">97</i>&nbsp; * and came about because of a cleaner optimization we make. The cleaner
<i class="no-highlight">98</i>&nbsp; * considers all deleted LN log entries to be obsolete, without doing a tree
<i class="no-highlight">99</i>&nbsp; * lookup, and without any record of an obsolete offset.  This makes the cost
<i class="no-highlight">100</i>&nbsp; * of cleaning of deleted LNs very low.  For example, if the log looks like
<i class="no-highlight">101</i>&nbsp; * this:
<i class="no-highlight">102</i>&nbsp; *
<i class="no-highlight">103</i>&nbsp; * 100  LNA
<i class="no-highlight">104</i>&nbsp; * 200  delete of LNA
<i class="no-highlight">105</i>&nbsp; *
<i class="no-highlight">106</i>&nbsp; * then LSN 200 will be considered obsolete when this file is processed by the
<i class="no-highlight">107</i>&nbsp; * cleaner. After all, only two things can happen: (1) the txn commits, and we
<i class="no-highlight">108</i>&nbsp; * don&#39;t need LSN 200, because we can wipe this LN out of the tree, or (2) the
<i class="no-highlight">109</i>&nbsp; * txn aborts, and we don&#39;t need LSN 200, because we are going to revert to LSN
<i class="no-highlight">110</i>&nbsp; * 100/LNA.
<i class="no-highlight">111</i>&nbsp; *
<i class="no-highlight">112</i>&nbsp; * We set PD for the entry of a deleted LN at the time of the operation, and we
<i class="no-highlight">113</i>&nbsp; * clear PD if the transaction aborts.  There is no real danger that this log
<i class="no-highlight">114</i>&nbsp; * entry will be processed by the cleaner before it&#39;s committed, because
<i class="no-highlight">115</i>&nbsp; * cleaning can only happen after the first active LSN.
<i class="no-highlight">116</i>&nbsp; *
<i class="no-highlight">117</i>&nbsp; * Just as in the first use of KD above, setting PD is necessary to avoid a
<i class="no-highlight">118</i>&nbsp; * fetch error, when the file is deleted by the cleaner but the entry
<i class="no-highlight">119</i>&nbsp; * containing the deleted LN has not been deleted by the INCompressor.
<i class="no-highlight">120</i>&nbsp; *
<i class="no-highlight">121</i>&nbsp; * PD is also set in replication rollback, when LNs are marked as
<i class="no-highlight">122</i>&nbsp; * invisible.
<i class="no-highlight">123</i>&nbsp; *
<i class="no-highlight">124</i>&nbsp; * When LSN locking was implemented (see CursorImpl.lockLN), the PD flag took
<i class="no-highlight">125</i>&nbsp; * on additional meaning.  PD is used to determine whether an LN is deleted
<i class="no-highlight">126</i>&nbsp; * without fetching it, and therefore is relied on to be transactionally
<i class="no-highlight">127</i>&nbsp; * correct.
<i class="no-highlight">128</i>&nbsp; *
<i class="no-highlight">129</i>&nbsp; * In addition to the setting and use of the KD/PD flags described above, the
<i class="no-highlight">130</i>&nbsp; * situation is complicated by the fact that we must restore the state of these
<i class="no-highlight">131</i>&nbsp; * flags during abort, recovery, and set them properly during slot reuse.
<i class="no-highlight">132</i>&nbsp; *
<i class="no-highlight">133</i>&nbsp; * We have been meaning to consider whether PD and KD can be consolidated into
<i class="no-highlight">134</i>&nbsp; * one flag: simply the Deleted flag.  The Deleted flag would be set in the
<i class="no-highlight">135</i>&nbsp; * same way as PD is currently set, as well as the second use of KD described
<i class="no-highlight">136</i>&nbsp; * above (when the LSN is NULL_LSN after an insertion error).  The use of KD
<i class="no-highlight">137</i>&nbsp; * and PD for invisible entries and recovery rollback should also be
<i class="no-highlight">138</i>&nbsp; * considered.
<i class="no-highlight">139</i>&nbsp; *
<i class="no-highlight">140</i>&nbsp; * If we consolidate the two flags and set the Deleted flag during a delete
<i class="no-highlight">141</i>&nbsp; * operation (like PD), we&#39;ll have to remove optimizations (in CursorImpl for
<i class="no-highlight">142</i>&nbsp; * example) that consider a slot deleted when KD is set.  Since KD is rarely
<i class="no-highlight">143</i>&nbsp; * set currently, this shouldn&#39;t have a noticeable performance impact.
<i class="no-highlight">144</i>&nbsp; */
<b class="fc"><i class="no-highlight">145</i>&nbsp;public class IN extends Node implements Comparable&lt;IN&gt;, LatchContext {</b>
<i class="no-highlight">146</i>&nbsp;
<b class="fc"><i class="no-highlight">147</i>&nbsp;    public static AtomicLong COUNT_FIND = new AtomicLong(0);</b>
<b class="fc"><i class="no-highlight">148</i>&nbsp;    public static AtomicLong COUNT_SERIALIZE = new AtomicLong(0);</b>
<i class="no-highlight">149</i>&nbsp;
<i class="no-highlight">150</i>&nbsp;    private static final String BEGIN_TAG = &quot;&lt;in&gt;&quot;;
<i class="no-highlight">151</i>&nbsp;    private static final String END_TAG = &quot;&lt;/in&gt;&quot;;
<i class="no-highlight">152</i>&nbsp;    private static final String TRACE_SPLIT = &quot;Split:&quot;;
<i class="no-highlight">153</i>&nbsp;    private static final String TRACE_DELETE = &quot;Delete:&quot;;
<i class="no-highlight">154</i>&nbsp;
<i class="no-highlight">155</i>&nbsp;    private static final int BYTES_PER_LSN_ENTRY = 4;
<i class="no-highlight">156</i>&nbsp;    public static final int MAX_FILE_OFFSET = 0xfffffe;
<i class="no-highlight">157</i>&nbsp;    private static final int THREE_BYTE_NEGATIVE_ONE = 0xffffff;
<i class="no-highlight">158</i>&nbsp;
<i class="no-highlight">159</i>&nbsp;    /**
<i class="no-highlight">160</i>&nbsp;     * Used as the &quot;empty rep&quot; for the INLongRep offHeapBINIds field.
<i class="no-highlight">161</i>&nbsp;     *
<i class="no-highlight">162</i>&nbsp;     * minLength is 3 because BIN IDs are LRU list indexes. Initially 100k
<i class="no-highlight">163</i>&nbsp;     * indexes are allocated and the largest values are used first.
<i class="no-highlight">164</i>&nbsp;     *
<i class="no-highlight">165</i>&nbsp;     * allowSparseRep is true because some workloads will only load BIN IDs for
<i class="no-highlight">166</i>&nbsp;     * a subset of the BINs in the IN.
<i class="no-highlight">167</i>&nbsp;     */
<b class="fc"><i class="no-highlight">168</i>&nbsp;    private static final INLongRep.EmptyRep EMPTY_OFFHEAP_BIN_IDS =</b>
<i class="no-highlight">169</i>&nbsp;        new INLongRep.EmptyRep(3, true);
<i class="no-highlight">170</i>&nbsp;
<i class="no-highlight">171</i>&nbsp;    /*
<i class="no-highlight">172</i>&nbsp;     * Levels:
<i class="no-highlight">173</i>&nbsp;     * The mapping tree has levels in the 0x20000 -&gt; 0x2ffff number space.
<i class="no-highlight">174</i>&nbsp;     * The main tree has levels in the 0x10000 -&gt; 0x1ffff number space.
<i class="no-highlight">175</i>&nbsp;     * The duplicate tree levels are in 0-&gt; 0xffff number space.
<i class="no-highlight">176</i>&nbsp;     */
<i class="no-highlight">177</i>&nbsp;    public static final int DBMAP_LEVEL = 0x20000;
<i class="no-highlight">178</i>&nbsp;    public static final int MAIN_LEVEL = 0x10000;
<i class="no-highlight">179</i>&nbsp;    public static final int LEVEL_MASK = 0x0ffff;
<i class="no-highlight">180</i>&nbsp;    public static final int MIN_LEVEL = -1;
<i class="no-highlight">181</i>&nbsp;    public static final int BIN_LEVEL = MAIN_LEVEL | 1;
<i class="no-highlight">182</i>&nbsp;
<i class="no-highlight">183</i>&nbsp;    /* Used to indicate that an exact match was found in findEntry. */
<i class="no-highlight">184</i>&nbsp;    public static final int EXACT_MATCH = (1 &lt;&lt; 16);
<i class="no-highlight">185</i>&nbsp;
<i class="no-highlight">186</i>&nbsp;    /* Used to indicate that an insert was successful. */
<i class="no-highlight">187</i>&nbsp;    public static final int INSERT_SUCCESS = (1 &lt;&lt; 17);
<i class="no-highlight">188</i>&nbsp;
<i class="no-highlight">189</i>&nbsp;    /*
<i class="no-highlight">190</i>&nbsp;     * A bit flag set in the return value of partialEviction() to indicate
<i class="no-highlight">191</i>&nbsp;     * whether the IN is evictable or not.
<i class="no-highlight">192</i>&nbsp;     */
<i class="no-highlight">193</i>&nbsp;    public static final long NON_EVICTABLE_IN = (1L &lt;&lt; 62);
<i class="no-highlight">194</i>&nbsp;
<i class="no-highlight">195</i>&nbsp;    /*
<i class="no-highlight">196</i>&nbsp;     * Boolean properties of an IN, encoded as bits inside the flags
<i class="no-highlight">197</i>&nbsp;     * data member.
<i class="no-highlight">198</i>&nbsp;     */
<i class="no-highlight">199</i>&nbsp;    private static final int IN_DIRTY_BIT = 0x1;
<i class="no-highlight">200</i>&nbsp;    private static final int IN_RECALC_TOGGLE_BIT = 0x2;
<i class="no-highlight">201</i>&nbsp;    private static final int IN_IS_ROOT_BIT = 0x4;
<i class="no-highlight">202</i>&nbsp;    private static final int IN_HAS_CACHED_CHILDREN_BIT = 0x8;
<i class="no-highlight">203</i>&nbsp;    private static final int IN_PRI2_LRU_BIT = 0x10;
<i class="no-highlight">204</i>&nbsp;    private static final int IN_DELTA_BIT = 0x20;
<i class="no-highlight">205</i>&nbsp;    private static final int IN_FETCHED_COLD_BIT = 0x40;
<i class="no-highlight">206</i>&nbsp;    private static final int IN_FETCHED_COLD_OFFHEAP_BIT = 0x80;
<i class="no-highlight">207</i>&nbsp;    private static final int IN_RESIDENT_BIT = 0x100;
<i class="no-highlight">208</i>&nbsp;    private static final int IN_PROHIBIT_NEXT_DELTA_BIT = 0x200;
<i class="no-highlight">209</i>&nbsp;    private static final int IN_EXPIRATION_IN_HOURS = 0x400;
<i class="no-highlight">210</i>&nbsp;
<i class="no-highlight">211</i>&nbsp;    /* Tracing for LRU-related ops */
<i class="no-highlight">212</i>&nbsp;    private static final boolean traceLRU = false;
<i class="no-highlight">213</i>&nbsp;    private static final boolean traceDeltas = false;
<b class="fc"><i class="no-highlight">214</i>&nbsp;    private static final Level traceLevel = Level.INFO;</b>
<i class="no-highlight">215</i>&nbsp;
<i class="no-highlight">216</i>&nbsp;    DatabaseImpl databaseImpl;
<i class="no-highlight">217</i>&nbsp;
<i class="no-highlight">218</i>&nbsp;    private int level;
<i class="no-highlight">219</i>&nbsp;
<i class="no-highlight">220</i>&nbsp;    /* The unique id of this node. */
<i class="no-highlight">221</i>&nbsp;    long nodeId;
<i class="no-highlight">222</i>&nbsp;
<i class="no-highlight">223</i>&nbsp;    /* Some bits are persistent and some are not, see serialize. */
<i class="no-highlight">224</i>&nbsp;    int flags;
<i class="no-highlight">225</i>&nbsp;
<i class="no-highlight">226</i>&nbsp;    /*
<i class="no-highlight">227</i>&nbsp;     * The identifier key is a key that can be used used to search for this IN.
<i class="no-highlight">228</i>&nbsp;     * Initially it is the key of the zeroth slot, but insertions prior to slot
<i class="no-highlight">229</i>&nbsp;     * zero make this no longer true.  It is always equal to some key in the
<i class="no-highlight">230</i>&nbsp;     * IN, and therefore it is changed by BIN.compress when removing slots.
<i class="no-highlight">231</i>&nbsp;     */
<i class="no-highlight">232</i>&nbsp;    private byte[] identifierKey;
<i class="no-highlight">233</i>&nbsp;
<i class="no-highlight">234</i>&nbsp;    int nEntries;
<i class="no-highlight">235</i>&nbsp;
<i class="no-highlight">236</i>&nbsp;    byte[] entryStates;
<i class="no-highlight">237</i>&nbsp;
<i class="no-highlight">238</i>&nbsp;    /*
<i class="no-highlight">239</i>&nbsp;     * entryKeys contains the keys in their entirety if key prefixing is not
<i class="no-highlight">240</i>&nbsp;     * being used. If prefixing is enabled, then keyPrefix contains the prefix
<i class="no-highlight">241</i>&nbsp;     * and entryKeys contains the suffixes. Records with small enough data
<i class="no-highlight">242</i>&nbsp;     * (smaller than the value je.tree.maxEmbeddedLN param) are stored in
<i class="no-highlight">243</i>&nbsp;     * their entirity (both key (or key suffix) and data) inside BINs. This is
<i class="no-highlight">244</i>&nbsp;     * done by combining the record key and data as a two-part key (see the
<i class="no-highlight">245</i>&nbsp;     * dbi/DupKeyData class) and storing the resulting array in entryKeys.
<i class="no-highlight">246</i>&nbsp;     * A special case is when the record to be embedded has no data. Then,
<i class="no-highlight">247</i>&nbsp;     * the two-part key format is not used, but instead the NO_DATA_LN_BIT
<i class="no-highlight">248</i>&nbsp;     * is turned on in the slot&#39;s state. This saves the space overhead of
<i class="no-highlight">249</i>&nbsp;     * using the two-part key format.
<i class="no-highlight">250</i>&nbsp;     */
<i class="no-highlight">251</i>&nbsp;    INKeyRep entryKeys;
<i class="no-highlight">252</i>&nbsp;    byte[] keyPrefix;
<i class="no-highlight">253</i>&nbsp;
<i class="no-highlight">254</i>&nbsp;    /*
<i class="no-highlight">255</i>&nbsp;     * The following entryLsnXXX fields are used for storing LSNs.  There are
<i class="no-highlight">256</i>&nbsp;     * two possible representations: a byte array based rep, and a long array
<i class="no-highlight">257</i>&nbsp;     * based one.  For compactness, the byte array rep is used initially.  A
<i class="no-highlight">258</i>&nbsp;     * single byte[] that uses four bytes per LSN is used. The baseFileNumber
<i class="no-highlight">259</i>&nbsp;     * field contains the lowest file number of any LSN in the array.  Then for
<i class="no-highlight">260</i>&nbsp;     * each entry (four bytes each), the first byte contains the offset from
<i class="no-highlight">261</i>&nbsp;     * the baseFileNumber of that LSN&#39;s file number.  The remaining three bytes
<i class="no-highlight">262</i>&nbsp;     * contain the file offset portion of the LSN.  Three bytes will hold a
<i class="no-highlight">263</i>&nbsp;     * maximum offset of 16,777,214 (0xfffffe), so with the default JE log file
<i class="no-highlight">264</i>&nbsp;     * size of 10,000,000 bytes this works well.
<i class="no-highlight">265</i>&nbsp;     *
<i class="no-highlight">266</i>&nbsp;     * If either (1) the difference in file numbers exceeds 127
<i class="no-highlight">267</i>&nbsp;     * (Byte.MAX_VALUE) or (2) the file offset is greater than 16,777,214, then
<i class="no-highlight">268</i>&nbsp;     * the byte[] based rep mutates to a long[] based rep.
<i class="no-highlight">269</i>&nbsp;     *
<i class="no-highlight">270</i>&nbsp;     * In the byte[] rep, DbLsn.NULL_LSN is represented by setting the file
<i class="no-highlight">271</i>&nbsp;     * offset bytes for a given entry to -1 (0xffffff).
<i class="no-highlight">272</i>&nbsp;     *
<i class="no-highlight">273</i>&nbsp;     * Note: A compact representation will be changed to the non-compact one,
<i class="no-highlight">274</i>&nbsp;     * if needed, but in the current implementation, the reverse mutation
<i class="no-highlight">275</i>&nbsp;     * (from long to compact) never takes place.
<i class="no-highlight">276</i>&nbsp;     */
<i class="no-highlight">277</i>&nbsp;    long baseFileNumber;
<i class="no-highlight">278</i>&nbsp;    byte[] entryLsnByteArray;
<i class="no-highlight">279</i>&nbsp;    long[] entryLsnLongArray;
<i class="no-highlight">280</i>&nbsp;    public static boolean disableCompactLsns; // DbCacheSize only
<i class="no-highlight">281</i>&nbsp;
<i class="no-highlight">282</i>&nbsp;    /*
<i class="no-highlight">283</i>&nbsp;     * The children of this IN. Only the ones that are actually in the cache
<i class="no-highlight">284</i>&nbsp;     * have non-null entries. Specialized sparse array represents are used to
<i class="no-highlight">285</i>&nbsp;     * represent the entries. The representation can mutate as modifications
<i class="no-highlight">286</i>&nbsp;     * are made to it.
<i class="no-highlight">287</i>&nbsp;     */
<i class="no-highlight">288</i>&nbsp;    INTargetRep entryTargets;
<i class="no-highlight">289</i>&nbsp;
<i class="no-highlight">290</i>&nbsp;    /*
<i class="no-highlight">291</i>&nbsp;     * In a level 2 IN, the LRU IDs of the child BINs.
<i class="no-highlight">292</i>&nbsp;     */
<b class="fc"><i class="no-highlight">293</i>&nbsp;    private INLongRep offHeapBINIds = EMPTY_OFFHEAP_BIN_IDS;</b>
<i class="no-highlight">294</i>&nbsp;
<i class="no-highlight">295</i>&nbsp;    long inMemorySize;
<i class="no-highlight">296</i>&nbsp;
<i class="no-highlight">297</i>&nbsp;    /*
<i class="no-highlight">298</i>&nbsp;     * accumluted memory budget delta.  Once this exceeds
<i class="no-highlight">299</i>&nbsp;     * MemoryBudget.ACCUMULATED_LIMIT we inform the MemoryBudget that a change
<i class="no-highlight">300</i>&nbsp;     * has occurred.  See SR 12273.
<i class="no-highlight">301</i>&nbsp;     */
<b class="fc"><i class="no-highlight">302</i>&nbsp;    private int accumulatedDelta = 0;</b>
<i class="no-highlight">303</i>&nbsp;
<i class="no-highlight">304</i>&nbsp;    /*
<i class="no-highlight">305</i>&nbsp;     * Max allowable accumulation of memory budget changes before MemoryBudget
<i class="no-highlight">306</i>&nbsp;     * should be updated. This allows for consolidating multiple calls to
<i class="no-highlight">307</i>&nbsp;     * updateXXXMemoryBudget() into one call.  Not declared final so that the
<i class="no-highlight">308</i>&nbsp;     * unit tests can modify it.  See SR 12273.
<i class="no-highlight">309</i>&nbsp;     */
<i class="no-highlight">310</i>&nbsp;    public static final int ACCUMULATED_LIMIT_DEFAULT = 1000;
<b class="fc"><i class="no-highlight">311</i>&nbsp;    public static int ACCUMULATED_LIMIT = ACCUMULATED_LIMIT_DEFAULT;</b>
<i class="no-highlight">312</i>&nbsp;
<i class="no-highlight">313</i>&nbsp;    /**
<i class="no-highlight">314</i>&nbsp;     * References to the next and previous nodes in an LRU list. If the node
<i class="no-highlight">315</i>&nbsp;     * is not in any LRUList, both of these will be null. If the node is at
<i class="no-highlight">316</i>&nbsp;     * the front/back of an LRUList, prevLRUNode/nextLRUNode will point to
<i class="no-highlight">317</i>&nbsp;     * the node itself.
<i class="no-highlight">318</i>&nbsp;     */
<b class="fc"><i class="no-highlight">319</i>&nbsp;    private IN nextLRUNode = null;</b>
<b class="fc"><i class="no-highlight">320</i>&nbsp;    private IN prevLRUNode = null;</b>
<i class="no-highlight">321</i>&nbsp;
<i class="no-highlight">322</i>&nbsp;    /*
<i class="no-highlight">323</i>&nbsp;     * Let L be the most recently written logrec for this IN instance.
<i class="no-highlight">324</i>&nbsp;     * (a) If this is a UIN, lastFullVersion is the lsn of L.
<i class="no-highlight">325</i>&nbsp;     * (b) If this is a BIN instance and L is a full-version logrec,
<i class="no-highlight">326</i>&nbsp;     *     lastFullVersion is the lsn of L.
<i class="no-highlight">327</i>&nbsp;     * (c) If this is a BIN instance and L is a delta logrec, lastFullVersion
<i class="no-highlight">328</i>&nbsp;     *     is the lsn of the most recently written full-version logrec for the
<i class="no-highlight">329</i>&nbsp;     *     same BIN.
<i class="no-highlight">330</i>&nbsp;     *
<i class="no-highlight">331</i>&nbsp;     * It is set in 2 cases:
<i class="no-highlight">332</i>&nbsp;     *
<i class="no-highlight">333</i>&nbsp;     * (a) after &quot;this&quot; is created via reading a logrec L, lastFullVersion is
<i class="no-highlight">334</i>&nbsp;     * set to L&#39;s lsn, if L is a UIN or a full BIN. (this is done in
<i class="no-highlight">335</i>&nbsp;     * IN.postFetch/RecoveryInit(), via IN.setLastLoggedLsn()). If L is a BIN
<i class="no-highlight">336</i>&nbsp;     * delta, lastFullVersion is set by BINDeltaLogEntry.readEntry() to
<i class="no-highlight">337</i>&nbsp;     * L.prevFullLsn.
<i class="no-highlight">338</i>&nbsp;     *
<i class="no-highlight">339</i>&nbsp;     * (b) After logging a UIN or a full-BIN logrec, it is set to the LSN of
<i class="no-highlight">340</i>&nbsp;     * the logrec written. This is done in IN.afterLog().
<i class="no-highlight">341</i>&nbsp;     *
<i class="no-highlight">342</i>&nbsp;     * Notice that this is a persistent field, but except from case (c), when
<i class="no-highlight">343</i>&nbsp;     * reading a logrec L, it is set not to the value found in L, but to the
<i class="no-highlight">344</i>&nbsp;     * lsn of L. This is why its read/write is managed by the INLogEntry class
<i class="no-highlight">345</i>&nbsp;     * rather than the IN readFromLog/writeFromLog methods.
<i class="no-highlight">346</i>&nbsp;     */
<b class="fc"><i class="no-highlight">347</i>&nbsp;    long lastFullVersion = DbLsn.NULL_LSN;</b>
<i class="no-highlight">348</i>&nbsp;
<i class="no-highlight">349</i>&nbsp;    /*
<i class="no-highlight">350</i>&nbsp;     * BINs have a lastDeltaVersion data field as well, which is defined as
<i class="no-highlight">351</i>&nbsp;     * follows:
<i class="no-highlight">352</i>&nbsp;     *
<i class="no-highlight">353</i>&nbsp;     * Let L be the most recently written logrec for this BIN instance. If
<i class="no-highlight">354</i>&nbsp;     * L is a full-version logrec, lastDeltaVersion is NULL; otherwise it
<i class="no-highlight">355</i>&nbsp;     * is the lsn of L.
<i class="no-highlight">356</i>&nbsp;     *
<i class="no-highlight">357</i>&nbsp;     * It is used for obsolete tracking.
<i class="no-highlight">358</i>&nbsp;     *
<i class="no-highlight">359</i>&nbsp;     * It is set in 2 cases:
<i class="no-highlight">360</i>&nbsp;     *
<i class="no-highlight">361</i>&nbsp;     * (a) after &quot;this&quot; is created via reading a logrec L, lastDeltaVersion
<i class="no-highlight">362</i>&nbsp;     * is set to L&#39;s lsn, if L is a BIN-delta logrec, or to NULL if L is a
<i class="no-highlight">363</i>&nbsp;     * full-BIN logrec (this is done in IN.postFetch/RecoveryInit(), via
<i class="no-highlight">364</i>&nbsp;     * BIN.setLastLoggedLsn()).
<i class="no-highlight">365</i>&nbsp;     *
<i class="no-highlight">366</i>&nbsp;     * (b) After we write a logrec L for this BIN instance, lastDeltaVersion
<i class="no-highlight">367</i>&nbsp;     * is set to NULL if L is a full-BIN logrec, or to L&#39;s lsn, if L is a
<i class="no-highlight">368</i>&nbsp;     * BIN-delta logrec (this is done in BIN.afterLog()).
<i class="no-highlight">369</i>&nbsp;     *
<i class="no-highlight">370</i>&nbsp;     * Notice that this is a persistent field, but when reading a logrec L,
<i class="no-highlight">371</i>&nbsp;     * it is set not to the value found in L, but to the lsn of L. This is why
<i class="no-highlight">372</i>&nbsp;     * its read/write is managed by the INLogEntry class rather than the IN
<i class="no-highlight">373</i>&nbsp;     * readFromLog/writeFromLog methods.
<i class="no-highlight">374</i>&nbsp;     *
<i class="no-highlight">375</i>&nbsp;     * private long lastDeltaVersion = DbLsn.NULL_LSN;
<i class="no-highlight">376</i>&nbsp;     */
<i class="no-highlight">377</i>&nbsp;
<i class="no-highlight">378</i>&nbsp;
<i class="no-highlight">379</i>&nbsp;    /*
<i class="no-highlight">380</i>&nbsp;     * A sequence of obsolete info that cannot be counted as obsolete until an
<i class="no-highlight">381</i>&nbsp;     * ancestor IN is logged non-provisionally.
<i class="no-highlight">382</i>&nbsp;     */
<i class="no-highlight">383</i>&nbsp;    private PackedObsoleteInfo provisionalObsolete;
<i class="no-highlight">384</i>&nbsp;
<i class="no-highlight">385</i>&nbsp;    /* See convertDupKeys. */
<i class="no-highlight">386</i>&nbsp;    private boolean needDupKeyConversion;
<i class="no-highlight">387</i>&nbsp;
<b class="fc"><i class="no-highlight">388</i>&nbsp;    private int pinCount = 0;</b>
<i class="no-highlight">389</i>&nbsp;
<i class="no-highlight">390</i>&nbsp;    private SharedLatch latch;
<i class="no-highlight">391</i>&nbsp;
<i class="no-highlight">392</i>&nbsp;    private IN parent;
<i class="no-highlight">393</i>&nbsp;
<i class="no-highlight">394</i>&nbsp;    private TestHook fetchINHook;
<i class="no-highlight">395</i>&nbsp;
<i class="no-highlight">396</i>&nbsp;    /**
<i class="no-highlight">397</i>&nbsp;     * Create an empty IN, with no node ID, to be filled in from the log.
<i class="no-highlight">398</i>&nbsp;     */
<b class="fc"><i class="no-highlight">399</i>&nbsp;    public IN() {</b>
<b class="fc"><i class="no-highlight">400</i>&nbsp;        init(null, Key.EMPTY_KEY, 0, 0);</b>
<b class="fc"><i class="no-highlight">401</i>&nbsp;    }</b>
<i class="no-highlight">402</i>&nbsp;
<i class="no-highlight">403</i>&nbsp;    /**
<i class="no-highlight">404</i>&nbsp;     * Create a new IN.
<i class="no-highlight">405</i>&nbsp;     */
<i class="no-highlight">406</i>&nbsp;    public IN(
<i class="no-highlight">407</i>&nbsp;        DatabaseImpl dbImpl,
<i class="no-highlight">408</i>&nbsp;        byte[] identifierKey,
<i class="no-highlight">409</i>&nbsp;        int capacity,
<b class="fc"><i class="no-highlight">410</i>&nbsp;        int level) {</b>
<i class="no-highlight">411</i>&nbsp;
<b class="fc"><i class="no-highlight">412</i>&nbsp;        nodeId = dbImpl.getEnv().getNodeSequence().getNextLocalNodeId();</b>
<i class="no-highlight">413</i>&nbsp;
<b class="fc"><i class="no-highlight">414</i>&nbsp;        init(dbImpl, identifierKey, capacity,</b>
<b class="fc"><i class="no-highlight">415</i>&nbsp;            generateLevel(dbImpl.getId(), level));</b>
<i class="no-highlight">416</i>&nbsp;
<b class="fc"><i class="no-highlight">417</i>&nbsp;        initMemorySize();</b>
<b class="fc"><i class="no-highlight">418</i>&nbsp;    }</b>
<i class="no-highlight">419</i>&nbsp;
<i class="no-highlight">420</i>&nbsp;    /**
<i class="no-highlight">421</i>&nbsp;     * For Sizeof.
<i class="no-highlight">422</i>&nbsp;     */
<b class="nc"><i class="no-highlight">423</i>&nbsp;    public IN(@SuppressWarnings(&quot;unused&quot;) SizeofMarker marker) {</b>
<i class="no-highlight">424</i>&nbsp;
<i class="no-highlight">425</i>&nbsp;        /*
<i class="no-highlight">426</i>&nbsp;         * Set all variable fields to null, since they are not part of the
<i class="no-highlight">427</i>&nbsp;         * fixed overhead.
<i class="no-highlight">428</i>&nbsp;         */
<b class="nc"><i class="no-highlight">429</i>&nbsp;        entryTargets = null;</b>
<b class="nc"><i class="no-highlight">430</i>&nbsp;        entryKeys = null;</b>
<b class="nc"><i class="no-highlight">431</i>&nbsp;        keyPrefix = null;</b>
<b class="nc"><i class="no-highlight">432</i>&nbsp;        entryLsnByteArray = null;</b>
<b class="nc"><i class="no-highlight">433</i>&nbsp;        entryLsnLongArray = null;</b>
<b class="nc"><i class="no-highlight">434</i>&nbsp;        entryStates = null;</b>
<i class="no-highlight">435</i>&nbsp;
<b class="nc"><i class="no-highlight">436</i>&nbsp;        latch = LatchFactory.createSharedLatch(</b>
<b class="nc"><i class="no-highlight">437</i>&nbsp;            LatchSupport.DUMMY_LATCH_CONTEXT, isAlwaysLatchedExclusively());</b>
<i class="no-highlight">438</i>&nbsp;
<i class="no-highlight">439</i>&nbsp;        /*
<i class="no-highlight">440</i>&nbsp;         * Use the latch to force it to grow to &quot;runtime size&quot;.
<i class="no-highlight">441</i>&nbsp;         */
<b class="nc"><i class="no-highlight">442</i>&nbsp;        latch.acquireExclusive();</b>
<b class="nc"><i class="no-highlight">443</i>&nbsp;        latch.release();</b>
<b class="nc"><i class="no-highlight">444</i>&nbsp;        latch.acquireExclusive();</b>
<b class="nc"><i class="no-highlight">445</i>&nbsp;        latch.release();</b>
<b class="nc"><i class="no-highlight">446</i>&nbsp;    }</b>
<i class="no-highlight">447</i>&nbsp;
<i class="no-highlight">448</i>&nbsp;    /**
<i class="no-highlight">449</i>&nbsp;     * Create a new IN.  Need this because we can&#39;t call newInstance() without
<i class="no-highlight">450</i>&nbsp;     * getting a 0 for nodeId.
<i class="no-highlight">451</i>&nbsp;     */
<i class="no-highlight">452</i>&nbsp;    IN createNewInstance(
<i class="no-highlight">453</i>&nbsp;        byte[] identifierKey,
<i class="no-highlight">454</i>&nbsp;        int maxEntries,
<i class="no-highlight">455</i>&nbsp;        int level) {
<b class="fc"><i class="no-highlight">456</i>&nbsp;        return new IN(databaseImpl, identifierKey, maxEntries, level);</b>
<i class="no-highlight">457</i>&nbsp;    }
<i class="no-highlight">458</i>&nbsp;
<i class="no-highlight">459</i>&nbsp;    /**
<i class="no-highlight">460</i>&nbsp;     * Initialize IN object.
<i class="no-highlight">461</i>&nbsp;     */
<i class="no-highlight">462</i>&nbsp;    protected void init(
<i class="no-highlight">463</i>&nbsp;        DatabaseImpl db,
<i class="no-highlight">464</i>&nbsp;        @SuppressWarnings(&quot;hiding&quot;)
<i class="no-highlight">465</i>&nbsp;        byte[] identifierKey,
<i class="no-highlight">466</i>&nbsp;        int initialCapacity,
<i class="no-highlight">467</i>&nbsp;        @SuppressWarnings(&quot;hiding&quot;)
<i class="no-highlight">468</i>&nbsp;        int level) {
<i class="no-highlight">469</i>&nbsp;
<b class="fc"><i class="no-highlight">470</i>&nbsp;        setDatabase(db);</b>
<b class="fc"><i class="no-highlight">471</i>&nbsp;        latch = LatchFactory.createSharedLatch(</b>
<b class="fc"><i class="no-highlight">472</i>&nbsp;            this, isAlwaysLatchedExclusively());</b>
<b class="fc"><i class="no-highlight">473</i>&nbsp;        flags = 0;</b>
<b class="fc"><i class="no-highlight">474</i>&nbsp;        nEntries = 0;</b>
<b class="fc"><i class="no-highlight">475</i>&nbsp;        this.identifierKey = identifierKey;</b>
<b class="fc"><i class="no-highlight">476</i>&nbsp;        entryTargets = INTargetRep.NONE;</b>
<b class="fc"><i class="no-highlight">477</i>&nbsp;        entryKeys = new INKeyRep.Default(initialCapacity);</b>
<b class="fc"><i class="no-highlight">478</i>&nbsp;        keyPrefix = null;</b>
<b class="fc"><i class="no-highlight">479</i>&nbsp;        baseFileNumber = -1;</b>
<i class="no-highlight">480</i>&nbsp;
<i class="no-highlight">481</i>&nbsp;        /*
<i class="no-highlight">482</i>&nbsp;         * Normally we start out with the compact LSN rep and then mutate to
<i class="no-highlight">483</i>&nbsp;         * the long rep when needed.  But for some purposes (DbCacheSize) we
<i class="no-highlight">484</i>&nbsp;         * start out with the long rep and never use the compact rep.
<i class="no-highlight">485</i>&nbsp;         */
<b class="fc"><i class="no-highlight">486</i>&nbsp;        if (disableCompactLsns) {</b>
<b class="nc"><i class="no-highlight">487</i>&nbsp;            entryLsnByteArray = null;</b>
<b class="nc"><i class="no-highlight">488</i>&nbsp;            entryLsnLongArray = new long[initialCapacity];</b>
<i class="no-highlight">489</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">490</i>&nbsp;            entryLsnByteArray = new byte[initialCapacity &lt;&lt; 2];</b>
<b class="fc"><i class="no-highlight">491</i>&nbsp;            entryLsnLongArray = null;</b>
<i class="no-highlight">492</i>&nbsp;        }
<i class="no-highlight">493</i>&nbsp;
<b class="fc"><i class="no-highlight">494</i>&nbsp;        entryStates = new byte[initialCapacity];</b>
<b class="fc"><i class="no-highlight">495</i>&nbsp;        this.level = level;</b>
<b class="fc"><i class="no-highlight">496</i>&nbsp;    }</b>
<i class="no-highlight">497</i>&nbsp;
<i class="no-highlight">498</i>&nbsp;    @Override
<i class="no-highlight">499</i>&nbsp;    public final boolean isIN() {
<b class="fc"><i class="no-highlight">500</i>&nbsp;        return true;</b>
<i class="no-highlight">501</i>&nbsp;    }
<i class="no-highlight">502</i>&nbsp;
<i class="no-highlight">503</i>&nbsp;    @Override
<i class="no-highlight">504</i>&nbsp;    public final boolean isUpperIN() {
<b class="fc"><i class="no-highlight">505</i>&nbsp;        return !isBIN();</b>
<i class="no-highlight">506</i>&nbsp;    }
<i class="no-highlight">507</i>&nbsp;
<i class="no-highlight">508</i>&nbsp;    @Override
<i class="no-highlight">509</i>&nbsp;    public final String getLatchName() {
<b class="nc"><i class="no-highlight">510</i>&nbsp;        return shortClassName() + getNodeId();</b>
<i class="no-highlight">511</i>&nbsp;    }
<i class="no-highlight">512</i>&nbsp;
<i class="no-highlight">513</i>&nbsp;    @Override
<i class="no-highlight">514</i>&nbsp;    public final int getLatchTimeoutMs() {
<b class="fc"><i class="no-highlight">515</i>&nbsp;        return databaseImpl.getEnv().getLatchTimeoutMs();</b>
<i class="no-highlight">516</i>&nbsp;    }
<i class="no-highlight">517</i>&nbsp;
<i class="no-highlight">518</i>&nbsp;    @Override
<i class="no-highlight">519</i>&nbsp;    public final LatchTable getLatchTable() {
<b class="nc"><i class="no-highlight">520</i>&nbsp;        return LatchSupport.btreeLatchTable;</b>
<i class="no-highlight">521</i>&nbsp;    }
<i class="no-highlight">522</i>&nbsp;
<i class="no-highlight">523</i>&nbsp;    /*
<i class="no-highlight">524</i>&nbsp;     * Return whether the shared latch for this kind of node should be of the
<i class="no-highlight">525</i>&nbsp;     * &quot;always exclusive&quot; variety.  Presently, only IN&#39;s are actually latched
<i class="no-highlight">526</i>&nbsp;     * shared.  BINs are latched exclusive only.
<i class="no-highlight">527</i>&nbsp;     */
<i class="no-highlight">528</i>&nbsp;    boolean isAlwaysLatchedExclusively() {
<b class="fc"><i class="no-highlight">529</i>&nbsp;        return false;</b>
<i class="no-highlight">530</i>&nbsp;    }
<i class="no-highlight">531</i>&nbsp;
<i class="no-highlight">532</i>&nbsp;    /**
<i class="no-highlight">533</i>&nbsp;     * Latch this node if it is not latched by another thread. Update the LRU
<i class="no-highlight">534</i>&nbsp;     * using the given cacheMode if the latch succeeds.
<i class="no-highlight">535</i>&nbsp;     */
<i class="no-highlight">536</i>&nbsp;    public final boolean latchNoWait(CacheMode cacheMode) {
<b class="nc"><i class="no-highlight">537</i>&nbsp;        if (!latch.acquireExclusiveNoWait()) {</b>
<b class="nc"><i class="no-highlight">538</i>&nbsp;            return false;</b>
<i class="no-highlight">539</i>&nbsp;        }
<b class="nc"><i class="no-highlight">540</i>&nbsp;        updateLRU(cacheMode);</b>
<b class="nc"><i class="no-highlight">541</i>&nbsp;        return true;</b>
<i class="no-highlight">542</i>&nbsp;    }
<i class="no-highlight">543</i>&nbsp;
<i class="no-highlight">544</i>&nbsp;    /**
<i class="no-highlight">545</i>&nbsp;     * Latch this node exclusive and update the LRU using the given cacheMode.
<i class="no-highlight">546</i>&nbsp;     */
<i class="no-highlight">547</i>&nbsp;    public void latch(CacheMode cacheMode) {
<b class="fc"><i class="no-highlight">548</i>&nbsp;        latch.acquireExclusive();</b>
<b class="fc"><i class="no-highlight">549</i>&nbsp;        updateLRU(cacheMode);</b>
<b class="fc"><i class="no-highlight">550</i>&nbsp;    }</b>
<i class="no-highlight">551</i>&nbsp;
<i class="no-highlight">552</i>&nbsp;    /**
<i class="no-highlight">553</i>&nbsp;     * Latch this node exclusive and update the LRU using the default cacheMode.
<i class="no-highlight">554</i>&nbsp;     */
<i class="no-highlight">555</i>&nbsp;    public final void latch() {
<b class="nc"><i class="no-highlight">556</i>&nbsp;        latch(CacheMode.DEFAULT);</b>
<b class="nc"><i class="no-highlight">557</i>&nbsp;    }</b>
<i class="no-highlight">558</i>&nbsp;
<i class="no-highlight">559</i>&nbsp;    /**
<i class="no-highlight">560</i>&nbsp;     * Latch this node shared and update the LRU using the given cacheMode.
<i class="no-highlight">561</i>&nbsp;     */
<i class="no-highlight">562</i>&nbsp;    @Override
<i class="no-highlight">563</i>&nbsp;    public void latchShared(CacheMode cacheMode) {
<b class="fc"><i class="no-highlight">564</i>&nbsp;        latch.acquireShared();</b>
<b class="fc"><i class="no-highlight">565</i>&nbsp;        updateLRU(cacheMode);</b>
<b class="fc"><i class="no-highlight">566</i>&nbsp;    }</b>
<i class="no-highlight">567</i>&nbsp;
<i class="no-highlight">568</i>&nbsp;    /**
<i class="no-highlight">569</i>&nbsp;     * Latch this node shared and update the LRU using the default cacheMode.
<i class="no-highlight">570</i>&nbsp;     */
<i class="no-highlight">571</i>&nbsp;    @Override
<i class="no-highlight">572</i>&nbsp;    public final void latchShared() {
<b class="nc"><i class="no-highlight">573</i>&nbsp;        latchShared(CacheMode.DEFAULT);</b>
<b class="nc"><i class="no-highlight">574</i>&nbsp;    }</b>
<i class="no-highlight">575</i>&nbsp;
<i class="no-highlight">576</i>&nbsp;    /**
<i class="no-highlight">577</i>&nbsp;     * Latch this node exclusive and do not update the LRU or cause other
<i class="no-highlight">578</i>&nbsp;     * related side effects.
<i class="no-highlight">579</i>&nbsp;     *
<i class="no-highlight">580</i>&nbsp;     * @param db is passed in order to initialize the database for an
<i class="no-highlight">581</i>&nbsp;     * uninitialized node, which is necessary in order to latch it.
<i class="no-highlight">582</i>&nbsp;     */
<i class="no-highlight">583</i>&nbsp;    public final void latchNoUpdateLRU(DatabaseImpl db) {
<b class="fc"><i class="no-highlight">584</i>&nbsp;        if (databaseImpl == null) {</b>
<b class="fc"><i class="no-highlight">585</i>&nbsp;            databaseImpl = db;</b>
<i class="no-highlight">586</i>&nbsp;        }
<b class="fc"><i class="no-highlight">587</i>&nbsp;        latch.acquireExclusive();</b>
<b class="fc"><i class="no-highlight">588</i>&nbsp;    }</b>
<i class="no-highlight">589</i>&nbsp;
<i class="no-highlight">590</i>&nbsp;    /**
<i class="no-highlight">591</i>&nbsp;     * Latch this node exclusive and do not update the LRU or cause other
<i class="no-highlight">592</i>&nbsp;     * related side effects.
<i class="no-highlight">593</i>&nbsp;     */
<i class="no-highlight">594</i>&nbsp;    public final void latchNoUpdateLRU() {
<b class="fc"><i class="no-highlight">595</i>&nbsp;        assert databaseImpl != null;</b>
<b class="fc"><i class="no-highlight">596</i>&nbsp;        latch.acquireExclusive();</b>
<b class="fc"><i class="no-highlight">597</i>&nbsp;    }</b>
<i class="no-highlight">598</i>&nbsp;
<i class="no-highlight">599</i>&nbsp;    /**
<i class="no-highlight">600</i>&nbsp;     * Release the latch on this node.
<i class="no-highlight">601</i>&nbsp;     */
<i class="no-highlight">602</i>&nbsp;    @Override
<i class="no-highlight">603</i>&nbsp;    public final void releaseLatch() {
<b class="fc"><i class="no-highlight">604</i>&nbsp;        latch.release();</b>
<b class="fc"><i class="no-highlight">605</i>&nbsp;    }</b>
<i class="no-highlight">606</i>&nbsp;
<i class="no-highlight">607</i>&nbsp;    /**
<i class="no-highlight">608</i>&nbsp;     * Release the latch on this node if it is owned.
<i class="no-highlight">609</i>&nbsp;     */
<i class="no-highlight">610</i>&nbsp;    public final void releaseLatchIfOwner() {
<b class="fc"><i class="no-highlight">611</i>&nbsp;        latch.releaseIfOwner();</b>
<b class="fc"><i class="no-highlight">612</i>&nbsp;    }</b>
<i class="no-highlight">613</i>&nbsp;
<i class="no-highlight">614</i>&nbsp;    /**
<i class="no-highlight">615</i>&nbsp;     * @return true if this thread holds the IN&#39;s latch
<i class="no-highlight">616</i>&nbsp;     */
<i class="no-highlight">617</i>&nbsp;    public final boolean isLatchOwner() {
<b class="fc"><i class="no-highlight">618</i>&nbsp;        return latch.isOwner();</b>
<i class="no-highlight">619</i>&nbsp;    }
<i class="no-highlight">620</i>&nbsp;
<i class="no-highlight">621</i>&nbsp;    public final boolean isLatchExclusiveOwner() {
<b class="fc"><i class="no-highlight">622</i>&nbsp;        return latch.isExclusiveOwner();</b>
<i class="no-highlight">623</i>&nbsp;    }
<i class="no-highlight">624</i>&nbsp;
<i class="no-highlight">625</i>&nbsp;    /* For unit testing. */
<i class="no-highlight">626</i>&nbsp;    public final int getLatchNWaiters() {
<b class="nc"><i class="no-highlight">627</i>&nbsp;        return latch.getNWaiters();</b>
<i class="no-highlight">628</i>&nbsp;    }
<i class="no-highlight">629</i>&nbsp;
<i class="no-highlight">630</i>&nbsp;    public final void updateLRU(CacheMode cacheMode) {
<i class="no-highlight">631</i>&nbsp;
<b class="fc"><i class="no-highlight">632</i>&nbsp;        if (!getInListResident()) {</b>
<b class="fc"><i class="no-highlight">633</i>&nbsp;            return;</b>
<i class="no-highlight">634</i>&nbsp;        }
<i class="no-highlight">635</i>&nbsp;
<b class="fc"><i class="no-highlight">636</i>&nbsp;        switch (cacheMode) {</b>
<i class="no-highlight">637</i>&nbsp;        case UNCHANGED:
<i class="no-highlight">638</i>&nbsp;        case MAKE_COLD:
<b class="fc"><i class="no-highlight">639</i>&nbsp;            break;</b>
<i class="no-highlight">640</i>&nbsp;        case DEFAULT:
<i class="no-highlight">641</i>&nbsp;        case EVICT_LN:
<i class="no-highlight">642</i>&nbsp;        case EVICT_BIN:
<i class="no-highlight">643</i>&nbsp;        case KEEP_HOT:
<b class="fc"><i class="no-highlight">644</i>&nbsp;            setFetchedCold(false);</b>
<b class="fc"><i class="no-highlight">645</i>&nbsp;            setFetchedColdOffHeap(false);</b>
<i class="no-highlight">646</i>&nbsp;
<b class="fc"><i class="no-highlight">647</i>&nbsp;            if (isBIN() || !hasCachedChildrenFlag()) {</b>
<b class="fc"><i class="no-highlight">648</i>&nbsp;                assert(isBIN() || !hasCachedChildren());</b>
<b class="fc"><i class="no-highlight">649</i>&nbsp;                getEvictor().moveBack(this);</b>
<i class="no-highlight">650</i>&nbsp;            }
<i class="no-highlight">651</i>&nbsp;            break;
<i class="no-highlight">652</i>&nbsp;        default:
<b class="nc"><i class="no-highlight">653</i>&nbsp;            assert false;</b>
<i class="no-highlight">654</i>&nbsp;        }
<b class="fc"><i class="no-highlight">655</i>&nbsp;    }</b>
<i class="no-highlight">656</i>&nbsp;
<i class="no-highlight">657</i>&nbsp;    /**
<i class="no-highlight">658</i>&nbsp;     * This method should be used carefully. Unless this node and the parent
<i class="no-highlight">659</i>&nbsp;     * are already known to be latched, call latchParent instead to access the
<i class="no-highlight">660</i>&nbsp;     * parent safely.
<i class="no-highlight">661</i>&nbsp;     */
<i class="no-highlight">662</i>&nbsp;    public IN getParent() {
<b class="fc"><i class="no-highlight">663</i>&nbsp;        return parent;</b>
<i class="no-highlight">664</i>&nbsp;    }
<i class="no-highlight">665</i>&nbsp;
<i class="no-highlight">666</i>&nbsp;    public void setParent(IN in) {
<b class="fc"><i class="no-highlight">667</i>&nbsp;        assert in != null;</b>
<i class="no-highlight">668</i>&nbsp;
<i class="no-highlight">669</i>&nbsp;        /*
<i class="no-highlight">670</i>&nbsp;         * Must hold EX-latch when changing a non-null parent. But when setting
<i class="no-highlight">671</i>&nbsp;         * the parent initially (it is currently null), we assume it is being
<i class="no-highlight">672</i>&nbsp;         * attached and no other threads have access to it.
<i class="no-highlight">673</i>&nbsp;         */
<b class="fc"><i class="no-highlight">674</i>&nbsp;        if (parent != null &amp;&amp; !isLatchExclusiveOwner()) {</b>
<b class="nc"><i class="no-highlight">675</i>&nbsp;            throw unexpectedState();</b>
<i class="no-highlight">676</i>&nbsp;        }
<i class="no-highlight">677</i>&nbsp;
<b class="fc"><i class="no-highlight">678</i>&nbsp;        parent = in;</b>
<b class="fc"><i class="no-highlight">679</i>&nbsp;    }</b>
<i class="no-highlight">680</i>&nbsp;
<i class="no-highlight">681</i>&nbsp;    /**
<i class="no-highlight">682</i>&nbsp;     * Latches the parent exclusively, leaving this node latched. The parent
<i class="no-highlight">683</i>&nbsp;     * must not already be latched.
<i class="no-highlight">684</i>&nbsp;     *
<i class="no-highlight">685</i>&nbsp;     * This node must be latched on entry and will be latched on exit. This
<i class="no-highlight">686</i>&nbsp;     * node&#39;s latch may be released temporarily, in which case it will be
<i class="no-highlight">687</i>&nbsp;     * ex-latched (since the parent is ex-latched, this isn&#39;t a drawback).
<i class="no-highlight">688</i>&nbsp;     *
<i class="no-highlight">689</i>&nbsp;     * Does not perform cache mode processing, since this node is already
<i class="no-highlight">690</i>&nbsp;     * latched.
<i class="no-highlight">691</i>&nbsp;     *
<i class="no-highlight">692</i>&nbsp;     * @return the ex-latched parent, for which calling getKnownChildIndex with
<i class="no-highlight">693</i>&nbsp;     * this node is guaranteed to succeed.
<i class="no-highlight">694</i>&nbsp;     *
<i class="no-highlight">695</i>&nbsp;     * @throws EnvironmentFailureException (fatal) if the parent latch is
<i class="no-highlight">696</i>&nbsp;     * already held.
<i class="no-highlight">697</i>&nbsp;     */
<i class="no-highlight">698</i>&nbsp;    public final IN latchParent() {
<i class="no-highlight">699</i>&nbsp;
<b class="nc"><i class="no-highlight">700</i>&nbsp;        assert latch.isOwner();</b>
<b class="nc"><i class="no-highlight">701</i>&nbsp;        assert !isRoot();</b>
<b class="nc"><i class="no-highlight">702</i>&nbsp;        assert getParent() != null;</b>
<i class="no-highlight">703</i>&nbsp;
<i class="no-highlight">704</i>&nbsp;        while (true) {
<b class="nc"><i class="no-highlight">705</i>&nbsp;            final IN p = getParent();</b>
<i class="no-highlight">706</i>&nbsp;
<b class="nc"><i class="no-highlight">707</i>&nbsp;            if (p.latch.acquireExclusiveNoWait()) {</b>
<b class="nc"><i class="no-highlight">708</i>&nbsp;                return p;</b>
<i class="no-highlight">709</i>&nbsp;            }
<i class="no-highlight">710</i>&nbsp;
<b class="nc"><i class="no-highlight">711</i>&nbsp;            pin();</b>
<i class="no-highlight">712</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">713</i>&nbsp;                latch.release();</b>
<b class="nc"><i class="no-highlight">714</i>&nbsp;                p.latch.acquireExclusive();</b>
<b class="nc"><i class="no-highlight">715</i>&nbsp;                latch.acquireExclusive();</b>
<i class="no-highlight">716</i>&nbsp;            } finally {
<b class="nc"><i class="no-highlight">717</i>&nbsp;                unpin();</b>
<b class="nc"><i class="no-highlight">718</i>&nbsp;            }</b>
<i class="no-highlight">719</i>&nbsp;
<b class="nc"><i class="no-highlight">720</i>&nbsp;            if (getParent() == p) {</b>
<b class="nc"><i class="no-highlight">721</i>&nbsp;                return p;</b>
<i class="no-highlight">722</i>&nbsp;            }
<i class="no-highlight">723</i>&nbsp;
<b class="nc"><i class="no-highlight">724</i>&nbsp;            p.latch.release();</b>
<b class="nc"><i class="no-highlight">725</i>&nbsp;        }</b>
<i class="no-highlight">726</i>&nbsp;    }
<i class="no-highlight">727</i>&nbsp;
<i class="no-highlight">728</i>&nbsp;    /**
<i class="no-highlight">729</i>&nbsp;     * Returns the index of the given child. Should only be called when the
<i class="no-highlight">730</i>&nbsp;     * caller knows that the given child is resident.
<i class="no-highlight">731</i>&nbsp;     */
<i class="no-highlight">732</i>&nbsp;    public int getKnownChildIndex(final Node child) {
<i class="no-highlight">733</i>&nbsp;
<b class="nc"><i class="no-highlight">734</i>&nbsp;        for (int i = 0; i &lt; nEntries; i += 1) {</b>
<b class="nc"><i class="no-highlight">735</i>&nbsp;            if (getTarget(i) == child) {</b>
<b class="nc"><i class="no-highlight">736</i>&nbsp;                return i;</b>
<i class="no-highlight">737</i>&nbsp;            }
<i class="no-highlight">738</i>&nbsp;        }
<i class="no-highlight">739</i>&nbsp;
<b class="nc"><i class="no-highlight">740</i>&nbsp;        throw unexpectedState();</b>
<i class="no-highlight">741</i>&nbsp;    }
<i class="no-highlight">742</i>&nbsp;
<i class="no-highlight">743</i>&nbsp;    public final synchronized void pin() {
<b class="fc"><i class="no-highlight">744</i>&nbsp;        assert(isLatchOwner());</b>
<b class="fc"><i class="no-highlight">745</i>&nbsp;        assert(pinCount &gt;= 0);</b>
<b class="fc"><i class="no-highlight">746</i>&nbsp;        ++pinCount;</b>
<b class="fc"><i class="no-highlight">747</i>&nbsp;    }</b>
<i class="no-highlight">748</i>&nbsp;
<i class="no-highlight">749</i>&nbsp;    public final synchronized void unpin() {
<b class="fc"><i class="no-highlight">750</i>&nbsp;        assert(pinCount &gt; 0);</b>
<b class="fc"><i class="no-highlight">751</i>&nbsp;        --pinCount;</b>
<b class="fc"><i class="no-highlight">752</i>&nbsp;    }</b>
<i class="no-highlight">753</i>&nbsp;
<i class="no-highlight">754</i>&nbsp;    public final synchronized boolean isPinned() {
<b class="fc"><i class="no-highlight">755</i>&nbsp;        assert(isLatchExclusiveOwner());</b>
<b class="fc"><i class="no-highlight">756</i>&nbsp;        assert(pinCount &gt;= 0);</b>
<b class="fc"><i class="no-highlight">757</i>&nbsp;        return pinCount &gt; 0;</b>
<i class="no-highlight">758</i>&nbsp;    }
<i class="no-highlight">759</i>&nbsp;
<i class="no-highlight">760</i>&nbsp;    /**
<i class="no-highlight">761</i>&nbsp;     * Get the database for this IN.
<i class="no-highlight">762</i>&nbsp;     */
<i class="no-highlight">763</i>&nbsp;    public final DatabaseImpl getDatabase() {
<b class="fc"><i class="no-highlight">764</i>&nbsp;        return databaseImpl;</b>
<i class="no-highlight">765</i>&nbsp;    }
<i class="no-highlight">766</i>&nbsp;
<i class="no-highlight">767</i>&nbsp;    /**
<i class="no-highlight">768</i>&nbsp;     * Set the database reference for this node.
<i class="no-highlight">769</i>&nbsp;     */
<i class="no-highlight">770</i>&nbsp;    public final void setDatabase(DatabaseImpl db) {
<b class="fc"><i class="no-highlight">771</i>&nbsp;        databaseImpl = db;</b>
<b class="fc"><i class="no-highlight">772</i>&nbsp;    }</b>
<i class="no-highlight">773</i>&nbsp;
<i class="no-highlight">774</i>&nbsp;    /*
<i class="no-highlight">775</i>&nbsp;     * Get the database id for this node.
<i class="no-highlight">776</i>&nbsp;     */
<i class="no-highlight">777</i>&nbsp;    public final DatabaseId getDatabaseId() {
<b class="nc"><i class="no-highlight">778</i>&nbsp;        return databaseImpl.getId();</b>
<i class="no-highlight">779</i>&nbsp;    }
<i class="no-highlight">780</i>&nbsp;
<i class="no-highlight">781</i>&nbsp;    @Override
<i class="no-highlight">782</i>&nbsp;    public final EnvironmentImpl getEnvImplForFatalException() {
<b class="nc"><i class="no-highlight">783</i>&nbsp;        return databaseImpl.getEnv();</b>
<i class="no-highlight">784</i>&nbsp;    }
<i class="no-highlight">785</i>&nbsp;
<i class="no-highlight">786</i>&nbsp;    public final EnvironmentImpl getEnv() {
<b class="fc"><i class="no-highlight">787</i>&nbsp;        return databaseImpl.getEnv();</b>
<i class="no-highlight">788</i>&nbsp;    }
<i class="no-highlight">789</i>&nbsp;
<i class="no-highlight">790</i>&nbsp;    final Evictor getEvictor() {
<b class="fc"><i class="no-highlight">791</i>&nbsp;        return databaseImpl.getEnv().getEvictor();</b>
<i class="no-highlight">792</i>&nbsp;    }
<i class="no-highlight">793</i>&nbsp;
<i class="no-highlight">794</i>&nbsp;    final OffHeapCache getOffHeapCache() {
<b class="fc"><i class="no-highlight">795</i>&nbsp;        return databaseImpl.getEnv().getOffHeapCache();</b>
<i class="no-highlight">796</i>&nbsp;    }
<i class="no-highlight">797</i>&nbsp;
<i class="no-highlight">798</i>&nbsp;    /**
<i class="no-highlight">799</i>&nbsp;     * Convenience method to return the database key comparator.
<i class="no-highlight">800</i>&nbsp;     */
<i class="no-highlight">801</i>&nbsp;    public final Comparator&lt;byte[]&gt; getKeyComparator() {
<b class="fc"><i class="no-highlight">802</i>&nbsp;        return databaseImpl.getKeyComparator();</b>
<i class="no-highlight">803</i>&nbsp;    }
<i class="no-highlight">804</i>&nbsp;
<i class="no-highlight">805</i>&nbsp;    @Override
<i class="no-highlight">806</i>&nbsp;    public final int getLevel() {
<b class="fc"><i class="no-highlight">807</i>&nbsp;        return level;</b>
<i class="no-highlight">808</i>&nbsp;    }
<i class="no-highlight">809</i>&nbsp;
<i class="no-highlight">810</i>&nbsp;    public final int getNormalizedLevel() {
<b class="fc"><i class="no-highlight">811</i>&nbsp;        return level &amp; LEVEL_MASK;</b>
<i class="no-highlight">812</i>&nbsp;    }
<i class="no-highlight">813</i>&nbsp;
<i class="no-highlight">814</i>&nbsp;    private static int generateLevel(DatabaseId dbId, int newLevel) {
<b class="fc"><i class="no-highlight">815</i>&nbsp;        if (dbId.equals(DbTree.ID_DB_ID)) {</b>
<b class="fc"><i class="no-highlight">816</i>&nbsp;            return newLevel | DBMAP_LEVEL;</b>
<i class="no-highlight">817</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">818</i>&nbsp;            return newLevel | MAIN_LEVEL;</b>
<i class="no-highlight">819</i>&nbsp;        }
<i class="no-highlight">820</i>&nbsp;    }
<i class="no-highlight">821</i>&nbsp;
<i class="no-highlight">822</i>&nbsp;    public final long getNodeId() {
<b class="fc"><i class="no-highlight">823</i>&nbsp;        return nodeId;</b>
<i class="no-highlight">824</i>&nbsp;    }
<i class="no-highlight">825</i>&nbsp;
<i class="no-highlight">826</i>&nbsp;    /* For unit tests only. */
<i class="no-highlight">827</i>&nbsp;    final void setNodeId(long nid) {
<b class="nc"><i class="no-highlight">828</i>&nbsp;        nodeId = nid;</b>
<b class="nc"><i class="no-highlight">829</i>&nbsp;    }</b>
<i class="no-highlight">830</i>&nbsp;
<i class="no-highlight">831</i>&nbsp;    /**
<i class="no-highlight">832</i>&nbsp;     * We would like as even a hash distribution as possible so that the
<i class="no-highlight">833</i>&nbsp;     * Evictor&#39;s LRU is as accurate as possible.  ConcurrentHashMap takes the
<i class="no-highlight">834</i>&nbsp;     * value returned by this method and runs its own hash algorithm on it.
<i class="no-highlight">835</i>&nbsp;     * So a bit complement of the node ID is sufficient as the return value and
<i class="no-highlight">836</i>&nbsp;     * is a little better than returning just the node ID.  If we use a
<i class="no-highlight">837</i>&nbsp;     * different container in the future that does not re-hash the return
<i class="no-highlight">838</i>&nbsp;     * value, we should probably implement the Wang-Jenkins hash function here.
<i class="no-highlight">839</i>&nbsp;     */
<i class="no-highlight">840</i>&nbsp;    @Override
<i class="no-highlight">841</i>&nbsp;    public final int hashCode() {
<b class="fc"><i class="no-highlight">842</i>&nbsp;        return (int) ~getNodeId();</b>
<i class="no-highlight">843</i>&nbsp;    }
<i class="no-highlight">844</i>&nbsp;
<i class="no-highlight">845</i>&nbsp;    @Override
<i class="no-highlight">846</i>&nbsp;    public final boolean equals(Object obj) {
<b class="nc"><i class="no-highlight">847</i>&nbsp;        if (!(obj instanceof IN)) {</b>
<b class="nc"><i class="no-highlight">848</i>&nbsp;            return false;</b>
<i class="no-highlight">849</i>&nbsp;        }
<b class="nc"><i class="no-highlight">850</i>&nbsp;        IN in = (IN) obj;</b>
<b class="nc"><i class="no-highlight">851</i>&nbsp;        return (this.getNodeId() == in.getNodeId());</b>
<i class="no-highlight">852</i>&nbsp;    }
<i class="no-highlight">853</i>&nbsp;
<i class="no-highlight">854</i>&nbsp;    /**
<i class="no-highlight">855</i>&nbsp;     * Sort based on equality key.
<i class="no-highlight">856</i>&nbsp;     */
<i class="no-highlight">857</i>&nbsp;    public final int compareTo(IN argIN) {
<b class="nc"><i class="no-highlight">858</i>&nbsp;        long argNodeId = argIN.getNodeId();</b>
<b class="nc"><i class="no-highlight">859</i>&nbsp;        long myNodeId = getNodeId();</b>
<i class="no-highlight">860</i>&nbsp;
<b class="nc"><i class="no-highlight">861</i>&nbsp;        if (myNodeId &lt; argNodeId) {</b>
<b class="nc"><i class="no-highlight">862</i>&nbsp;            return -1;</b>
<b class="nc"><i class="no-highlight">863</i>&nbsp;        } else if (myNodeId &gt; argNodeId) {</b>
<b class="nc"><i class="no-highlight">864</i>&nbsp;            return 1;</b>
<i class="no-highlight">865</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">866</i>&nbsp;            return 0;</b>
<i class="no-highlight">867</i>&nbsp;        }
<i class="no-highlight">868</i>&nbsp;    }
<i class="no-highlight">869</i>&nbsp;
<i class="no-highlight">870</i>&nbsp;    public final boolean getDirty() {
<b class="fc"><i class="no-highlight">871</i>&nbsp;        return (flags &amp; IN_DIRTY_BIT) != 0;</b>
<i class="no-highlight">872</i>&nbsp;    }
<i class="no-highlight">873</i>&nbsp;
<i class="no-highlight">874</i>&nbsp;    public final void setDirty(boolean dirty) {
<b class="fc"><i class="no-highlight">875</i>&nbsp;        if (dirty) {</b>
<b class="fc"><i class="no-highlight">876</i>&nbsp;            flags |= IN_DIRTY_BIT;</b>
<i class="no-highlight">877</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">878</i>&nbsp;            flags &amp;= ~IN_DIRTY_BIT;</b>
<i class="no-highlight">879</i>&nbsp;        }
<b class="fc"><i class="no-highlight">880</i>&nbsp;    }</b>
<i class="no-highlight">881</i>&nbsp;
<i class="no-highlight">882</i>&nbsp;    @Override
<i class="no-highlight">883</i>&nbsp;    public final boolean isBINDelta() {
<b class="fc"><i class="no-highlight">884</i>&nbsp;        assert(isUpperIN() || isLatchOwner());</b>
<b class="fc"><i class="no-highlight">885</i>&nbsp;        return (flags &amp; IN_DELTA_BIT) != 0;</b>
<i class="no-highlight">886</i>&nbsp;    }
<i class="no-highlight">887</i>&nbsp;
<i class="no-highlight">888</i>&nbsp;    /*
<i class="no-highlight">889</i>&nbsp;     * This version of isBINDelta() takes a checkLatched param to allow
<i class="no-highlight">890</i>&nbsp;     * for cases where it is ok to call the method without holding the
<i class="no-highlight">891</i>&nbsp;     * BIN latch (e.g. in single-threaded tests, or when the BIN is not
<i class="no-highlight">892</i>&nbsp;     * attached to the tree (and thus inaccessible from other threads)).
<i class="no-highlight">893</i>&nbsp;     */
<i class="no-highlight">894</i>&nbsp;    @Override
<i class="no-highlight">895</i>&nbsp;    public final boolean isBINDelta(boolean checkLatched) {
<b class="fc"><i class="no-highlight">896</i>&nbsp;        assert(!checkLatched || isUpperIN() || isLatchOwner());</b>
<b class="fc"><i class="no-highlight">897</i>&nbsp;        return (flags &amp; IN_DELTA_BIT) != 0;</b>
<i class="no-highlight">898</i>&nbsp;    }
<i class="no-highlight">899</i>&nbsp;
<i class="no-highlight">900</i>&nbsp;    final void setBINDelta(boolean delta) {
<b class="fc"><i class="no-highlight">901</i>&nbsp;        if (delta) {</b>
<b class="fc"><i class="no-highlight">902</i>&nbsp;            flags |= IN_DELTA_BIT;</b>
<i class="no-highlight">903</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">904</i>&nbsp;            flags &amp;= ~IN_DELTA_BIT;</b>
<i class="no-highlight">905</i>&nbsp;        }
<b class="fc"><i class="no-highlight">906</i>&nbsp;    }</b>
<i class="no-highlight">907</i>&nbsp;
<i class="no-highlight">908</i>&nbsp;    /**
<i class="no-highlight">909</i>&nbsp;     * Indicates that the BIN was fetched from disk, or loaded from the
<i class="no-highlight">910</i>&nbsp;     * off-heap cache, using CacheMode.UNCHANGED, and has not been accessed
<i class="no-highlight">911</i>&nbsp;     * with another CacheMode. BINs in this state should be evicted from main
<i class="no-highlight">912</i>&nbsp;     * cache as soon as they are no longer referenced by a cursor. If they were
<i class="no-highlight">913</i>&nbsp;     * loaded from off-heap cache, they should be stored off-heap when they are
<i class="no-highlight">914</i>&nbsp;     * evicted from main. The FetchedColdOffHeap flag indicates whether the
<i class="no-highlight">915</i>&nbsp;     * BIN was loaded from off-heap cache.
<i class="no-highlight">916</i>&nbsp;     */
<i class="no-highlight">917</i>&nbsp;    public final boolean getFetchedCold() {
<b class="nc"><i class="no-highlight">918</i>&nbsp;        return (flags &amp; IN_FETCHED_COLD_BIT) != 0;</b>
<i class="no-highlight">919</i>&nbsp;    }
<i class="no-highlight">920</i>&nbsp;
<i class="no-highlight">921</i>&nbsp;    /** @see #getFetchedCold() */
<i class="no-highlight">922</i>&nbsp;    public final void setFetchedCold(boolean val) {
<b class="fc"><i class="no-highlight">923</i>&nbsp;        if (val) {</b>
<b class="fc"><i class="no-highlight">924</i>&nbsp;            flags |= IN_FETCHED_COLD_BIT;</b>
<i class="no-highlight">925</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">926</i>&nbsp;            flags &amp;= ~IN_FETCHED_COLD_BIT;</b>
<i class="no-highlight">927</i>&nbsp;        }
<b class="fc"><i class="no-highlight">928</i>&nbsp;    }</b>
<i class="no-highlight">929</i>&nbsp;
<i class="no-highlight">930</i>&nbsp;    /** @see #getFetchedCold() */
<i class="no-highlight">931</i>&nbsp;    public final boolean getFetchedColdOffHeap() {
<b class="nc"><i class="no-highlight">932</i>&nbsp;        return (flags &amp; IN_FETCHED_COLD_OFFHEAP_BIT) != 0;</b>
<i class="no-highlight">933</i>&nbsp;    }
<i class="no-highlight">934</i>&nbsp;
<i class="no-highlight">935</i>&nbsp;    /** @see #getFetchedCold() */
<i class="no-highlight">936</i>&nbsp;    public final void setFetchedColdOffHeap(boolean val) {
<b class="fc"><i class="no-highlight">937</i>&nbsp;        if (val) {</b>
<b class="nc"><i class="no-highlight">938</i>&nbsp;            flags |= IN_FETCHED_COLD_OFFHEAP_BIT;</b>
<i class="no-highlight">939</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">940</i>&nbsp;            flags &amp;= ~IN_FETCHED_COLD_OFFHEAP_BIT;</b>
<i class="no-highlight">941</i>&nbsp;        }
<b class="fc"><i class="no-highlight">942</i>&nbsp;    }</b>
<i class="no-highlight">943</i>&nbsp;
<i class="no-highlight">944</i>&nbsp;    public final boolean getRecalcToggle() {
<b class="fc"><i class="no-highlight">945</i>&nbsp;        return (flags &amp; IN_RECALC_TOGGLE_BIT) != 0;</b>
<i class="no-highlight">946</i>&nbsp;    }
<i class="no-highlight">947</i>&nbsp;
<i class="no-highlight">948</i>&nbsp;    public final void setRecalcToggle(boolean toggle) {
<b class="fc"><i class="no-highlight">949</i>&nbsp;        if (toggle) {</b>
<b class="fc"><i class="no-highlight">950</i>&nbsp;            flags |= IN_RECALC_TOGGLE_BIT;</b>
<i class="no-highlight">951</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">952</i>&nbsp;            flags &amp;= ~IN_RECALC_TOGGLE_BIT;</b>
<i class="no-highlight">953</i>&nbsp;        }
<b class="fc"><i class="no-highlight">954</i>&nbsp;    }</b>
<i class="no-highlight">955</i>&nbsp;
<i class="no-highlight">956</i>&nbsp;    public final boolean isRoot() {
<b class="fc"><i class="no-highlight">957</i>&nbsp;        return (flags &amp; IN_IS_ROOT_BIT) != 0;</b>
<i class="no-highlight">958</i>&nbsp;    }
<i class="no-highlight">959</i>&nbsp;
<i class="no-highlight">960</i>&nbsp;    final void setIsRoot(boolean isRoot) {
<b class="fc"><i class="no-highlight">961</i>&nbsp;        setIsRootFlag(isRoot);</b>
<b class="fc"><i class="no-highlight">962</i>&nbsp;        setDirty(true);</b>
<b class="fc"><i class="no-highlight">963</i>&nbsp;    }</b>
<i class="no-highlight">964</i>&nbsp;
<i class="no-highlight">965</i>&nbsp;    private void setIsRootFlag(boolean isRoot) {
<b class="fc"><i class="no-highlight">966</i>&nbsp;        if (isRoot) {</b>
<b class="fc"><i class="no-highlight">967</i>&nbsp;            flags |= IN_IS_ROOT_BIT;</b>
<i class="no-highlight">968</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">969</i>&nbsp;            flags &amp;= ~IN_IS_ROOT_BIT;</b>
<i class="no-highlight">970</i>&nbsp;        }
<b class="fc"><i class="no-highlight">971</i>&nbsp;    }</b>
<i class="no-highlight">972</i>&nbsp;
<i class="no-highlight">973</i>&nbsp;    public final boolean hasCachedChildrenFlag() {
<b class="fc"><i class="no-highlight">974</i>&nbsp;        return (flags &amp; IN_HAS_CACHED_CHILDREN_BIT) != 0;</b>
<i class="no-highlight">975</i>&nbsp;    }
<i class="no-highlight">976</i>&nbsp;
<i class="no-highlight">977</i>&nbsp;    private void setHasCachedChildrenFlag(boolean value) {
<b class="fc"><i class="no-highlight">978</i>&nbsp;        if (value) {</b>
<b class="fc"><i class="no-highlight">979</i>&nbsp;            flags |= IN_HAS_CACHED_CHILDREN_BIT;</b>
<i class="no-highlight">980</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">981</i>&nbsp;            flags &amp;= ~IN_HAS_CACHED_CHILDREN_BIT;</b>
<i class="no-highlight">982</i>&nbsp;        }
<b class="fc"><i class="no-highlight">983</i>&nbsp;    }</b>
<i class="no-highlight">984</i>&nbsp;
<i class="no-highlight">985</i>&nbsp;    public final boolean isInPri2LRU() {
<b class="fc"><i class="no-highlight">986</i>&nbsp;        return (flags &amp; IN_PRI2_LRU_BIT) != 0;</b>
<i class="no-highlight">987</i>&nbsp;    }
<i class="no-highlight">988</i>&nbsp;
<i class="no-highlight">989</i>&nbsp;    /* public for unit tests */
<i class="no-highlight">990</i>&nbsp;    public final void setInPri2LRU(boolean value) {
<b class="fc"><i class="no-highlight">991</i>&nbsp;        if (value) {</b>
<b class="fc"><i class="no-highlight">992</i>&nbsp;            flags |= IN_PRI2_LRU_BIT;</b>
<i class="no-highlight">993</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">994</i>&nbsp;            flags &amp;= ~IN_PRI2_LRU_BIT;</b>
<i class="no-highlight">995</i>&nbsp;        }
<b class="fc"><i class="no-highlight">996</i>&nbsp;    }</b>
<i class="no-highlight">997</i>&nbsp;
<i class="no-highlight">998</i>&nbsp;    public boolean isExpirationInHours() {
<b class="fc"><i class="no-highlight">999</i>&nbsp;        return (flags &amp; IN_EXPIRATION_IN_HOURS) != 0;</b>
<i class="no-highlight">1000</i>&nbsp;    }
<i class="no-highlight">1001</i>&nbsp;
<i class="no-highlight">1002</i>&nbsp;    void setExpirationInHours(boolean value) {
<b class="fc"><i class="no-highlight">1003</i>&nbsp;        if (value) {</b>
<b class="nc"><i class="no-highlight">1004</i>&nbsp;            flags |= IN_EXPIRATION_IN_HOURS;</b>
<i class="no-highlight">1005</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">1006</i>&nbsp;            flags &amp;= ~IN_EXPIRATION_IN_HOURS;</b>
<i class="no-highlight">1007</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1008</i>&nbsp;    }</b>
<i class="no-highlight">1009</i>&nbsp;
<i class="no-highlight">1010</i>&nbsp;    /**
<i class="no-highlight">1011</i>&nbsp;     * @return the identifier key for this node.
<i class="no-highlight">1012</i>&nbsp;     */
<i class="no-highlight">1013</i>&nbsp;    public final byte[] getIdentifierKey() {
<b class="fc"><i class="no-highlight">1014</i>&nbsp;        return identifierKey;</b>
<i class="no-highlight">1015</i>&nbsp;    }
<i class="no-highlight">1016</i>&nbsp;
<i class="no-highlight">1017</i>&nbsp;    /**
<i class="no-highlight">1018</i>&nbsp;     * Set the identifier key for this node.
<i class="no-highlight">1019</i>&nbsp;     *
<i class="no-highlight">1020</i>&nbsp;     * @param key - the new identifier key for this node.
<i class="no-highlight">1021</i>&nbsp;     *
<i class="no-highlight">1022</i>&nbsp;     * @param makeDirty should normally be true, but may be false when an
<i class="no-highlight">1023</i>&nbsp;     * expired slot containing the identifier key has been deleted.
<i class="no-highlight">1024</i>&nbsp;     */
<i class="no-highlight">1025</i>&nbsp;    public final void setIdentifierKey(byte[] key, boolean makeDirty) {
<i class="no-highlight">1026</i>&nbsp;
<b class="fc"><i class="no-highlight">1027</i>&nbsp;        assert(!isBINDelta());</b>
<i class="no-highlight">1028</i>&nbsp;
<i class="no-highlight">1029</i>&nbsp;        /*
<i class="no-highlight">1030</i>&nbsp;         * The identifierKey is &quot;intentionally&quot; not kept track of in the
<i class="no-highlight">1031</i>&nbsp;         * memory budget.  If we did, then it would look like this:
<i class="no-highlight">1032</i>&nbsp;
<i class="no-highlight">1033</i>&nbsp;         int oldIDKeySz = (identifierKey == null) ?
<i class="no-highlight">1034</i>&nbsp;                           0 :
<i class="no-highlight">1035</i>&nbsp;                           MemoryBudget.byteArraySize(identifierKey.length);
<i class="no-highlight">1036</i>&nbsp;
<i class="no-highlight">1037</i>&nbsp;         int newIDKeySz = (key == null) ?
<i class="no-highlight">1038</i>&nbsp;                           0 :
<i class="no-highlight">1039</i>&nbsp;                           MemoryBudget.byteArraySize(key.length);
<i class="no-highlight">1040</i>&nbsp;         updateMemorySize(newIDKeySz - oldIDKeySz);
<i class="no-highlight">1041</i>&nbsp;
<i class="no-highlight">1042</i>&nbsp;         */
<b class="fc"><i class="no-highlight">1043</i>&nbsp;        identifierKey = key;</b>
<i class="no-highlight">1044</i>&nbsp;
<b class="fc"><i class="no-highlight">1045</i>&nbsp;        if (makeDirty) {</b>
<b class="fc"><i class="no-highlight">1046</i>&nbsp;            setDirty(true);</b>
<i class="no-highlight">1047</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1048</i>&nbsp;    }</b>
<i class="no-highlight">1049</i>&nbsp;
<i class="no-highlight">1050</i>&nbsp;    /**
<i class="no-highlight">1051</i>&nbsp;     * @return the number of entries in this node.
<i class="no-highlight">1052</i>&nbsp;     */
<i class="no-highlight">1053</i>&nbsp;    public final int getNEntries() {
<b class="fc"><i class="no-highlight">1054</i>&nbsp;        return nEntries;</b>
<i class="no-highlight">1055</i>&nbsp;    }
<i class="no-highlight">1056</i>&nbsp;
<i class="no-highlight">1057</i>&nbsp;    /**
<i class="no-highlight">1058</i>&nbsp;     * @return the maximum number of entries in this node.
<i class="no-highlight">1059</i>&nbsp;     *
<i class="no-highlight">1060</i>&nbsp;     * Overriden by TestIN in INEntryTestBase.java
<i class="no-highlight">1061</i>&nbsp;     */
<i class="no-highlight">1062</i>&nbsp;    public int getMaxEntries() {
<b class="fc"><i class="no-highlight">1063</i>&nbsp;        return entryStates.length;</b>
<i class="no-highlight">1064</i>&nbsp;    }
<i class="no-highlight">1065</i>&nbsp;
<i class="no-highlight">1066</i>&nbsp;    public final byte getState(int idx) {
<b class="fc"><i class="no-highlight">1067</i>&nbsp;        return entryStates[idx];</b>
<i class="no-highlight">1068</i>&nbsp;    }
<i class="no-highlight">1069</i>&nbsp;
<i class="no-highlight">1070</i>&nbsp;    /**
<i class="no-highlight">1071</i>&nbsp;     * @return true if the object is dirty.
<i class="no-highlight">1072</i>&nbsp;     */
<i class="no-highlight">1073</i>&nbsp;    final boolean isDirty(int idx) {
<b class="fc"><i class="no-highlight">1074</i>&nbsp;        return ((entryStates[idx] &amp; EntryStates.DIRTY_BIT) != 0);</b>
<i class="no-highlight">1075</i>&nbsp;    }
<i class="no-highlight">1076</i>&nbsp;
<i class="no-highlight">1077</i>&nbsp;    /**
<i class="no-highlight">1078</i>&nbsp;     * @return true if the idx&#39;th entry has been deleted, although the
<i class="no-highlight">1079</i>&nbsp;     * transaction that performed the deletion may not be committed.
<i class="no-highlight">1080</i>&nbsp;     */
<i class="no-highlight">1081</i>&nbsp;    public final boolean isEntryPendingDeleted(int idx) {
<b class="fc"><i class="no-highlight">1082</i>&nbsp;        return ((entryStates[idx] &amp; EntryStates.PENDING_DELETED_BIT) != 0);</b>
<i class="no-highlight">1083</i>&nbsp;    }
<i class="no-highlight">1084</i>&nbsp;
<i class="no-highlight">1085</i>&nbsp;    /**
<i class="no-highlight">1086</i>&nbsp;     * Set pendingDeleted to true.
<i class="no-highlight">1087</i>&nbsp;     */
<i class="no-highlight">1088</i>&nbsp;    public final void setPendingDeleted(int idx) {
<i class="no-highlight">1089</i>&nbsp;
<b class="nc"><i class="no-highlight">1090</i>&nbsp;        entryStates[idx] |= EntryStates.PENDING_DELETED_BIT;</b>
<b class="nc"><i class="no-highlight">1091</i>&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<b class="nc"><i class="no-highlight">1092</i>&nbsp;        setDirty(true);</b>
<b class="nc"><i class="no-highlight">1093</i>&nbsp;    }</b>
<i class="no-highlight">1094</i>&nbsp;
<i class="no-highlight">1095</i>&nbsp;    /**
<i class="no-highlight">1096</i>&nbsp;     * Set pendingDeleted to false.
<i class="no-highlight">1097</i>&nbsp;     */
<i class="no-highlight">1098</i>&nbsp;    final void clearPendingDeleted(int idx) {
<i class="no-highlight">1099</i>&nbsp;
<b class="nc"><i class="no-highlight">1100</i>&nbsp;        entryStates[idx] &amp;= EntryStates.CLEAR_PENDING_DELETED_BIT;</b>
<b class="nc"><i class="no-highlight">1101</i>&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<b class="nc"><i class="no-highlight">1102</i>&nbsp;        setDirty(true);</b>
<b class="nc"><i class="no-highlight">1103</i>&nbsp;    }</b>
<i class="no-highlight">1104</i>&nbsp;
<i class="no-highlight">1105</i>&nbsp;    /**
<i class="no-highlight">1106</i>&nbsp;     * @return true if the idx&#39;th entry is deleted for sure.  If a transaction
<i class="no-highlight">1107</i>&nbsp;     * performed the deletion, it has been committed.
<i class="no-highlight">1108</i>&nbsp;     */
<i class="no-highlight">1109</i>&nbsp;    public final boolean isEntryKnownDeleted(int idx) {
<b class="fc"><i class="no-highlight">1110</i>&nbsp;        return ((entryStates[idx] &amp; EntryStates.KNOWN_DELETED_BIT) != 0);</b>
<i class="no-highlight">1111</i>&nbsp;    }
<i class="no-highlight">1112</i>&nbsp;
<i class="no-highlight">1113</i>&nbsp;    /**
<i class="no-highlight">1114</i>&nbsp;     * Set KD flag to true and clear the PD flag (PD does not need to be on
<i class="no-highlight">1115</i>&nbsp;     * if KD is on).
<i class="no-highlight">1116</i>&nbsp;     */
<i class="no-highlight">1117</i>&nbsp;    public final void setKnownDeleted(int idx) {
<i class="no-highlight">1118</i>&nbsp;
<b class="nc"><i class="no-highlight">1119</i>&nbsp;        assert(isBIN());</b>
<i class="no-highlight">1120</i>&nbsp;
<b class="nc"><i class="no-highlight">1121</i>&nbsp;        entryStates[idx] |= EntryStates.KNOWN_DELETED_BIT;</b>
<b class="nc"><i class="no-highlight">1122</i>&nbsp;        entryStates[idx] &amp;= EntryStates.CLEAR_PENDING_DELETED_BIT;</b>
<b class="nc"><i class="no-highlight">1123</i>&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<b class="nc"><i class="no-highlight">1124</i>&nbsp;        setDirty(true);</b>
<b class="nc"><i class="no-highlight">1125</i>&nbsp;    }</b>
<i class="no-highlight">1126</i>&nbsp;
<i class="no-highlight">1127</i>&nbsp;    /**
<i class="no-highlight">1128</i>&nbsp;     * Set knownDeleted flag to true and evict the child LN if cached. The
<i class="no-highlight">1129</i>&nbsp;     * child LN is evicted to save memory, since it will never be fetched
<i class="no-highlight">1130</i>&nbsp;     * again.
<i class="no-highlight">1131</i>&nbsp;     */
<i class="no-highlight">1132</i>&nbsp;    public final void setKnownDeletedAndEvictLN(int index) {
<i class="no-highlight">1133</i>&nbsp;
<b class="nc"><i class="no-highlight">1134</i>&nbsp;        assert(isBIN());</b>
<i class="no-highlight">1135</i>&nbsp;
<b class="nc"><i class="no-highlight">1136</i>&nbsp;        setKnownDeleted(index);</b>
<i class="no-highlight">1137</i>&nbsp;
<b class="nc"><i class="no-highlight">1138</i>&nbsp;        LN oldLN = (LN) getTarget(index);</b>
<b class="nc"><i class="no-highlight">1139</i>&nbsp;        if (oldLN != null) {</b>
<b class="nc"><i class="no-highlight">1140</i>&nbsp;            updateMemorySize(oldLN, null /* newNode */);</b>
<b class="nc"><i class="no-highlight">1141</i>&nbsp;            oldLN.releaseMemoryBudget();</b>
<i class="no-highlight">1142</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1143</i>&nbsp;        setTarget(index, null);</b>
<b class="nc"><i class="no-highlight">1144</i>&nbsp;    }</b>
<i class="no-highlight">1145</i>&nbsp;
<i class="no-highlight">1146</i>&nbsp;    /**
<i class="no-highlight">1147</i>&nbsp;     * Set knownDeleted to false.
<i class="no-highlight">1148</i>&nbsp;     */
<i class="no-highlight">1149</i>&nbsp;    final void clearKnownDeleted(int idx) {
<i class="no-highlight">1150</i>&nbsp;
<b class="nc"><i class="no-highlight">1151</i>&nbsp;        assert(isBIN());</b>
<i class="no-highlight">1152</i>&nbsp;
<b class="nc"><i class="no-highlight">1153</i>&nbsp;        entryStates[idx] &amp;= EntryStates.CLEAR_KNOWN_DELETED_BIT;</b>
<b class="nc"><i class="no-highlight">1154</i>&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<b class="nc"><i class="no-highlight">1155</i>&nbsp;        setDirty(true);</b>
<b class="nc"><i class="no-highlight">1156</i>&nbsp;    }</b>
<i class="no-highlight">1157</i>&nbsp;
<i class="no-highlight">1158</i>&nbsp;    /*
<i class="no-highlight">1159</i>&nbsp;     * In the future we may want to move the following static methods to an
<i class="no-highlight">1160</i>&nbsp;     * EntryState utility class and share all state bit twidling among IN,
<i class="no-highlight">1161</i>&nbsp;     * ChildReference, and DeltaInfo.
<i class="no-highlight">1162</i>&nbsp;     */
<i class="no-highlight">1163</i>&nbsp;
<i class="no-highlight">1164</i>&nbsp;    /**
<i class="no-highlight">1165</i>&nbsp;     * Returns true if the given state is known deleted.
<i class="no-highlight">1166</i>&nbsp;     */
<i class="no-highlight">1167</i>&nbsp;    static boolean isStateKnownDeleted(byte state) {
<b class="nc"><i class="no-highlight">1168</i>&nbsp;        return ((state &amp; EntryStates.KNOWN_DELETED_BIT) != 0);</b>
<i class="no-highlight">1169</i>&nbsp;    }
<i class="no-highlight">1170</i>&nbsp;
<i class="no-highlight">1171</i>&nbsp;    /**
<i class="no-highlight">1172</i>&nbsp;     * Returns true if the given state is pending deleted.
<i class="no-highlight">1173</i>&nbsp;     */
<i class="no-highlight">1174</i>&nbsp;    static boolean isStatePendingDeleted(byte state) {
<b class="nc"><i class="no-highlight">1175</i>&nbsp;        return ((state &amp; EntryStates.PENDING_DELETED_BIT) != 0);</b>
<i class="no-highlight">1176</i>&nbsp;    }
<i class="no-highlight">1177</i>&nbsp;
<i class="no-highlight">1178</i>&nbsp;    /**
<i class="no-highlight">1179</i>&nbsp;     * Return true if the LN at the given slot is embedded.
<i class="no-highlight">1180</i>&nbsp;     */
<i class="no-highlight">1181</i>&nbsp;    public final boolean isEmbeddedLN(int idx) {
<b class="fc"><i class="no-highlight">1182</i>&nbsp;        return ((entryStates[idx] &amp; EntryStates.EMBEDDED_LN_BIT) != 0);</b>
<i class="no-highlight">1183</i>&nbsp;    }
<i class="no-highlight">1184</i>&nbsp;
<i class="no-highlight">1185</i>&nbsp;    public static boolean isEmbeddedLN(byte state) {
<b class="nc"><i class="no-highlight">1186</i>&nbsp;        return ((state &amp; EntryStates.EMBEDDED_LN_BIT) != 0);</b>
<i class="no-highlight">1187</i>&nbsp;    }
<i class="no-highlight">1188</i>&nbsp;
<i class="no-highlight">1189</i>&nbsp;    /**
<i class="no-highlight">1190</i>&nbsp;     * Set embeddedLN to true.
<i class="no-highlight">1191</i>&nbsp;     */
<i class="no-highlight">1192</i>&nbsp;    private void setEmbeddedLN(int idx) {
<i class="no-highlight">1193</i>&nbsp;
<b class="nc"><i class="no-highlight">1194</i>&nbsp;        entryStates[idx] |= EntryStates.EMBEDDED_LN_BIT;</b>
<b class="nc"><i class="no-highlight">1195</i>&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<b class="nc"><i class="no-highlight">1196</i>&nbsp;        setDirty(true);</b>
<b class="nc"><i class="no-highlight">1197</i>&nbsp;    }</b>
<i class="no-highlight">1198</i>&nbsp;
<i class="no-highlight">1199</i>&nbsp;    /**
<i class="no-highlight">1200</i>&nbsp;     * Set embeddedLN to false.
<i class="no-highlight">1201</i>&nbsp;     */
<i class="no-highlight">1202</i>&nbsp;    private void clearEmbeddedLN(int idx) {
<i class="no-highlight">1203</i>&nbsp;
<b class="nc"><i class="no-highlight">1204</i>&nbsp;        entryStates[idx] &amp;= EntryStates.CLEAR_EMBEDDED_LN_BIT;</b>
<b class="nc"><i class="no-highlight">1205</i>&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<b class="nc"><i class="no-highlight">1206</i>&nbsp;        setDirty(true);</b>
<b class="nc"><i class="no-highlight">1207</i>&nbsp;    }</b>
<i class="no-highlight">1208</i>&nbsp;
<i class="no-highlight">1209</i>&nbsp;    /**
<i class="no-highlight">1210</i>&nbsp;     * Return true if the LN at the given slot is an embedded LN with no data.
<i class="no-highlight">1211</i>&nbsp;     */
<i class="no-highlight">1212</i>&nbsp;    public final boolean isNoDataLN(int idx) {
<b class="fc"><i class="no-highlight">1213</i>&nbsp;        return ((entryStates[idx] &amp; EntryStates.NO_DATA_LN_BIT) != 0);</b>
<i class="no-highlight">1214</i>&nbsp;    }
<i class="no-highlight">1215</i>&nbsp;
<i class="no-highlight">1216</i>&nbsp;    public static boolean isNoDataLN(byte state) {
<b class="nc"><i class="no-highlight">1217</i>&nbsp;        return ((state &amp; EntryStates.NO_DATA_LN_BIT) != 0);</b>
<i class="no-highlight">1218</i>&nbsp;    }
<i class="no-highlight">1219</i>&nbsp;
<i class="no-highlight">1220</i>&nbsp;    /**
<i class="no-highlight">1221</i>&nbsp;     * Set noDataLN to true.
<i class="no-highlight">1222</i>&nbsp;     */
<i class="no-highlight">1223</i>&nbsp;    void setNoDataLN(int idx) {
<i class="no-highlight">1224</i>&nbsp;
<b class="nc"><i class="no-highlight">1225</i>&nbsp;        entryStates[idx] |= EntryStates.NO_DATA_LN_BIT;</b>
<b class="nc"><i class="no-highlight">1226</i>&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<b class="nc"><i class="no-highlight">1227</i>&nbsp;        setDirty(true);</b>
<b class="nc"><i class="no-highlight">1228</i>&nbsp;    }</b>
<i class="no-highlight">1229</i>&nbsp;
<i class="no-highlight">1230</i>&nbsp;    /**
<i class="no-highlight">1231</i>&nbsp;     * Set noDataLN to false.
<i class="no-highlight">1232</i>&nbsp;     */
<i class="no-highlight">1233</i>&nbsp;    private void clearNoDataLN(int idx) {
<i class="no-highlight">1234</i>&nbsp;
<b class="nc"><i class="no-highlight">1235</i>&nbsp;        entryStates[idx] &amp;= EntryStates.CLEAR_NO_DATA_LN_BIT;</b>
<b class="nc"><i class="no-highlight">1236</i>&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<b class="nc"><i class="no-highlight">1237</i>&nbsp;        setDirty(true);</b>
<b class="nc"><i class="no-highlight">1238</i>&nbsp;    }</b>
<i class="no-highlight">1239</i>&nbsp;
<i class="no-highlight">1240</i>&nbsp;    /*
<i class="no-highlight">1241</i>&nbsp;     *
<i class="no-highlight">1242</i>&nbsp;     */
<i class="no-highlight">1243</i>&nbsp;    public final boolean haveEmbeddedData(int idx) {
<b class="fc"><i class="no-highlight">1244</i>&nbsp;        return (isEmbeddedLN(idx) &amp;&amp; !isNoDataLN(idx));</b>
<i class="no-highlight">1245</i>&nbsp;    }
<i class="no-highlight">1246</i>&nbsp;
<i class="no-highlight">1247</i>&nbsp;    /* For unit testing */
<i class="no-highlight">1248</i>&nbsp;    public final int getNumEmbeddedLNs() {
<b class="nc"><i class="no-highlight">1249</i>&nbsp;        int res = 0;</b>
<b class="nc"><i class="no-highlight">1250</i>&nbsp;        for (int i = 0; i &lt; getNEntries(); ++i) {</b>
<b class="nc"><i class="no-highlight">1251</i>&nbsp;            if (isEmbeddedLN(i)) {</b>
<b class="nc"><i class="no-highlight">1252</i>&nbsp;                ++res;</b>
<i class="no-highlight">1253</i>&nbsp;            }
<i class="no-highlight">1254</i>&nbsp;        }
<i class="no-highlight">1255</i>&nbsp;
<b class="nc"><i class="no-highlight">1256</i>&nbsp;        return res;</b>
<i class="no-highlight">1257</i>&nbsp;    }
<i class="no-highlight">1258</i>&nbsp;
<i class="no-highlight">1259</i>&nbsp;    /* For unit testing */
<i class="no-highlight">1260</i>&nbsp;    public final INKeyRep getKeyVals() {
<b class="nc"><i class="no-highlight">1261</i>&nbsp;        return entryKeys;</b>
<i class="no-highlight">1262</i>&nbsp;    }
<i class="no-highlight">1263</i>&nbsp;
<i class="no-highlight">1264</i>&nbsp;    public final byte[] getKeyPrefix() {
<b class="nc"><i class="no-highlight">1265</i>&nbsp;        return keyPrefix;</b>
<i class="no-highlight">1266</i>&nbsp;    }
<i class="no-highlight">1267</i>&nbsp;
<i class="no-highlight">1268</i>&nbsp;    /*
<i class="no-highlight">1269</i>&nbsp;     * For unit testing only
<i class="no-highlight">1270</i>&nbsp;     */
<i class="no-highlight">1271</i>&nbsp;    public final boolean hasKeyPrefix() {
<b class="nc"><i class="no-highlight">1272</i>&nbsp;        return keyPrefix != null;</b>
<i class="no-highlight">1273</i>&nbsp;    }
<i class="no-highlight">1274</i>&nbsp;
<i class="no-highlight">1275</i>&nbsp;    /* This has default protection for access by the unit tests. */
<i class="no-highlight">1276</i>&nbsp;    final void setKeyPrefix(byte[] keyPrefix) {
<i class="no-highlight">1277</i>&nbsp;
<b class="fc"><i class="no-highlight">1278</i>&nbsp;        assert databaseImpl != null;</b>
<i class="no-highlight">1279</i>&nbsp;
<b class="fc"><i class="no-highlight">1280</i>&nbsp;        int prevLength = (this.keyPrefix == null) ? 0 : this.keyPrefix.length;</b>
<b class="fc"><i class="no-highlight">1281</i>&nbsp;        this.keyPrefix = keyPrefix;</b>
<i class="no-highlight">1282</i>&nbsp;        /* Update the memory budgeting to reflect changes in the key prefix. */
<b class="fc"><i class="no-highlight">1283</i>&nbsp;        int currLength = (keyPrefix == null) ? 0 : keyPrefix.length;</b>
<b class="fc"><i class="no-highlight">1284</i>&nbsp;        updateMemorySize(prevLength, currLength);</b>
<b class="fc"><i class="no-highlight">1285</i>&nbsp;    }</b>
<i class="no-highlight">1286</i>&nbsp;
<i class="no-highlight">1287</i>&nbsp;    /**
<i class="no-highlight">1288</i>&nbsp;     * Return the idx&#39;th key. If prefixing is enabled, construct a new byte[]
<i class="no-highlight">1289</i>&nbsp;     * containing the prefix and suffix. If prefixing is not enabled, just
<i class="no-highlight">1290</i>&nbsp;     * return the current byte[] in entryKeys.
<i class="no-highlight">1291</i>&nbsp;     */
<i class="no-highlight">1292</i>&nbsp;    public final byte[] getKey(int idx) {
<i class="no-highlight">1293</i>&nbsp;
<b class="fc"><i class="no-highlight">1294</i>&nbsp;        assert idx &lt; nEntries;</b>
<i class="no-highlight">1295</i>&nbsp;
<b class="fc"><i class="no-highlight">1296</i>&nbsp;        byte[] key = entryKeys.getFullKey(</b>
<b class="fc"><i class="no-highlight">1297</i>&nbsp;            keyPrefix, idx, haveEmbeddedData(idx));</b>
<i class="no-highlight">1298</i>&nbsp;
<b class="fc"><i class="no-highlight">1299</i>&nbsp;        assert(key != null);</b>
<i class="no-highlight">1300</i>&nbsp;
<b class="fc"><i class="no-highlight">1301</i>&nbsp;        return key;</b>
<i class="no-highlight">1302</i>&nbsp;    }
<i class="no-highlight">1303</i>&nbsp;
<i class="no-highlight">1304</i>&nbsp;    public final byte[] getData(int idx) {
<i class="no-highlight">1305</i>&nbsp;
<b class="fc"><i class="no-highlight">1306</i>&nbsp;        if (haveEmbeddedData(idx)) {</b>
<b class="nc"><i class="no-highlight">1307</i>&nbsp;            return entryKeys.getData(idx);</b>
<i class="no-highlight">1308</i>&nbsp;        }
<i class="no-highlight">1309</i>&nbsp;
<b class="fc"><i class="no-highlight">1310</i>&nbsp;        if (isNoDataLN(idx)) {</b>
<b class="nc"><i class="no-highlight">1311</i>&nbsp;            return Key.EMPTY_KEY;</b>
<i class="no-highlight">1312</i>&nbsp;        }
<i class="no-highlight">1313</i>&nbsp;
<b class="fc"><i class="no-highlight">1314</i>&nbsp;        return null;</b>
<i class="no-highlight">1315</i>&nbsp;    }
<i class="no-highlight">1316</i>&nbsp;
<i class="no-highlight">1317</i>&nbsp;    /**
<i class="no-highlight">1318</i>&nbsp;     * Returns the size of the key that is stored persistently, which will be
<i class="no-highlight">1319</i>&nbsp;     * the combined key-data for an embedded LN or duplicated DB record.
<i class="no-highlight">1320</i>&nbsp;     */
<i class="no-highlight">1321</i>&nbsp;    int getStoredKeySize(int idx) {
<b class="fc"><i class="no-highlight">1322</i>&nbsp;        return entryKeys.size(idx);</b>
<i class="no-highlight">1323</i>&nbsp;    }
<i class="no-highlight">1324</i>&nbsp;
<i class="no-highlight">1325</i>&nbsp;    /**
<i class="no-highlight">1326</i>&nbsp;     * Updates the key in the idx-th slot of this BIN, if the DB allows key
<i class="no-highlight">1327</i>&nbsp;     * updates and the new key is not identical to the current key in the slot.
<i class="no-highlight">1328</i>&nbsp;     * It also updates the data (if any) that is embedded with the key in the
<i class="no-highlight">1329</i>&nbsp;     * idx-slot, or embeds new data in that slot, is the &quot;data&quot; param is
<i class="no-highlight">1330</i>&nbsp;     * non-null, or removes embedded data, if &quot;data&quot; is null. Finally, it
<i class="no-highlight">1331</i>&nbsp;     * sets the EMBEDDED_LN_BIT and NO_DATA_LN_BIT flags in the slot&#39;s state.
<i class="no-highlight">1332</i>&nbsp;     *
<i class="no-highlight">1333</i>&nbsp;     * @param key is the key to set in the slot and is the LN key.
<i class="no-highlight">1334</i>&nbsp;     *
<i class="no-highlight">1335</i>&nbsp;     * @param data If the data portion of a record must be embedded in this
<i class="no-highlight">1336</i>&nbsp;     * BIN, &quot;data&quot; stores the record&#39;s data. Null otherwise. See also comment
<i class="no-highlight">1337</i>&nbsp;     * for the keyEntries field. 
<i class="no-highlight">1338</i>&nbsp;     * 
<i class="no-highlight">1339</i>&nbsp;     * @return true if a multi-slot change was made and the complete IN memory
<i class="no-highlight">1340</i>&nbsp;     * size must be updated.
<i class="no-highlight">1341</i>&nbsp;     */
<i class="no-highlight">1342</i>&nbsp;    private boolean updateLNSlotKey(int idx, byte[] key, byte[] data) {
<i class="no-highlight">1343</i>&nbsp;
<b class="fc"><i class="no-highlight">1344</i>&nbsp;        assert(isBIN());</b>
<i class="no-highlight">1345</i>&nbsp;
<b class="fc"><i class="no-highlight">1346</i>&nbsp;        boolean haveEmbeddedData = haveEmbeddedData(idx);</b>
<i class="no-highlight">1347</i>&nbsp;
<b class="fc"><i class="no-highlight">1348</i>&nbsp;        if (data == null) {</b>
<b class="fc"><i class="no-highlight">1349</i>&nbsp;            if (isEmbeddedLN(idx)) {</b>
<b class="nc"><i class="no-highlight">1350</i>&nbsp;                clearEmbeddedLN(idx); </b>
<b class="nc"><i class="no-highlight">1351</i>&nbsp;                clearNoDataLN(idx);</b>
<i class="no-highlight">1352</i>&nbsp;            }
<i class="no-highlight">1353</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">1354</i>&nbsp;            if (!isEmbeddedLN(idx)) {</b>
<b class="nc"><i class="no-highlight">1355</i>&nbsp;                setEmbeddedLN(idx);</b>
<i class="no-highlight">1356</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1357</i>&nbsp;            if (data.length == 0) {</b>
<b class="nc"><i class="no-highlight">1358</i>&nbsp;                setNoDataLN(idx);</b>
<i class="no-highlight">1359</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">1360</i>&nbsp;                clearNoDataLN(idx);</b>
<i class="no-highlight">1361</i>&nbsp;            }
<i class="no-highlight">1362</i>&nbsp;        }
<i class="no-highlight">1363</i>&nbsp;
<i class="no-highlight">1364</i>&nbsp;        /*
<i class="no-highlight">1365</i>&nbsp;         * The new key may be null if a dup LN was deleted, in which case there
<i class="no-highlight">1366</i>&nbsp;         * is no need to update it.  There is no need to compare keys if there
<i class="no-highlight">1367</i>&nbsp;         * is no comparator configured, since a key cannot be changed when the
<i class="no-highlight">1368</i>&nbsp;         * default comparator is used.
<i class="no-highlight">1369</i>&nbsp;         */
<b class="fc"><i class="no-highlight">1370</i>&nbsp;        if (key != null &amp;&amp;</b>
<b class="fc"><i class="no-highlight">1371</i>&nbsp;            (databaseImpl.allowsKeyUpdates() ||</b>
<b class="fc"><i class="no-highlight">1372</i>&nbsp;             DupConvert.needsConversion(databaseImpl)) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">1373</i>&nbsp;            !Arrays.equals(key, getKey(idx))) {</b>
<i class="no-highlight">1374</i>&nbsp;
<b class="nc"><i class="no-highlight">1375</i>&nbsp;            setDirty(true);</b>
<b class="nc"><i class="no-highlight">1376</i>&nbsp;            return setKey(idx, key, data, false);</b>
<i class="no-highlight">1377</i>&nbsp;
<b class="fc"><i class="no-highlight">1378</i>&nbsp;        } else if (haveEmbeddedData) {</b>
<i class="no-highlight">1379</i>&nbsp;
<i class="no-highlight">1380</i>&nbsp;            /*
<i class="no-highlight">1381</i>&nbsp;             * The key does not change, but the slot contains embedded data,
<i class="no-highlight">1382</i>&nbsp;             * which must now either be removed (if data == null or
<i class="no-highlight">1383</i>&nbsp;             * data.length == 0) or updated.
<i class="no-highlight">1384</i>&nbsp;             * TODO #21488: update the data only if it actually changes.
<i class="no-highlight">1385</i>&nbsp;             */
<b class="nc"><i class="no-highlight">1386</i>&nbsp;            setDirty(true);</b>
<b class="nc"><i class="no-highlight">1387</i>&nbsp;            entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<i class="no-highlight">1388</i>&nbsp;
<b class="nc"><i class="no-highlight">1389</i>&nbsp;            INKeyRep.Type oldRepType = entryKeys.getType();</b>
<b class="nc"><i class="no-highlight">1390</i>&nbsp;            entryKeys = entryKeys.setData(idx, data, this);</b>
<b class="nc"><i class="no-highlight">1391</i>&nbsp;            return oldRepType != entryKeys.getType();</b>
<i class="no-highlight">1392</i>&nbsp;
<b class="fc"><i class="no-highlight">1393</i>&nbsp;        } else if (data != null &amp;&amp; data.length != 0) {</b>
<i class="no-highlight">1394</i>&nbsp;
<i class="no-highlight">1395</i>&nbsp;            /*
<i class="no-highlight">1396</i>&nbsp;             * The key does not change, but we now have to embed data in a slot
<i class="no-highlight">1397</i>&nbsp;             * that does not currently have embedded data.
<i class="no-highlight">1398</i>&nbsp;             */
<b class="nc"><i class="no-highlight">1399</i>&nbsp;            setDirty(true);</b>
<b class="nc"><i class="no-highlight">1400</i>&nbsp;            entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<i class="no-highlight">1401</i>&nbsp;
<b class="nc"><i class="no-highlight">1402</i>&nbsp;            key = entryKeys.getKey(idx, false);</b>
<b class="nc"><i class="no-highlight">1403</i>&nbsp;            INKeyRep.Type oldRepType = entryKeys.getType();</b>
<b class="nc"><i class="no-highlight">1404</i>&nbsp;            entryKeys = entryKeys.set(idx, key, data, this);</b>
<b class="nc"><i class="no-highlight">1405</i>&nbsp;            return oldRepType != entryKeys.getType();</b>
<i class="no-highlight">1406</i>&nbsp;
<i class="no-highlight">1407</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">1408</i>&nbsp;            return false;</b>
<i class="no-highlight">1409</i>&nbsp;        }
<i class="no-highlight">1410</i>&nbsp;    }
<i class="no-highlight">1411</i>&nbsp;
<i class="no-highlight">1412</i>&nbsp;    /*
<i class="no-highlight">1413</i>&nbsp;     * Convenience wrapper for setKey() method below
<i class="no-highlight">1414</i>&nbsp;     */
<i class="no-highlight">1415</i>&nbsp;    private boolean insertKey(
<i class="no-highlight">1416</i>&nbsp;        int idx,
<i class="no-highlight">1417</i>&nbsp;        byte[] key,
<i class="no-highlight">1418</i>&nbsp;        byte[] data) {
<i class="no-highlight">1419</i>&nbsp;
<i class="no-highlight">1420</i>&nbsp;        /*
<i class="no-highlight">1421</i>&nbsp;         * Set the id key when inserting the first entry. This is important
<i class="no-highlight">1422</i>&nbsp;         * when compression removes all entries from a BIN, and then an entry
<i class="no-highlight">1423</i>&nbsp;         * is inserted before the empty BIN is purged.
<i class="no-highlight">1424</i>&nbsp;         */
<b class="fc"><i class="no-highlight">1425</i>&nbsp;        if (nEntries == 1 &amp;&amp; !isBINDelta()) {</b>
<b class="fc"><i class="no-highlight">1426</i>&nbsp;            setIdentifierKey(key, true /*makeDirty*/);</b>
<i class="no-highlight">1427</i>&nbsp;        }
<i class="no-highlight">1428</i>&nbsp;
<b class="fc"><i class="no-highlight">1429</i>&nbsp;        return setKey(idx, key, data, true);</b>
<i class="no-highlight">1430</i>&nbsp;    }
<i class="no-highlight">1431</i>&nbsp;
<i class="no-highlight">1432</i>&nbsp;    // TODO re-enable this and figure out why it is firing
<i class="no-highlight">1433</i>&nbsp;
<i class="no-highlight">1434</i>&nbsp;    private boolean idKeyIsSlotKey() {
<i class="no-highlight">1435</i>&nbsp;
<i class="no-highlight">1436</i>&nbsp;        if (true) {
<b class="nc"><i class="no-highlight">1437</i>&nbsp;            return true;</b>
<i class="no-highlight">1438</i>&nbsp;        }
<i class="no-highlight">1439</i>&nbsp;
<i class="no-highlight">1440</i>&nbsp;        if (!isBIN() || nEntries == 0) {
<i class="no-highlight">1441</i>&nbsp;            return true;
<i class="no-highlight">1442</i>&nbsp;        }
<i class="no-highlight">1443</i>&nbsp;
<i class="no-highlight">1444</i>&nbsp;        for (int i = 0; i &lt; nEntries; i += 1) {
<i class="no-highlight">1445</i>&nbsp;
<i class="no-highlight">1446</i>&nbsp;            if (entryKeys.compareKeys(
<i class="no-highlight">1447</i>&nbsp;                identifierKey,  keyPrefix, i, haveEmbeddedData(i),
<i class="no-highlight">1448</i>&nbsp;                databaseImpl.getKeyComparator()) == 0) {
<i class="no-highlight">1449</i>&nbsp;
<i class="no-highlight">1450</i>&nbsp;                return true;
<i class="no-highlight">1451</i>&nbsp;            }
<i class="no-highlight">1452</i>&nbsp;        }
<i class="no-highlight">1453</i>&nbsp;
<i class="no-highlight">1454</i>&nbsp;        return false;
<i class="no-highlight">1455</i>&nbsp;    }
<i class="no-highlight">1456</i>&nbsp;
<i class="no-highlight">1457</i>&nbsp;    /*
<i class="no-highlight">1458</i>&nbsp;     * Convenience wrapper for setKey() method below. It is used for
<i class="no-highlight">1459</i>&nbsp;     * upper INs only, so no need to worry about the EMBEDDED_LN_BIT
<i class="no-highlight">1460</i>&nbsp;     * and NO_DATA_LN_BIT flags.
<i class="no-highlight">1461</i>&nbsp;     */
<i class="no-highlight">1462</i>&nbsp;    private boolean updateKey(
<i class="no-highlight">1463</i>&nbsp;        int idx,
<i class="no-highlight">1464</i>&nbsp;        byte[] key,
<i class="no-highlight">1465</i>&nbsp;        byte[] data) {
<b class="fc"><i class="no-highlight">1466</i>&nbsp;        return setKey(idx, key, data, false);</b>
<i class="no-highlight">1467</i>&nbsp;    }
<i class="no-highlight">1468</i>&nbsp;
<i class="no-highlight">1469</i>&nbsp;    /**
<i class="no-highlight">1470</i>&nbsp;     * This method inserts or updates a key at a given slot. In either case,
<i class="no-highlight">1471</i>&nbsp;     * the associated embedded data (if any) is inserted or updated as well,
<i class="no-highlight">1472</i>&nbsp;     * and the key prefix is adjusted, if necessary.
<i class="no-highlight">1473</i>&nbsp;     *
<i class="no-highlight">1474</i>&nbsp;     * In case of insertion (indicated by a true value for the isInsertion
<i class="no-highlight">1475</i>&nbsp;     * param), it is assumed that the idx slot does not store any valid info,
<i class="no-highlight">1476</i>&nbsp;     * so any change to the key prefix (if any) is due to the insertion of
<i class="no-highlight">1477</i>&nbsp;     * this new new key and not to the removal of the current key at the idx
<i class="no-highlight">1478</i>&nbsp;     * slot.
<i class="no-highlight">1479</i>&nbsp;     *
<i class="no-highlight">1480</i>&nbsp;     * In case of update, the method does not check if the current key is
<i class="no-highlight">1481</i>&nbsp;     * indeed different from the new key; it just updates the key
<i class="no-highlight">1482</i>&nbsp;     * unconditionally. If the slot has embedded data, that data will also
<i class="no-highlight">1483</i>&nbsp;     * be updated (if the data param is not null), or be removed (if the data
<i class="no-highlight">1484</i>&nbsp;     * param is null). If the slot does not have embedded data and the data
<i class="no-highlight">1485</i>&nbsp;     * param is not null, the given data will be embedded.
<i class="no-highlight">1486</i>&nbsp;     *
<i class="no-highlight">1487</i>&nbsp;     * Note: For BINs, the maintenance of the EMBEDDED_LN_BIT andNO_DATA_LN_BIT
<i class="no-highlight">1488</i>&nbsp;     * is done by the callers of this method.
<i class="no-highlight">1489</i>&nbsp;     *
<i class="no-highlight">1490</i>&nbsp;     * @param data If the data portion of a record must be embedded in this
<i class="no-highlight">1491</i>&nbsp;     * BIN, &quot;data&quot; stores the record&#39;s data. Null otherwise. See also comment
<i class="no-highlight">1492</i>&nbsp;     * for the keyEntries field. 
<i class="no-highlight">1493</i>&nbsp;     *
<i class="no-highlight">1494</i>&nbsp;     * @return true if a multi-slot change was made and the complete IN memory
<i class="no-highlight">1495</i>&nbsp;     * size must be updated.
<i class="no-highlight">1496</i>&nbsp;     */
<i class="no-highlight">1497</i>&nbsp;    public boolean setKey(
<i class="no-highlight">1498</i>&nbsp;        int idx,
<i class="no-highlight">1499</i>&nbsp;        byte[] key,
<i class="no-highlight">1500</i>&nbsp;        byte[] data,
<i class="no-highlight">1501</i>&nbsp;        boolean isInsertion) {
<i class="no-highlight">1502</i>&nbsp;
<b class="fc"><i class="no-highlight">1503</i>&nbsp;        entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<b class="fc"><i class="no-highlight">1504</i>&nbsp;        setDirty(true);</b>
<i class="no-highlight">1505</i>&nbsp;
<i class="no-highlight">1506</i>&nbsp;        /*
<i class="no-highlight">1507</i>&nbsp;         * Only compute key prefix if prefixing is enabled and there&#39;s an
<i class="no-highlight">1508</i>&nbsp;         * existing prefix.
<i class="no-highlight">1509</i>&nbsp;         */
<b class="fc"><i class="no-highlight">1510</i>&nbsp;        if (databaseImpl.getKeyPrefixing() &amp;&amp; keyPrefix != null) {</b>
<i class="no-highlight">1511</i>&nbsp;
<b class="nc"><i class="no-highlight">1512</i>&nbsp;            int newPrefixLen = Key.getKeyPrefixLength(</b>
<i class="no-highlight">1513</i>&nbsp;                keyPrefix, keyPrefix.length, key);
<i class="no-highlight">1514</i>&nbsp;
<b class="nc"><i class="no-highlight">1515</i>&nbsp;            if (newPrefixLen &lt; keyPrefix.length) {</b>
<i class="no-highlight">1516</i>&nbsp;
<i class="no-highlight">1517</i>&nbsp;                /*
<i class="no-highlight">1518</i>&nbsp;                 * The new key doesn&#39;t share the current prefix, so recompute
<i class="no-highlight">1519</i>&nbsp;                 * the prefix and readjust all the existing suffixes.
<i class="no-highlight">1520</i>&nbsp;                 */
<b class="nc"><i class="no-highlight">1521</i>&nbsp;                byte[] newPrefix = (isInsertion ?</b>
<b class="nc"><i class="no-highlight">1522</i>&nbsp;                                    Key.createKeyPrefix(keyPrefix, key) :</b>
<b class="nc"><i class="no-highlight">1523</i>&nbsp;                                    computeKeyPrefix(idx));</b>
<i class="no-highlight">1524</i>&nbsp;
<b class="nc"><i class="no-highlight">1525</i>&nbsp;                if (newPrefix != null) {</b>
<i class="no-highlight">1526</i>&nbsp;                    /* Take the new key into consideration for new prefix. */
<b class="nc"><i class="no-highlight">1527</i>&nbsp;                    newPrefix = Key.createKeyPrefix(newPrefix, key);</b>
<i class="no-highlight">1528</i>&nbsp;                }
<i class="no-highlight">1529</i>&nbsp;
<b class="nc"><i class="no-highlight">1530</i>&nbsp;                recalcSuffixes(newPrefix, key, data, idx);</b>
<b class="nc"><i class="no-highlight">1531</i>&nbsp;                return true;</b>
<i class="no-highlight">1532</i>&nbsp;
<i class="no-highlight">1533</i>&nbsp;            } else {
<i class="no-highlight">1534</i>&nbsp;
<b class="nc"><i class="no-highlight">1535</i>&nbsp;                INKeyRep.Type prevRepType = entryKeys.getType();</b>
<i class="no-highlight">1536</i>&nbsp;
<b class="nc"><i class="no-highlight">1537</i>&nbsp;                byte[] suffix = computeKeySuffix(keyPrefix, key);</b>
<b class="nc"><i class="no-highlight">1538</i>&nbsp;                entryKeys = entryKeys.set(idx, suffix, data, this);</b>
<i class="no-highlight">1539</i>&nbsp;
<b class="nc"><i class="no-highlight">1540</i>&nbsp;                return prevRepType != entryKeys.getType();</b>
<i class="no-highlight">1541</i>&nbsp;            }
<i class="no-highlight">1542</i>&nbsp;
<b class="fc"><i class="no-highlight">1543</i>&nbsp;        } else if (keyPrefix != null) {</b>
<i class="no-highlight">1544</i>&nbsp;
<i class="no-highlight">1545</i>&nbsp;            /*
<i class="no-highlight">1546</i>&nbsp;             * Key prefixing has been turned off on this database, but there
<i class="no-highlight">1547</i>&nbsp;             * are existing prefixes. Remove prefixes for this IN.
<i class="no-highlight">1548</i>&nbsp;             */
<b class="nc"><i class="no-highlight">1549</i>&nbsp;            recalcSuffixes(null, key, data, idx);</b>
<b class="nc"><i class="no-highlight">1550</i>&nbsp;            return true;</b>
<i class="no-highlight">1551</i>&nbsp;
<i class="no-highlight">1552</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">1553</i>&nbsp;            INKeyRep.Type oldRepType = entryKeys.getType();</b>
<b class="fc"><i class="no-highlight">1554</i>&nbsp;            entryKeys = entryKeys.set(idx, key, data, this);</b>
<b class="fc"><i class="no-highlight">1555</i>&nbsp;            return oldRepType != entryKeys.getType();</b>
<i class="no-highlight">1556</i>&nbsp;        }
<i class="no-highlight">1557</i>&nbsp;    }
<i class="no-highlight">1558</i>&nbsp;
<i class="no-highlight">1559</i>&nbsp;    /*
<i class="no-highlight">1560</i>&nbsp;     * Given 2 byte arrays, &quot;prefix&quot; and &quot;key&quot;, where &quot;prefix&quot; is or stores
<i class="no-highlight">1561</i>&nbsp;     * a prefix of &quot;key&quot;, allocate and return another byte array that stores
<i class="no-highlight">1562</i>&nbsp;     * the suffix of &quot;key&quot; w.r.t. &quot;prefix&quot;.
<i class="no-highlight">1563</i>&nbsp;     */
<i class="no-highlight">1564</i>&nbsp;    private static byte[] computeKeySuffix(byte[] prefix, byte[] key) {
<i class="no-highlight">1565</i>&nbsp;
<b class="fc"><i class="no-highlight">1566</i>&nbsp;        int prefixLen = (prefix == null ? 0 : prefix.length);</b>
<i class="no-highlight">1567</i>&nbsp;
<b class="fc"><i class="no-highlight">1568</i>&nbsp;        if (prefixLen == 0) {</b>
<b class="fc"><i class="no-highlight">1569</i>&nbsp;            return key;</b>
<i class="no-highlight">1570</i>&nbsp;        }
<i class="no-highlight">1571</i>&nbsp;
<b class="nc"><i class="no-highlight">1572</i>&nbsp;        int suffixLen = key.length - prefixLen;</b>
<b class="nc"><i class="no-highlight">1573</i>&nbsp;        byte[] ret = new byte[suffixLen];</b>
<b class="nc"><i class="no-highlight">1574</i>&nbsp;        System.arraycopy(key, prefixLen, ret, 0, suffixLen);</b>
<b class="nc"><i class="no-highlight">1575</i>&nbsp;        return ret;</b>
<i class="no-highlight">1576</i>&nbsp;    }
<i class="no-highlight">1577</i>&nbsp;
<i class="no-highlight">1578</i>&nbsp;    /*
<i class="no-highlight">1579</i>&nbsp;     * Iterate over all keys in this IN and recalculate their suffixes based on
<i class="no-highlight">1580</i>&nbsp;     * newPrefix.  If keyVal and idx are supplied, it means that entry[idx] is
<i class="no-highlight">1581</i>&nbsp;     * about to be changed to keyVal so use that instead of
<i class="no-highlight">1582</i>&nbsp;     * entryKeys.get(idx) when computing the new suffixes. If idx is &lt; 0,
<i class="no-highlight">1583</i>&nbsp;     * and keyVal is null, then recalculate suffixes for all entries in this.
<i class="no-highlight">1584</i>&nbsp;     */
<i class="no-highlight">1585</i>&nbsp;    private void recalcSuffixes(
<i class="no-highlight">1586</i>&nbsp;        byte[] newPrefix,
<i class="no-highlight">1587</i>&nbsp;        byte[] key,
<i class="no-highlight">1588</i>&nbsp;        byte[] data,
<i class="no-highlight">1589</i>&nbsp;        int idx) {
<i class="no-highlight">1590</i>&nbsp;
<b class="fc"><i class="no-highlight">1591</i>&nbsp;        for (int i = 0; i &lt; nEntries; i++) {</b>
<i class="no-highlight">1592</i>&nbsp;
<b class="fc"><i class="no-highlight">1593</i>&nbsp;            byte[] curKey = (i == idx ? key : getKey(i));</b>
<i class="no-highlight">1594</i>&nbsp;
<b class="fc"><i class="no-highlight">1595</i>&nbsp;            byte[] curData = null;</b>
<i class="no-highlight">1596</i>&nbsp;
<b class="fc"><i class="no-highlight">1597</i>&nbsp;            if (i == idx) {</b>
<b class="nc"><i class="no-highlight">1598</i>&nbsp;                curData = data;</b>
<b class="fc"><i class="no-highlight">1599</i>&nbsp;            } else if (haveEmbeddedData(i)) {</b>
<b class="nc"><i class="no-highlight">1600</i>&nbsp;                curData = entryKeys.getData(i);</b>
<i class="no-highlight">1601</i>&nbsp;            }
<i class="no-highlight">1602</i>&nbsp;
<b class="fc"><i class="no-highlight">1603</i>&nbsp;            byte[] suffix = computeKeySuffix(newPrefix, curKey);</b>
<i class="no-highlight">1604</i>&nbsp;
<b class="fc"><i class="no-highlight">1605</i>&nbsp;            entryKeys = entryKeys.set(i, suffix, curData, this);</b>
<i class="no-highlight">1606</i>&nbsp;        }
<i class="no-highlight">1607</i>&nbsp;
<b class="fc"><i class="no-highlight">1608</i>&nbsp;        setKeyPrefix(newPrefix);</b>
<b class="fc"><i class="no-highlight">1609</i>&nbsp;    }</b>
<i class="no-highlight">1610</i>&nbsp;
<i class="no-highlight">1611</i>&nbsp;    /**
<i class="no-highlight">1612</i>&nbsp;     * Forces computation of the key prefix, without requiring a split.
<i class="no-highlight">1613</i>&nbsp;     * Is public for use by DbCacheSize.
<i class="no-highlight">1614</i>&nbsp;     */
<i class="no-highlight">1615</i>&nbsp;    public final void recalcKeyPrefix() {
<i class="no-highlight">1616</i>&nbsp;
<b class="nc"><i class="no-highlight">1617</i>&nbsp;        assert(!isBINDelta());</b>
<i class="no-highlight">1618</i>&nbsp;
<b class="nc"><i class="no-highlight">1619</i>&nbsp;        recalcSuffixes(computeKeyPrefix(-1), null, null, -1);</b>
<b class="nc"><i class="no-highlight">1620</i>&nbsp;    }</b>
<i class="no-highlight">1621</i>&nbsp;
<i class="no-highlight">1622</i>&nbsp;    /*
<i class="no-highlight">1623</i>&nbsp;     * Computes a key prefix based on all the keys in &#39;this&#39;.  Return null if
<i class="no-highlight">1624</i>&nbsp;     * the IN is empty or prefixing is not enabled or there is no common
<i class="no-highlight">1625</i>&nbsp;     * prefix for the keys.
<i class="no-highlight">1626</i>&nbsp;     */
<i class="no-highlight">1627</i>&nbsp;    private byte[] computeKeyPrefix(int excludeIdx) {
<i class="no-highlight">1628</i>&nbsp;
<b class="fc"><i class="no-highlight">1629</i>&nbsp;        if (!databaseImpl.getKeyPrefixing() || nEntries &lt;= 1) {</b>
<b class="fc"><i class="no-highlight">1630</i>&nbsp;            return null;</b>
<i class="no-highlight">1631</i>&nbsp;        }
<i class="no-highlight">1632</i>&nbsp;
<b class="nc"><i class="no-highlight">1633</i>&nbsp;        int firstIdx = (excludeIdx == 0) ? 1 : 0;</b>
<b class="nc"><i class="no-highlight">1634</i>&nbsp;        byte[] curPrefixKey = getKey(firstIdx);</b>
<b class="nc"><i class="no-highlight">1635</i>&nbsp;        int prefixLen = curPrefixKey.length;</b>
<i class="no-highlight">1636</i>&nbsp;
<i class="no-highlight">1637</i>&nbsp;        /*
<i class="no-highlight">1638</i>&nbsp;         * Only need to look at first and last entries when keys are ordered
<i class="no-highlight">1639</i>&nbsp;         * byte-by-byte.  But when there is a comparator, keys are not
<i class="no-highlight">1640</i>&nbsp;         * necessarily ordered byte-by-byte.  [#21328]
<i class="no-highlight">1641</i>&nbsp;         */
<i class="no-highlight">1642</i>&nbsp;        boolean byteOrdered;
<i class="no-highlight">1643</i>&nbsp;        if (true) {
<i class="no-highlight">1644</i>&nbsp;            /* Disable optimization for now.  Needs testing. */
<b class="nc"><i class="no-highlight">1645</i>&nbsp;            byteOrdered = false;</b>
<i class="no-highlight">1646</i>&nbsp;        } else {
<i class="no-highlight">1647</i>&nbsp;            byteOrdered = (databaseImpl.getKeyComparator() == null);
<i class="no-highlight">1648</i>&nbsp;        }
<i class="no-highlight">1649</i>&nbsp;
<b class="nc"><i class="no-highlight">1650</i>&nbsp;        if (byteOrdered) {</b>
<b class="nc"><i class="no-highlight">1651</i>&nbsp;            int lastIdx = nEntries - 1;</b>
<b class="nc"><i class="no-highlight">1652</i>&nbsp;            if (lastIdx == excludeIdx) {</b>
<b class="nc"><i class="no-highlight">1653</i>&nbsp;                lastIdx -= 1;</b>
<i class="no-highlight">1654</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1655</i>&nbsp;            if (lastIdx &gt; firstIdx) {</b>
<b class="nc"><i class="no-highlight">1656</i>&nbsp;                byte[] lastKey = getKey(lastIdx);</b>
<b class="nc"><i class="no-highlight">1657</i>&nbsp;                int newPrefixLen = Key.getKeyPrefixLength(</b>
<i class="no-highlight">1658</i>&nbsp;                    curPrefixKey, prefixLen, lastKey);
<i class="no-highlight">1659</i>&nbsp;
<b class="nc"><i class="no-highlight">1660</i>&nbsp;                if (newPrefixLen &lt; prefixLen) {</b>
<b class="nc"><i class="no-highlight">1661</i>&nbsp;                    curPrefixKey = lastKey;</b>
<b class="nc"><i class="no-highlight">1662</i>&nbsp;                    prefixLen = newPrefixLen;</b>
<i class="no-highlight">1663</i>&nbsp;                }
<i class="no-highlight">1664</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1665</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">1666</i>&nbsp;            for (int i = firstIdx + 1; i &lt; nEntries; i++) {</b>
<i class="no-highlight">1667</i>&nbsp;
<b class="nc"><i class="no-highlight">1668</i>&nbsp;                if (i == excludeIdx) {</b>
<b class="nc"><i class="no-highlight">1669</i>&nbsp;                    continue;</b>
<i class="no-highlight">1670</i>&nbsp;                }
<i class="no-highlight">1671</i>&nbsp;
<b class="nc"><i class="no-highlight">1672</i>&nbsp;                byte[] curKey = getKey(i);</b>
<i class="no-highlight">1673</i>&nbsp;
<b class="nc"><i class="no-highlight">1674</i>&nbsp;                int newPrefixLen = Key.getKeyPrefixLength(</b>
<i class="no-highlight">1675</i>&nbsp;                    curPrefixKey, prefixLen, curKey);
<i class="no-highlight">1676</i>&nbsp;
<b class="nc"><i class="no-highlight">1677</i>&nbsp;                if (newPrefixLen &lt; prefixLen) {</b>
<b class="nc"><i class="no-highlight">1678</i>&nbsp;                    curPrefixKey = curKey;</b>
<b class="nc"><i class="no-highlight">1679</i>&nbsp;                    prefixLen = newPrefixLen;</b>
<i class="no-highlight">1680</i>&nbsp;                }
<i class="no-highlight">1681</i>&nbsp;            }
<i class="no-highlight">1682</i>&nbsp;        }
<i class="no-highlight">1683</i>&nbsp;
<b class="nc"><i class="no-highlight">1684</i>&nbsp;        byte[] ret = new byte[prefixLen];</b>
<b class="nc"><i class="no-highlight">1685</i>&nbsp;        System.arraycopy(curPrefixKey, 0, ret, 0, prefixLen);</b>
<i class="no-highlight">1686</i>&nbsp;
<b class="nc"><i class="no-highlight">1687</i>&nbsp;        return ret;</b>
<i class="no-highlight">1688</i>&nbsp;    }
<i class="no-highlight">1689</i>&nbsp;
<i class="no-highlight">1690</i>&nbsp;    /*
<i class="no-highlight">1691</i>&nbsp;     * For debugging.
<i class="no-highlight">1692</i>&nbsp;     */
<i class="no-highlight">1693</i>&nbsp;    final boolean verifyKeyPrefix() {
<i class="no-highlight">1694</i>&nbsp;
<b class="nc"><i class="no-highlight">1695</i>&nbsp;        byte[] computedKeyPrefix = computeKeyPrefix(-1);</b>
<b class="nc"><i class="no-highlight">1696</i>&nbsp;        if (keyPrefix == null) {</b>
<b class="nc"><i class="no-highlight">1697</i>&nbsp;            return computedKeyPrefix == null;</b>
<i class="no-highlight">1698</i>&nbsp;        }
<i class="no-highlight">1699</i>&nbsp;
<b class="nc"><i class="no-highlight">1700</i>&nbsp;        if (computedKeyPrefix == null ||</b>
<i class="no-highlight">1701</i>&nbsp;            computedKeyPrefix.length &lt; keyPrefix.length) {
<b class="nc"><i class="no-highlight">1702</i>&nbsp;            System.out.println(&quot;VerifyKeyPrefix failed&quot;);</b>
<b class="nc"><i class="no-highlight">1703</i>&nbsp;            System.out.println(dumpString(0, false));</b>
<b class="nc"><i class="no-highlight">1704</i>&nbsp;            return false;</b>
<i class="no-highlight">1705</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1706</i>&nbsp;        for (int i = 0; i &lt; keyPrefix.length; i++) {</b>
<b class="nc"><i class="no-highlight">1707</i>&nbsp;            if (keyPrefix[i] != computedKeyPrefix[i]) {</b>
<b class="nc"><i class="no-highlight">1708</i>&nbsp;                System.out.println(&quot;VerifyKeyPrefix failed&quot;);</b>
<b class="nc"><i class="no-highlight">1709</i>&nbsp;                System.out.println(dumpString(0, false));</b>
<b class="nc"><i class="no-highlight">1710</i>&nbsp;                return false;</b>
<i class="no-highlight">1711</i>&nbsp;            }
<i class="no-highlight">1712</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1713</i>&nbsp;        return true;</b>
<i class="no-highlight">1714</i>&nbsp;    }
<i class="no-highlight">1715</i>&nbsp;
<i class="no-highlight">1716</i>&nbsp;    /**
<i class="no-highlight">1717</i>&nbsp;     * Returns whether the given key is greater than or equal to the first key
<i class="no-highlight">1718</i>&nbsp;     * in the IN and less than or equal to the last key in the IN.  This method
<i class="no-highlight">1719</i>&nbsp;     * is used to determine whether a key to be inserted belongs in this IN,
<i class="no-highlight">1720</i>&nbsp;     * without doing a tree search.  If false is returned it is still possible
<i class="no-highlight">1721</i>&nbsp;     * that the key belongs in this IN, but a tree search must be performed to
<i class="no-highlight">1722</i>&nbsp;     * find out.
<i class="no-highlight">1723</i>&nbsp;     */
<i class="no-highlight">1724</i>&nbsp;    public final boolean isKeyInBounds(byte[] key) {
<i class="no-highlight">1725</i>&nbsp;
<b class="nc"><i class="no-highlight">1726</i>&nbsp;        assert(!isBINDelta());</b>
<i class="no-highlight">1727</i>&nbsp;
<b class="nc"><i class="no-highlight">1728</i>&nbsp;        if (nEntries &lt; 2) {</b>
<b class="nc"><i class="no-highlight">1729</i>&nbsp;            return false;</b>
<i class="no-highlight">1730</i>&nbsp;        }
<i class="no-highlight">1731</i>&nbsp;
<b class="nc"><i class="no-highlight">1732</i>&nbsp;        Comparator&lt;byte[]&gt; comparator = getKeyComparator();</b>
<i class="no-highlight">1733</i>&nbsp;        int cmp;
<i class="no-highlight">1734</i>&nbsp;
<i class="no-highlight">1735</i>&nbsp;        /* Compare key given to my first key. */
<b class="nc"><i class="no-highlight">1736</i>&nbsp;        cmp = entryKeys.compareKeys(</b>
<b class="nc"><i class="no-highlight">1737</i>&nbsp;            key, keyPrefix, 0, haveEmbeddedData(0), comparator);</b>
<i class="no-highlight">1738</i>&nbsp;
<b class="nc"><i class="no-highlight">1739</i>&nbsp;        if (cmp &lt; 0) {</b>
<b class="nc"><i class="no-highlight">1740</i>&nbsp;            return false;</b>
<i class="no-highlight">1741</i>&nbsp;        }
<i class="no-highlight">1742</i>&nbsp;
<i class="no-highlight">1743</i>&nbsp;        /* Compare key given to my last key. */
<b class="nc"><i class="no-highlight">1744</i>&nbsp;        int idx =  nEntries - 1;</b>
<b class="nc"><i class="no-highlight">1745</i>&nbsp;        cmp = entryKeys.compareKeys(</b>
<b class="nc"><i class="no-highlight">1746</i>&nbsp;            key, keyPrefix, idx, haveEmbeddedData(idx), comparator);</b>
<i class="no-highlight">1747</i>&nbsp;
<b class="nc"><i class="no-highlight">1748</i>&nbsp;        return cmp &lt;= 0;</b>
<i class="no-highlight">1749</i>&nbsp;    }
<i class="no-highlight">1750</i>&nbsp;
<i class="no-highlight">1751</i>&nbsp;    /**
<i class="no-highlight">1752</i>&nbsp;     * Return the idx&#39;th LSN for this entry.
<i class="no-highlight">1753</i>&nbsp;     *
<i class="no-highlight">1754</i>&nbsp;     * @return the idx&#39;th LSN for this entry.
<i class="no-highlight">1755</i>&nbsp;     */
<i class="no-highlight">1756</i>&nbsp;    public final long getLsn(int idx) {
<i class="no-highlight">1757</i>&nbsp;
<b class="fc"><i class="no-highlight">1758</i>&nbsp;        if (entryLsnLongArray == null) {</b>
<b class="fc"><i class="no-highlight">1759</i>&nbsp;            int offset = idx &lt;&lt; 2;</b>
<b class="fc"><i class="no-highlight">1760</i>&nbsp;            int fileOffset = getFileOffset(offset);</b>
<b class="fc"><i class="no-highlight">1761</i>&nbsp;            if (fileOffset == -1) {</b>
<b class="fc"><i class="no-highlight">1762</i>&nbsp;                return DbLsn.NULL_LSN;</b>
<i class="no-highlight">1763</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">1764</i>&nbsp;                return DbLsn.makeLsn((baseFileNumber +</b>
<b class="fc"><i class="no-highlight">1765</i>&nbsp;                                      getFileNumberOffset(offset)),</b>
<i class="no-highlight">1766</i>&nbsp;                                     fileOffset);
<i class="no-highlight">1767</i>&nbsp;            }
<i class="no-highlight">1768</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">1769</i>&nbsp;            return entryLsnLongArray[idx];</b>
<i class="no-highlight">1770</i>&nbsp;        }
<i class="no-highlight">1771</i>&nbsp;    }
<i class="no-highlight">1772</i>&nbsp;
<i class="no-highlight">1773</i>&nbsp;    /**
<i class="no-highlight">1774</i>&nbsp;     * Set the LSN of the idx&#39;th slot, mark the slot dirty, and update
<i class="no-highlight">1775</i>&nbsp;     * memory consuption. Throw exception if the update is not legitimate.
<i class="no-highlight">1776</i>&nbsp;     */
<i class="no-highlight">1777</i>&nbsp;    public void setLsn(int idx, long lsn) {
<b class="fc"><i class="no-highlight">1778</i>&nbsp;        setLsn(idx, lsn, true);</b>
<b class="fc"><i class="no-highlight">1779</i>&nbsp;    }</b>
<i class="no-highlight">1780</i>&nbsp;
<i class="no-highlight">1781</i>&nbsp;    /**
<i class="no-highlight">1782</i>&nbsp;     * Set the LSN of the idx&#39;th slot, mark the slot dirty, and update
<i class="no-highlight">1783</i>&nbsp;     * memory consuption. If &quot;check&quot; is true, throw exception if the
<i class="no-highlight">1784</i>&nbsp;     * update is not legitimate.
<i class="no-highlight">1785</i>&nbsp;     */
<i class="no-highlight">1786</i>&nbsp;    private void setLsn(int idx, long lsn, boolean check) {
<i class="no-highlight">1787</i>&nbsp;
<b class="fc"><i class="no-highlight">1788</i>&nbsp;        if (!check || shouldUpdateLsn(getLsn(idx), lsn)) {</b>
<i class="no-highlight">1789</i>&nbsp;
<b class="fc"><i class="no-highlight">1790</i>&nbsp;            int oldSize = computeLsnOverhead();</b>
<i class="no-highlight">1791</i>&nbsp;
<i class="no-highlight">1792</i>&nbsp;            /* setLsnInternal can mutate to an array of longs. */
<b class="fc"><i class="no-highlight">1793</i>&nbsp;            setLsnInternal(idx, lsn);</b>
<i class="no-highlight">1794</i>&nbsp;
<b class="fc"><i class="no-highlight">1795</i>&nbsp;            updateMemorySize(computeLsnOverhead() - oldSize);</b>
<b class="fc"><i class="no-highlight">1796</i>&nbsp;            entryStates[idx] |= EntryStates.DIRTY_BIT;</b>
<b class="fc"><i class="no-highlight">1797</i>&nbsp;            setDirty(true);</b>
<i class="no-highlight">1798</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1799</i>&nbsp;    }</b>
<i class="no-highlight">1800</i>&nbsp;
<i class="no-highlight">1801</i>&nbsp;    /*
<i class="no-highlight">1802</i>&nbsp;     * Set the LSN of the idx&#39;th slot. If the current storage for LSNs is the
<i class="no-highlight">1803</i>&nbsp;     * compact one, mutate it to the the non-compact, if necessary.
<i class="no-highlight">1804</i>&nbsp;     */
<i class="no-highlight">1805</i>&nbsp;    final void setLsnInternal(int idx, long value) {
<i class="no-highlight">1806</i>&nbsp;
<i class="no-highlight">1807</i>&nbsp;        /* Will implement this in the future. Note, don&#39;t adjust if mutating.*/
<i class="no-highlight">1808</i>&nbsp;        //maybeAdjustCapacity(offset);
<b class="fc"><i class="no-highlight">1809</i>&nbsp;        if (entryLsnLongArray != null) {</b>
<b class="fc"><i class="no-highlight">1810</i>&nbsp;            entryLsnLongArray[idx] = value;</b>
<b class="fc"><i class="no-highlight">1811</i>&nbsp;            return;</b>
<i class="no-highlight">1812</i>&nbsp;        }
<i class="no-highlight">1813</i>&nbsp;
<b class="fc"><i class="no-highlight">1814</i>&nbsp;        int offset = idx &lt;&lt; 2;</b>
<i class="no-highlight">1815</i>&nbsp;
<b class="fc"><i class="no-highlight">1816</i>&nbsp;        if (value == DbLsn.NULL_LSN) {</b>
<b class="fc"><i class="no-highlight">1817</i>&nbsp;            setFileNumberOffset(offset, (byte) 0);</b>
<b class="fc"><i class="no-highlight">1818</i>&nbsp;            setFileOffset(offset, -1);</b>
<b class="fc"><i class="no-highlight">1819</i>&nbsp;            return;</b>
<i class="no-highlight">1820</i>&nbsp;        }
<i class="no-highlight">1821</i>&nbsp;
<b class="fc"><i class="no-highlight">1822</i>&nbsp;        long thisFileNumber = DbLsn.getFileNumber(value);</b>
<i class="no-highlight">1823</i>&nbsp;
<b class="fc"><i class="no-highlight">1824</i>&nbsp;        if (baseFileNumber == -1) {</b>
<i class="no-highlight">1825</i>&nbsp;            /* First entry. */
<b class="fc"><i class="no-highlight">1826</i>&nbsp;            baseFileNumber = thisFileNumber;</b>
<b class="fc"><i class="no-highlight">1827</i>&nbsp;            setFileNumberOffset(offset, (byte) 0);</b>
<i class="no-highlight">1828</i>&nbsp;
<i class="no-highlight">1829</i>&nbsp;        } else {
<i class="no-highlight">1830</i>&nbsp;
<b class="fc"><i class="no-highlight">1831</i>&nbsp;            if (thisFileNumber &lt; baseFileNumber) {</b>
<b class="fc"><i class="no-highlight">1832</i>&nbsp;                if (!adjustFileNumbers(thisFileNumber)) {</b>
<b class="nc"><i class="no-highlight">1833</i>&nbsp;                    mutateToLongArray(idx, value);</b>
<b class="nc"><i class="no-highlight">1834</i>&nbsp;                    return;</b>
<i class="no-highlight">1835</i>&nbsp;                }
<b class="fc"><i class="no-highlight">1836</i>&nbsp;                baseFileNumber = thisFileNumber;</b>
<i class="no-highlight">1837</i>&nbsp;            }
<i class="no-highlight">1838</i>&nbsp;
<b class="fc"><i class="no-highlight">1839</i>&nbsp;            long fileNumberDifference = thisFileNumber - baseFileNumber;</b>
<b class="fc"><i class="no-highlight">1840</i>&nbsp;            if (fileNumberDifference &gt; Byte.MAX_VALUE) {</b>
<b class="nc"><i class="no-highlight">1841</i>&nbsp;                mutateToLongArray(idx, value);</b>
<b class="nc"><i class="no-highlight">1842</i>&nbsp;                return;</b>
<i class="no-highlight">1843</i>&nbsp;            }
<i class="no-highlight">1844</i>&nbsp;
<b class="fc"><i class="no-highlight">1845</i>&nbsp;            setFileNumberOffset(</b>
<i class="no-highlight">1846</i>&nbsp;                offset, (byte) (thisFileNumber - baseFileNumber));
<i class="no-highlight">1847</i>&nbsp;            //assert getFileNumberOffset(offset) &gt;= 0;
<i class="no-highlight">1848</i>&nbsp;        }
<i class="no-highlight">1849</i>&nbsp;
<b class="fc"><i class="no-highlight">1850</i>&nbsp;        int fileOffset = (int) DbLsn.getFileOffset(value);</b>
<b class="fc"><i class="no-highlight">1851</i>&nbsp;        if (fileOffset &gt; MAX_FILE_OFFSET) {</b>
<b class="fc"><i class="no-highlight">1852</i>&nbsp;            mutateToLongArray(idx, value);</b>
<b class="fc"><i class="no-highlight">1853</i>&nbsp;            return;</b>
<i class="no-highlight">1854</i>&nbsp;        }
<i class="no-highlight">1855</i>&nbsp;
<b class="fc"><i class="no-highlight">1856</i>&nbsp;        setFileOffset(offset, fileOffset);</b>
<i class="no-highlight">1857</i>&nbsp;        //assert getLsn(offset) == value;
<b class="fc"><i class="no-highlight">1858</i>&nbsp;    }</b>
<i class="no-highlight">1859</i>&nbsp;
<i class="no-highlight">1860</i>&nbsp;    private boolean adjustFileNumbers(long newBaseFileNumber) {
<i class="no-highlight">1861</i>&nbsp;
<b class="fc"><i class="no-highlight">1862</i>&nbsp;        long oldBaseFileNumber = baseFileNumber;</b>
<b class="fc"><i class="no-highlight">1863</i>&nbsp;        for (int i = 0;</b>
<b class="fc"><i class="no-highlight">1864</i>&nbsp;             i &lt; entryLsnByteArray.length;</b>
<b class="fc"><i class="no-highlight">1865</i>&nbsp;             i += BYTES_PER_LSN_ENTRY) {</b>
<b class="fc"><i class="no-highlight">1866</i>&nbsp;            if (getFileOffset(i) == -1) {</b>
<b class="nc"><i class="no-highlight">1867</i>&nbsp;                continue;</b>
<i class="no-highlight">1868</i>&nbsp;            }
<i class="no-highlight">1869</i>&nbsp;
<b class="fc"><i class="no-highlight">1870</i>&nbsp;            long curEntryFileNumber =</b>
<b class="fc"><i class="no-highlight">1871</i>&nbsp;                oldBaseFileNumber + getFileNumberOffset(i);</b>
<b class="fc"><i class="no-highlight">1872</i>&nbsp;            long newCurEntryFileNumberOffset =</b>
<i class="no-highlight">1873</i>&nbsp;                (curEntryFileNumber - newBaseFileNumber);
<i class="no-highlight">1874</i>&nbsp;
<b class="fc"><i class="no-highlight">1875</i>&nbsp;            if (newCurEntryFileNumberOffset &gt; Byte.MAX_VALUE) {</b>
<b class="nc"><i class="no-highlight">1876</i>&nbsp;                long undoOffset = oldBaseFileNumber - newBaseFileNumber;</b>
<b class="nc"><i class="no-highlight">1877</i>&nbsp;                for (int j = i - BYTES_PER_LSN_ENTRY;</b>
<b class="nc"><i class="no-highlight">1878</i>&nbsp;                     j &gt;= 0;</b>
<b class="nc"><i class="no-highlight">1879</i>&nbsp;                     j -= BYTES_PER_LSN_ENTRY) {</b>
<b class="nc"><i class="no-highlight">1880</i>&nbsp;                    if (getFileOffset(j) == -1) {</b>
<b class="nc"><i class="no-highlight">1881</i>&nbsp;                        continue;</b>
<i class="no-highlight">1882</i>&nbsp;                    }
<b class="nc"><i class="no-highlight">1883</i>&nbsp;                    setFileNumberOffset</b>
<b class="nc"><i class="no-highlight">1884</i>&nbsp;                        (j, (byte) (getFileNumberOffset(j) - undoOffset));</b>
<i class="no-highlight">1885</i>&nbsp;                    //assert getFileNumberOffset(j) &gt;= 0;
<i class="no-highlight">1886</i>&nbsp;                }
<b class="nc"><i class="no-highlight">1887</i>&nbsp;                return false;</b>
<i class="no-highlight">1888</i>&nbsp;            }
<b class="fc"><i class="no-highlight">1889</i>&nbsp;            setFileNumberOffset(i, (byte) newCurEntryFileNumberOffset);</b>
<i class="no-highlight">1890</i>&nbsp;
<i class="no-highlight">1891</i>&nbsp;            //assert getFileNumberOffset(i) &gt;= 0;
<i class="no-highlight">1892</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1893</i>&nbsp;        return true;</b>
<i class="no-highlight">1894</i>&nbsp;    }
<i class="no-highlight">1895</i>&nbsp;
<i class="no-highlight">1896</i>&nbsp;    private void setFileNumberOffset(int offset, byte fileNumberOffset) {
<b class="fc"><i class="no-highlight">1897</i>&nbsp;        entryLsnByteArray[offset] = fileNumberOffset;</b>
<b class="fc"><i class="no-highlight">1898</i>&nbsp;    }</b>
<i class="no-highlight">1899</i>&nbsp;
<i class="no-highlight">1900</i>&nbsp;    private byte getFileNumberOffset(int offset) {
<b class="fc"><i class="no-highlight">1901</i>&nbsp;        return entryLsnByteArray[offset];</b>
<i class="no-highlight">1902</i>&nbsp;    }
<i class="no-highlight">1903</i>&nbsp;
<i class="no-highlight">1904</i>&nbsp;    private void setFileOffset(int offset, int fileOffset) {
<b class="fc"><i class="no-highlight">1905</i>&nbsp;        put3ByteInt(offset + 1, fileOffset);</b>
<b class="fc"><i class="no-highlight">1906</i>&nbsp;    }</b>
<i class="no-highlight">1907</i>&nbsp;
<i class="no-highlight">1908</i>&nbsp;    private int getFileOffset(int offset) {
<b class="fc"><i class="no-highlight">1909</i>&nbsp;        return get3ByteInt(offset + 1);</b>
<i class="no-highlight">1910</i>&nbsp;    }
<i class="no-highlight">1911</i>&nbsp;
<i class="no-highlight">1912</i>&nbsp;    private void put3ByteInt(int offset, int value) {
<b class="fc"><i class="no-highlight">1913</i>&nbsp;        entryLsnByteArray[offset++] = (byte) value;</b>
<b class="fc"><i class="no-highlight">1914</i>&nbsp;        entryLsnByteArray[offset++] = (byte) (value &gt;&gt;&gt; 8);</b>
<b class="fc"><i class="no-highlight">1915</i>&nbsp;        entryLsnByteArray[offset]   = (byte) (value &gt;&gt;&gt; 16);</b>
<b class="fc"><i class="no-highlight">1916</i>&nbsp;    }</b>
<i class="no-highlight">1917</i>&nbsp;
<i class="no-highlight">1918</i>&nbsp;    private int get3ByteInt(int offset) {
<b class="fc"><i class="no-highlight">1919</i>&nbsp;        int ret = (entryLsnByteArray[offset++] &amp; 0xFF);</b>
<b class="fc"><i class="no-highlight">1920</i>&nbsp;        ret += (entryLsnByteArray[offset++] &amp; 0xFF) &lt;&lt; 8;</b>
<b class="fc"><i class="no-highlight">1921</i>&nbsp;        ret += (entryLsnByteArray[offset]   &amp; 0xFF) &lt;&lt; 16;</b>
<b class="fc"><i class="no-highlight">1922</i>&nbsp;        if (ret == THREE_BYTE_NEGATIVE_ONE) {</b>
<b class="fc"><i class="no-highlight">1923</i>&nbsp;            ret = -1;</b>
<i class="no-highlight">1924</i>&nbsp;        }
<i class="no-highlight">1925</i>&nbsp;
<b class="fc"><i class="no-highlight">1926</i>&nbsp;        return ret;</b>
<i class="no-highlight">1927</i>&nbsp;    }
<i class="no-highlight">1928</i>&nbsp;
<i class="no-highlight">1929</i>&nbsp;    private void mutateToLongArray(int idx, long value) {
<b class="fc"><i class="no-highlight">1930</i>&nbsp;        int nElts = entryLsnByteArray.length &gt;&gt; 2;</b>
<b class="fc"><i class="no-highlight">1931</i>&nbsp;        long[] newArr = new long[nElts];</b>
<b class="fc"><i class="no-highlight">1932</i>&nbsp;        for (int i = 0; i &lt; nElts; i++) {</b>
<b class="fc"><i class="no-highlight">1933</i>&nbsp;            newArr[i] = getLsn(i);</b>
<i class="no-highlight">1934</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1935</i>&nbsp;        newArr[idx] = value;</b>
<b class="fc"><i class="no-highlight">1936</i>&nbsp;        entryLsnLongArray = newArr;</b>
<b class="fc"><i class="no-highlight">1937</i>&nbsp;        entryLsnByteArray = null;</b>
<b class="fc"><i class="no-highlight">1938</i>&nbsp;    }</b>
<i class="no-highlight">1939</i>&nbsp;
<i class="no-highlight">1940</i>&nbsp;    /**
<i class="no-highlight">1941</i>&nbsp;     * For a deferred write database, ensure that information is not lost when
<i class="no-highlight">1942</i>&nbsp;     * a new LSN is assigned.  Also ensures that a transient LSN is not
<i class="no-highlight">1943</i>&nbsp;     * accidentally assigned to a persistent entry.
<i class="no-highlight">1944</i>&nbsp;     *
<i class="no-highlight">1945</i>&nbsp;     * Because this method uses strict checking, prepareForSlotReuse must
<i class="no-highlight">1946</i>&nbsp;     * sometimes be called when a new logical entry is being placed in a slot,
<i class="no-highlight">1947</i>&nbsp;     * e.g., during an IN split or an LN slot reuse.
<i class="no-highlight">1948</i>&nbsp;     *
<i class="no-highlight">1949</i>&nbsp;     * The following transition is a NOOP and the LSN is not set:
<i class="no-highlight">1950</i>&nbsp;     *   Any LSN to same value.
<i class="no-highlight">1951</i>&nbsp;     * The following transitions are allowed and cause the LSN to be set:
<i class="no-highlight">1952</i>&nbsp;     *   Null LSN to transient LSN
<i class="no-highlight">1953</i>&nbsp;     *   Null LSN to persistent LSN
<i class="no-highlight">1954</i>&nbsp;     *   Transient LSN to persistent LSN
<i class="no-highlight">1955</i>&nbsp;     *   Persistent LSN to new persistent LSN
<i class="no-highlight">1956</i>&nbsp;     * The following transitions should not occur and throw an exception:
<i class="no-highlight">1957</i>&nbsp;     *   Transient LSN to null LSN
<i class="no-highlight">1958</i>&nbsp;     *   Transient LSN to new transient LSN
<i class="no-highlight">1959</i>&nbsp;     *   Persistent LSN to null LSN
<i class="no-highlight">1960</i>&nbsp;     *   Persistent LSN to transient LSN
<i class="no-highlight">1961</i>&nbsp;     *
<i class="no-highlight">1962</i>&nbsp;     * The above imply that a transient or null LSN can overwrite only a null
<i class="no-highlight">1963</i>&nbsp;     * LSN.
<i class="no-highlight">1964</i>&nbsp;     */
<i class="no-highlight">1965</i>&nbsp;    private final boolean shouldUpdateLsn(long oldLsn, long newLsn) {
<i class="no-highlight">1966</i>&nbsp;
<i class="no-highlight">1967</i>&nbsp;        /* Save a little computation in packing/updating an unchanged LSN. */
<b class="fc"><i class="no-highlight">1968</i>&nbsp;        if (oldLsn == newLsn) {</b>
<b class="nc"><i class="no-highlight">1969</i>&nbsp;            return false;</b>
<i class="no-highlight">1970</i>&nbsp;        }
<i class="no-highlight">1971</i>&nbsp;        /* The rules for a new null LSN can be broken in a read-only env. */
<b class="fc"><i class="no-highlight">1972</i>&nbsp;        if (newLsn == DbLsn.NULL_LSN &amp;&amp; getEnv().isReadOnly()) {</b>
<b class="nc"><i class="no-highlight">1973</i>&nbsp;            return true;</b>
<i class="no-highlight">1974</i>&nbsp;        }
<i class="no-highlight">1975</i>&nbsp;        /* Enforce LSN update rules.  Assume lsn != oldLsn. */
<b class="fc"><i class="no-highlight">1976</i>&nbsp;        if (databaseImpl.isDeferredWriteMode()) {</b>
<b class="nc"><i class="no-highlight">1977</i>&nbsp;            if (oldLsn != DbLsn.NULL_LSN &amp;&amp; DbLsn.isTransientOrNull(newLsn)) {</b>
<b class="nc"><i class="no-highlight">1978</i>&nbsp;                throw unexpectedState(</b>
<i class="no-highlight">1979</i>&nbsp;                    &quot;DeferredWrite LSN update not allowed&quot; +
<b class="nc"><i class="no-highlight">1980</i>&nbsp;                    &quot; oldLsn = &quot; + DbLsn.getNoFormatString(oldLsn) +</b>
<b class="nc"><i class="no-highlight">1981</i>&nbsp;                    &quot; newLsn = &quot; + DbLsn.getNoFormatString(newLsn));</b>
<i class="no-highlight">1982</i>&nbsp;            }
<i class="no-highlight">1983</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">1984</i>&nbsp;            if (DbLsn.isTransientOrNull(newLsn)) {</b>
<b class="nc"><i class="no-highlight">1985</i>&nbsp;                throw unexpectedState(</b>
<i class="no-highlight">1986</i>&nbsp;                    &quot;LSN update not allowed&quot; +
<b class="nc"><i class="no-highlight">1987</i>&nbsp;                    &quot; oldLsn = &quot; + DbLsn.getNoFormatString(oldLsn) +</b>
<b class="nc"><i class="no-highlight">1988</i>&nbsp;                    &quot; newLsn = &quot; + DbLsn.getNoFormatString(newLsn));</b>
<i class="no-highlight">1989</i>&nbsp;            }
<i class="no-highlight">1990</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1991</i>&nbsp;        return true;</b>
<i class="no-highlight">1992</i>&nbsp;    }
<i class="no-highlight">1993</i>&nbsp;
<i class="no-highlight">1994</i>&nbsp;    /* For unit tests. */
<i class="no-highlight">1995</i>&nbsp;    final long[] getEntryLsnLongArray() {
<b class="nc"><i class="no-highlight">1996</i>&nbsp;        return entryLsnLongArray;</b>
<i class="no-highlight">1997</i>&nbsp;    }
<i class="no-highlight">1998</i>&nbsp;
<i class="no-highlight">1999</i>&nbsp;    /* For unit tests. */
<i class="no-highlight">2000</i>&nbsp;    final byte[] getEntryLsnByteArray() {
<b class="nc"><i class="no-highlight">2001</i>&nbsp;        return entryLsnByteArray;</b>
<i class="no-highlight">2002</i>&nbsp;    }
<i class="no-highlight">2003</i>&nbsp;
<i class="no-highlight">2004</i>&nbsp;    /* For unit tests. */
<i class="no-highlight">2005</i>&nbsp;    final void initEntryLsn(int capacity) {
<b class="nc"><i class="no-highlight">2006</i>&nbsp;        entryLsnLongArray = null;</b>
<b class="nc"><i class="no-highlight">2007</i>&nbsp;        entryLsnByteArray = new byte[capacity &lt;&lt; 2];</b>
<b class="nc"><i class="no-highlight">2008</i>&nbsp;        baseFileNumber = -1;</b>
<b class="nc"><i class="no-highlight">2009</i>&nbsp;    }</b>
<i class="no-highlight">2010</i>&nbsp;
<i class="no-highlight">2011</i>&nbsp;    /* Will implement this in the future. Note, don&#39;t adjust if mutating.*/
<i class="no-highlight">2012</i>&nbsp;    /***
<i class="no-highlight">2013</i>&nbsp;      private void maybeAdjustCapacity(int offset) {
<i class="no-highlight">2014</i>&nbsp;      if (entryLsnLongArray == null) {
<i class="no-highlight">2015</i>&nbsp;      int bytesNeeded = offset + BYTES_PER_LSN_ENTRY;
<i class="no-highlight">2016</i>&nbsp;      int currentBytes = entryLsnByteArray.length;
<i class="no-highlight">2017</i>&nbsp;      if (currentBytes &lt; bytesNeeded) {
<i class="no-highlight">2018</i>&nbsp;      int newBytes = bytesNeeded +
<i class="no-highlight">2019</i>&nbsp;      (GROWTH_INCREMENT * BYTES_PER_LSN_ENTRY);
<i class="no-highlight">2020</i>&nbsp;      byte[] newArr = new byte[newBytes];
<i class="no-highlight">2021</i>&nbsp;      System.arraycopy(entryLsnByteArray, 0, newArr, 0,
<i class="no-highlight">2022</i>&nbsp;      currentBytes);
<i class="no-highlight">2023</i>&nbsp;      entryLsnByteArray = newArr;
<i class="no-highlight">2024</i>&nbsp;      for (int i = currentBytes;
<i class="no-highlight">2025</i>&nbsp;      i &lt; newBytes;
<i class="no-highlight">2026</i>&nbsp;      i += BYTES_PER_LSN_ENTRY) {
<i class="no-highlight">2027</i>&nbsp;      setFileNumberOffset(i, (byte) 0);
<i class="no-highlight">2028</i>&nbsp;      setFileOffset(i, -1);
<i class="no-highlight">2029</i>&nbsp;      }
<i class="no-highlight">2030</i>&nbsp;      }
<i class="no-highlight">2031</i>&nbsp;      } else {
<i class="no-highlight">2032</i>&nbsp;      int currentEntries = entryLsnLongArray.length;
<i class="no-highlight">2033</i>&nbsp;      int idx = offset &gt;&gt; 2;
<i class="no-highlight">2034</i>&nbsp;      if (currentEntries &lt; idx + 1) {
<i class="no-highlight">2035</i>&nbsp;      int newEntries = idx + GROWTH_INCREMENT;
<i class="no-highlight">2036</i>&nbsp;      long[] newArr = new long[newEntries];
<i class="no-highlight">2037</i>&nbsp;      System.arraycopy(entryLsnLongArray, 0, newArr, 0,
<i class="no-highlight">2038</i>&nbsp;      currentEntries);
<i class="no-highlight">2039</i>&nbsp;      entryLsnLongArray = newArr;
<i class="no-highlight">2040</i>&nbsp;      for (int i = currentEntries; i &lt; newEntries; i++) {
<i class="no-highlight">2041</i>&nbsp;      entryLsnLongArray[i] = DbLsn.NULL_LSN;
<i class="no-highlight">2042</i>&nbsp;      }
<i class="no-highlight">2043</i>&nbsp;      }
<i class="no-highlight">2044</i>&nbsp;      }
<i class="no-highlight">2045</i>&nbsp;      }
<i class="no-highlight">2046</i>&nbsp;     ***/
<i class="no-highlight">2047</i>&nbsp;
<i class="no-highlight">2048</i>&nbsp;    /**
<i class="no-highlight">2049</i>&nbsp;     * The last logged size is not stored for UINs.
<i class="no-highlight">2050</i>&nbsp;     */
<i class="no-highlight">2051</i>&nbsp;    boolean isLastLoggedSizeStored(int idx) {
<b class="fc"><i class="no-highlight">2052</i>&nbsp;        return false;</b>
<i class="no-highlight">2053</i>&nbsp;    }
<i class="no-highlight">2054</i>&nbsp;
<i class="no-highlight">2055</i>&nbsp;    boolean mayHaveLastLoggedSizeStored() {
<b class="fc"><i class="no-highlight">2056</i>&nbsp;        return false;</b>
<i class="no-highlight">2057</i>&nbsp;    }
<i class="no-highlight">2058</i>&nbsp;
<i class="no-highlight">2059</i>&nbsp;    /**
<i class="no-highlight">2060</i>&nbsp;     * The last logged size is not stored for UINs.
<i class="no-highlight">2061</i>&nbsp;     */
<i class="no-highlight">2062</i>&nbsp;    public void setLastLoggedSize(int idx, int lastLoggedSize) {
<b class="nc"><i class="no-highlight">2063</i>&nbsp;    }</b>
<i class="no-highlight">2064</i>&nbsp;
<i class="no-highlight">2065</i>&nbsp;    /**
<i class="no-highlight">2066</i>&nbsp;     * The last logged size is not stored for UINs.
<i class="no-highlight">2067</i>&nbsp;     */
<i class="no-highlight">2068</i>&nbsp;    public void clearLastLoggedSize(int idx) {
<b class="nc"><i class="no-highlight">2069</i>&nbsp;    }</b>
<i class="no-highlight">2070</i>&nbsp;
<i class="no-highlight">2071</i>&nbsp;    /**
<i class="no-highlight">2072</i>&nbsp;     * The last logged size is not stored for UINs.
<i class="no-highlight">2073</i>&nbsp;     */
<i class="no-highlight">2074</i>&nbsp;    void setLastLoggedSizeUnconditional(int idx, int lastLoggedSize) {
<b class="nc"><i class="no-highlight">2075</i>&nbsp;    }</b>
<i class="no-highlight">2076</i>&nbsp;
<i class="no-highlight">2077</i>&nbsp;    /**
<i class="no-highlight">2078</i>&nbsp;     * The last logged size is not stored for UINs.
<i class="no-highlight">2079</i>&nbsp;     */
<i class="no-highlight">2080</i>&nbsp;    public int getLastLoggedSize(int idx) {
<b class="fc"><i class="no-highlight">2081</i>&nbsp;        return 0;</b>
<i class="no-highlight">2082</i>&nbsp;    }
<i class="no-highlight">2083</i>&nbsp;
<i class="no-highlight">2084</i>&nbsp;    public void setOffHeapBINId(int idx,
<i class="no-highlight">2085</i>&nbsp;                                int val,
<i class="no-highlight">2086</i>&nbsp;                                boolean pri2,
<i class="no-highlight">2087</i>&nbsp;                                boolean dirty) {
<i class="no-highlight">2088</i>&nbsp;
<b class="nc"><i class="no-highlight">2089</i>&nbsp;        assert getNormalizedLevel() == 2;</b>
<b class="nc"><i class="no-highlight">2090</i>&nbsp;        assert val &gt;= 0;</b>
<i class="no-highlight">2091</i>&nbsp;
<b class="nc"><i class="no-highlight">2092</i>&nbsp;        setOffHeapBINPri2(idx, pri2);</b>
<b class="nc"><i class="no-highlight">2093</i>&nbsp;        setOffHeapBINDirty(idx, dirty);</b>
<i class="no-highlight">2094</i>&nbsp;
<b class="nc"><i class="no-highlight">2095</i>&nbsp;        final long newVal = val + 1;</b>
<b class="nc"><i class="no-highlight">2096</i>&nbsp;        final long oldVal = offHeapBINIds.get(idx);</b>
<i class="no-highlight">2097</i>&nbsp;
<b class="nc"><i class="no-highlight">2098</i>&nbsp;        if (oldVal == newVal) {</b>
<b class="nc"><i class="no-highlight">2099</i>&nbsp;            return;</b>
<i class="no-highlight">2100</i>&nbsp;        }
<i class="no-highlight">2101</i>&nbsp;
<b class="nc"><i class="no-highlight">2102</i>&nbsp;        assert oldVal == 0;</b>
<i class="no-highlight">2103</i>&nbsp;
<b class="nc"><i class="no-highlight">2104</i>&nbsp;        offHeapBINIds = offHeapBINIds.set(idx, newVal, this);</b>
<b class="nc"><i class="no-highlight">2105</i>&nbsp;    }</b>
<i class="no-highlight">2106</i>&nbsp;
<i class="no-highlight">2107</i>&nbsp;    public void clearOffHeapBINId(int idx) {
<i class="no-highlight">2108</i>&nbsp;
<b class="nc"><i class="no-highlight">2109</i>&nbsp;        assert getNormalizedLevel() == 2;</b>
<i class="no-highlight">2110</i>&nbsp;
<b class="nc"><i class="no-highlight">2111</i>&nbsp;        setOffHeapBINPri2(idx, false);</b>
<b class="nc"><i class="no-highlight">2112</i>&nbsp;        setOffHeapBINDirty(idx, false);</b>
<i class="no-highlight">2113</i>&nbsp;
<b class="nc"><i class="no-highlight">2114</i>&nbsp;        final long oldVal = offHeapBINIds.get(idx);</b>
<i class="no-highlight">2115</i>&nbsp;
<b class="nc"><i class="no-highlight">2116</i>&nbsp;        if (oldVal == 0) {</b>
<b class="nc"><i class="no-highlight">2117</i>&nbsp;            return;</b>
<i class="no-highlight">2118</i>&nbsp;        }
<i class="no-highlight">2119</i>&nbsp;
<b class="nc"><i class="no-highlight">2120</i>&nbsp;        offHeapBINIds = offHeapBINIds.set(idx, 0, this);</b>
<i class="no-highlight">2121</i>&nbsp;
<b class="nc"><i class="no-highlight">2122</i>&nbsp;        if (getInListResident() &amp;&amp;</b>
<b class="nc"><i class="no-highlight">2123</i>&nbsp;            getNormalizedLevel() == 2 &amp;&amp;</b>
<b class="nc"><i class="no-highlight">2124</i>&nbsp;            offHeapBINIds.isEmpty()) {</b>
<i class="no-highlight">2125</i>&nbsp;
<b class="nc"><i class="no-highlight">2126</i>&nbsp;            getEvictor().moveToPri1LRU(this);</b>
<i class="no-highlight">2127</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2128</i>&nbsp;    }</b>
<i class="no-highlight">2129</i>&nbsp;
<i class="no-highlight">2130</i>&nbsp;    public int getOffHeapBINId(int idx) {
<b class="fc"><i class="no-highlight">2131</i>&nbsp;        return ((int) offHeapBINIds.get(idx)) - 1;</b>
<i class="no-highlight">2132</i>&nbsp;    }
<i class="no-highlight">2133</i>&nbsp;
<i class="no-highlight">2134</i>&nbsp;    public boolean hasOffHeapBINIds() {
<b class="fc"><i class="no-highlight">2135</i>&nbsp;        return !offHeapBINIds.isEmpty();</b>
<i class="no-highlight">2136</i>&nbsp;    }
<i class="no-highlight">2137</i>&nbsp;
<i class="no-highlight">2138</i>&nbsp;    public long getOffHeapBINIdsMemorySize() {
<b class="nc"><i class="no-highlight">2139</i>&nbsp;        return offHeapBINIds.getMemorySize();</b>
<i class="no-highlight">2140</i>&nbsp;    }
<i class="no-highlight">2141</i>&nbsp;
<i class="no-highlight">2142</i>&nbsp;    private void setOffHeapBINDirty(int idx, boolean val) {
<b class="nc"><i class="no-highlight">2143</i>&nbsp;        if (val) {</b>
<b class="nc"><i class="no-highlight">2144</i>&nbsp;            entryStates[idx] |= EntryStates.OFFHEAP_DIRTY_BIT;</b>
<i class="no-highlight">2145</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">2146</i>&nbsp;            entryStates[idx] &amp;= EntryStates.CLEAR_OFFHEAP_DIRTY_BIT;</b>
<i class="no-highlight">2147</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2148</i>&nbsp;    }</b>
<i class="no-highlight">2149</i>&nbsp;
<i class="no-highlight">2150</i>&nbsp;    public boolean isOffHeapBINDirty(int idx) {
<b class="fc"><i class="no-highlight">2151</i>&nbsp;        return (entryStates[idx] &amp; EntryStates.OFFHEAP_DIRTY_BIT) != 0;</b>
<i class="no-highlight">2152</i>&nbsp;    }
<i class="no-highlight">2153</i>&nbsp;
<i class="no-highlight">2154</i>&nbsp;    private void setOffHeapBINPri2(int idx, boolean val) {
<b class="nc"><i class="no-highlight">2155</i>&nbsp;        if (val) {</b>
<b class="nc"><i class="no-highlight">2156</i>&nbsp;            entryStates[idx] |= EntryStates.OFFHEAP_PRI2_BIT;</b>
<i class="no-highlight">2157</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">2158</i>&nbsp;            entryStates[idx] &amp;= EntryStates.CLEAR_OFFHEAP_PRI2_BIT;</b>
<i class="no-highlight">2159</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2160</i>&nbsp;    }</b>
<i class="no-highlight">2161</i>&nbsp;
<i class="no-highlight">2162</i>&nbsp;    public boolean isOffHeapBINPri2(int idx) {
<b class="fc"><i class="no-highlight">2163</i>&nbsp;        return (entryStates[idx] &amp; EntryStates.OFFHEAP_PRI2_BIT) != 0;</b>
<i class="no-highlight">2164</i>&nbsp;    }
<i class="no-highlight">2165</i>&nbsp;
<i class="no-highlight">2166</i>&nbsp;    public final INTargetRep getTargets() {
<b class="nc"><i class="no-highlight">2167</i>&nbsp;        return entryTargets;</b>
<i class="no-highlight">2168</i>&nbsp;    }
<i class="no-highlight">2169</i>&nbsp;
<i class="no-highlight">2170</i>&nbsp;    /**
<i class="no-highlight">2171</i>&nbsp;     * Sets the idx&#39;th target. No need to make dirty, that state only applies
<i class="no-highlight">2172</i>&nbsp;     * to key and LSN.
<i class="no-highlight">2173</i>&nbsp;     *
<i class="no-highlight">2174</i>&nbsp;     * &lt;p&gt;WARNING: This method does not update the memory budget.  The caller
<i class="no-highlight">2175</i>&nbsp;     * must update the budget.&lt;/p&gt;
<i class="no-highlight">2176</i>&nbsp;     */
<i class="no-highlight">2177</i>&nbsp;    void setTarget(int idx, Node target) {
<i class="no-highlight">2178</i>&nbsp;
<b class="fc"><i class="no-highlight">2179</i>&nbsp;        assert isLatchExclusiveOwner() :</b>
<b class="nc"><i class="no-highlight">2180</i>&nbsp;            &quot;Not latched for write &quot; + getClass().getName() +</b>
<b class="nc"><i class="no-highlight">2181</i>&nbsp;            &quot; id=&quot; + getNodeId();</b>
<i class="no-highlight">2182</i>&nbsp;
<b class="fc"><i class="no-highlight">2183</i>&nbsp;        final Node curChild = entryTargets.get(idx);</b>
<i class="no-highlight">2184</i>&nbsp;
<b class="fc"><i class="no-highlight">2185</i>&nbsp;        entryTargets = entryTargets.set(idx, target, this);</b>
<i class="no-highlight">2186</i>&nbsp;
<b class="fc"><i class="no-highlight">2187</i>&nbsp;        if (target != null &amp;&amp; target.isIN()) {</b>
<b class="fc"><i class="no-highlight">2188</i>&nbsp;            ((IN) target).setParent(this);</b>
<i class="no-highlight">2189</i>&nbsp;        }
<i class="no-highlight">2190</i>&nbsp;
<b class="fc"><i class="no-highlight">2191</i>&nbsp;        if (isUpperIN()) {</b>
<b class="fc"><i class="no-highlight">2192</i>&nbsp;            if (target == null) {</b>
<i class="no-highlight">2193</i>&nbsp;
<i class="no-highlight">2194</i>&nbsp;                /*
<i class="no-highlight">2195</i>&nbsp;                 * If this UIN has just lost its last cached child, set its
<i class="no-highlight">2196</i>&nbsp;                 * hasCachedChildren flag to false and put it back to the
<i class="no-highlight">2197</i>&nbsp;                 * LRU list.
<i class="no-highlight">2198</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">2199</i>&nbsp;                if (curChild != null &amp;&amp;</b>
<b class="fc"><i class="no-highlight">2200</i>&nbsp;                    hasCachedChildrenFlag() &amp;&amp;</b>
<b class="fc"><i class="no-highlight">2201</i>&nbsp;                    !hasCachedChildren()) {</b>
<i class="no-highlight">2202</i>&nbsp;
<b class="fc"><i class="no-highlight">2203</i>&nbsp;                    setHasCachedChildrenFlag(false);</b>
<i class="no-highlight">2204</i>&nbsp;
<b class="fc"><i class="no-highlight">2205</i>&nbsp;                    if (!isDIN()) {</b>
<i class="no-highlight">2206</i>&nbsp;                        if (traceLRU) {
<i class="no-highlight">2207</i>&nbsp;                            LoggerUtils.envLogMsg(
<i class="no-highlight">2208</i>&nbsp;                                traceLevel, getEnv(),
<i class="no-highlight">2209</i>&nbsp;                                Thread.currentThread().getId() + &quot;-&quot; +
<i class="no-highlight">2210</i>&nbsp;                                    Thread.currentThread().getName() +
<i class="no-highlight">2211</i>&nbsp;                                    &quot;-&quot; + getEnv().getName() +
<i class="no-highlight">2212</i>&nbsp;                                    &quot; setTarget(): &quot; +
<i class="no-highlight">2213</i>&nbsp;                                    &quot; Adding UIN &quot; + getNodeId() +
<i class="no-highlight">2214</i>&nbsp;                                    &quot; to LRU after detaching chld &quot; +
<i class="no-highlight">2215</i>&nbsp;                                    ((IN) curChild).getNodeId());
<i class="no-highlight">2216</i>&nbsp;                        }
<b class="fc"><i class="no-highlight">2217</i>&nbsp;                        getEvictor().addBack(this);</b>
<i class="no-highlight">2218</i>&nbsp;                    }
<i class="no-highlight">2219</i>&nbsp;                }
<i class="no-highlight">2220</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">2221</i>&nbsp;                if (curChild == null &amp;&amp;</b>
<b class="fc"><i class="no-highlight">2222</i>&nbsp;                    !hasCachedChildrenFlag()) {</b>
<i class="no-highlight">2223</i>&nbsp;
<b class="fc"><i class="no-highlight">2224</i>&nbsp;                    setHasCachedChildrenFlag(true);</b>
<i class="no-highlight">2225</i>&nbsp;
<i class="no-highlight">2226</i>&nbsp;                    if (traceLRU) {
<i class="no-highlight">2227</i>&nbsp;                        LoggerUtils.envLogMsg(
<i class="no-highlight">2228</i>&nbsp;                            traceLevel, getEnv(),
<i class="no-highlight">2229</i>&nbsp;                            Thread.currentThread().getId() + &quot;-&quot; +
<i class="no-highlight">2230</i>&nbsp;                                Thread.currentThread().getName() +
<i class="no-highlight">2231</i>&nbsp;                                &quot;-&quot; + getEnv().getName() +
<i class="no-highlight">2232</i>&nbsp;                                &quot; setTarget(): &quot; +
<i class="no-highlight">2233</i>&nbsp;                                &quot; Removing UIN &quot; + getNodeId() +
<i class="no-highlight">2234</i>&nbsp;                                &quot; after attaching child &quot; +
<i class="no-highlight">2235</i>&nbsp;                                ((IN) target).getNodeId());
<i class="no-highlight">2236</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">2237</i>&nbsp;                    getEvictor().remove(this);</b>
<i class="no-highlight">2238</i>&nbsp;                }
<i class="no-highlight">2239</i>&nbsp;            }
<i class="no-highlight">2240</i>&nbsp;        }
<b class="fc"><i class="no-highlight">2241</i>&nbsp;    }</b>
<i class="no-highlight">2242</i>&nbsp;
<i class="no-highlight">2243</i>&nbsp;    /**
<i class="no-highlight">2244</i>&nbsp;     * Return the idx&#39;th target.
<i class="no-highlight">2245</i>&nbsp;     *
<i class="no-highlight">2246</i>&nbsp;     * This method does not load children from off-heap cache, so it always
<i class="no-highlight">2247</i>&nbsp;     * returns null when then child is not in main cache. Note that when
<i class="no-highlight">2248</i>&nbsp;     * children are INs (this is not a BIN), when this method returns null it
<i class="no-highlight">2249</i>&nbsp;     * is does not imply that the child is non-dirty, because dirty BINs are
<i class="no-highlight">2250</i>&nbsp;     * stored off-heap. To fetch the current version from off-heap cache in
<i class="no-highlight">2251</i>&nbsp;     * that case, call loadIN instead.
<i class="no-highlight">2252</i>&nbsp;     */
<i class="no-highlight">2253</i>&nbsp;    public final Node getTarget(int idx) {
<b class="fc"><i class="no-highlight">2254</i>&nbsp;        return entryTargets.get(idx);</b>
<i class="no-highlight">2255</i>&nbsp;    }
<i class="no-highlight">2256</i>&nbsp;
<i class="no-highlight">2257</i>&nbsp;    /**
<i class="no-highlight">2258</i>&nbsp;     * Returns the idx-th child of &quot;this&quot; upper IN, fetching the child from
<i class="no-highlight">2259</i>&nbsp;     * the log and attaching it to its parent if it is not already attached.
<i class="no-highlight">2260</i>&nbsp;     * This method is used during tree searches.
<i class="no-highlight">2261</i>&nbsp;     *
<i class="no-highlight">2262</i>&nbsp;     * On entry, the parent must be latched already.
<i class="no-highlight">2263</i>&nbsp;     *
<i class="no-highlight">2264</i>&nbsp;     * If the child must be fetched from the log, the parent is unlatched.
<i class="no-highlight">2265</i>&nbsp;     * After the disk read is done, the parent is relatched. However, due to
<i class="no-highlight">2266</i>&nbsp;     * splits, it may not be the correct parent anymore. If so, the method
<i class="no-highlight">2267</i>&nbsp;     * will return null, and the caller is expected to restart the tree search.
<i class="no-highlight">2268</i>&nbsp;     *
<i class="no-highlight">2269</i>&nbsp;     * On return, the parent will be latched, unless null is returned or an
<i class="no-highlight">2270</i>&nbsp;     * exception is thrown.
<i class="no-highlight">2271</i>&nbsp;     *
<i class="no-highlight">2272</i>&nbsp;     * The &quot;searchKey&quot; param is the key that the caller is looking for. It is
<i class="no-highlight">2273</i>&nbsp;     * used by this method in determining if, after a disk read, &quot;this&quot; is
<i class="no-highlight">2274</i>&nbsp;     * still the correct parent for the child. &quot;searchKey&quot; may be null if the
<i class="no-highlight">2275</i>&nbsp;     * caller is doing a LEFT or RIGHT search.
<i class="no-highlight">2276</i>&nbsp;     */
<i class="no-highlight">2277</i>&nbsp;    final IN fetchINWithNoLatch(int idx,
<i class="no-highlight">2278</i>&nbsp;                                byte [] searchKey,
<i class="no-highlight">2279</i>&nbsp;                                CacheMode cacheMode) {
<b class="fc"><i class="no-highlight">2280</i>&nbsp;        return fetchINWithNoLatch(idx, searchKey, null, cacheMode);</b>
<i class="no-highlight">2281</i>&nbsp;    }
<i class="no-highlight">2282</i>&nbsp;
<i class="no-highlight">2283</i>&nbsp;    /**
<i class="no-highlight">2284</i>&nbsp;     * This variant of fetchIN() takes a SearchResult as a param, instead of
<i class="no-highlight">2285</i>&nbsp;     * an idx (it is used by Tree.getParentINForChildIN()). The ordinal number
<i class="no-highlight">2286</i>&nbsp;     * of the child to fetch is specified by result.index. result.index will
<i class="no-highlight">2287</i>&nbsp;     * be adjusted by this method if, after a disk read, the ordinal number
<i class="no-highlight">2288</i>&nbsp;     * of the child changes due to insertions, deletions or splits in the
<i class="no-highlight">2289</i>&nbsp;     * parent.
<i class="no-highlight">2290</i>&nbsp;     */
<i class="no-highlight">2291</i>&nbsp;    final IN fetchINWithNoLatch(SearchResult result,
<i class="no-highlight">2292</i>&nbsp;                                byte [] searchKey,
<i class="no-highlight">2293</i>&nbsp;                                CacheMode cacheMode) {
<b class="nc"><i class="no-highlight">2294</i>&nbsp;        return fetchINWithNoLatch(result.index, searchKey, result, cacheMode);</b>
<i class="no-highlight">2295</i>&nbsp;    }
<i class="no-highlight">2296</i>&nbsp;
<i class="no-highlight">2297</i>&nbsp;    /**
<i class="no-highlight">2298</i>&nbsp;     * Provides the implementation of the above two methods.
<i class="no-highlight">2299</i>&nbsp;     */
<i class="no-highlight">2300</i>&nbsp;    private IN fetchINWithNoLatch(
<i class="no-highlight">2301</i>&nbsp;        int idx,
<i class="no-highlight">2302</i>&nbsp;        byte [] searchKey,
<i class="no-highlight">2303</i>&nbsp;        SearchResult result,
<i class="no-highlight">2304</i>&nbsp;        CacheMode cacheMode) {
<i class="no-highlight">2305</i>&nbsp;
<b class="fc"><i class="no-highlight">2306</i>&nbsp;        assert(isUpperIN());</b>
<b class="fc"><i class="no-highlight">2307</i>&nbsp;        assert(isLatchOwner());</b>
<i class="no-highlight">2308</i>&nbsp;
<b class="fc"><i class="no-highlight">2309</i>&nbsp;        final EnvironmentImpl envImpl = getEnv();</b>
<b class="fc"><i class="no-highlight">2310</i>&nbsp;        final OffHeapCache ohCache = envImpl.getOffHeapCache();</b>
<i class="no-highlight">2311</i>&nbsp;
<b class="fc"><i class="no-highlight">2312</i>&nbsp;        boolean isMiss = false;</b>
<b class="fc"><i class="no-highlight">2313</i>&nbsp;        boolean success = false;</b>
<i class="no-highlight">2314</i>&nbsp;
<b class="fc"><i class="no-highlight">2315</i>&nbsp;        IN child = (IN)entryTargets.get(idx);</b>
<i class="no-highlight">2316</i>&nbsp;
<b class="fc"><i class="no-highlight">2317</i>&nbsp;        if (child == null) {</b>
<i class="no-highlight">2318</i>&nbsp;
<b class="fc"><i class="no-highlight">2319</i>&nbsp;            final long lsn = getLsn(idx);</b>
<i class="no-highlight">2320</i>&nbsp;
<b class="fc"><i class="no-highlight">2321</i>&nbsp;            if (lsn == DbLsn.NULL_LSN) {</b>
<b class="nc"><i class="no-highlight">2322</i>&nbsp;                throw unexpectedState(makeFetchErrorMsg(</b>
<i class="no-highlight">2323</i>&nbsp;                    &quot;NULL_LSN in upper IN&quot;, lsn, idx));
<i class="no-highlight">2324</i>&nbsp;            }
<i class="no-highlight">2325</i>&nbsp;
<i class="no-highlight">2326</i>&nbsp;            /*
<i class="no-highlight">2327</i>&nbsp;             * For safety we must get a copy of the BIN off-heap bytes while
<i class="no-highlight">2328</i>&nbsp;             * latched, but we can materialize the bytes while unlatched
<i class="no-highlight">2329</i>&nbsp;             * (further below) to reduce the work done while latched.
<i class="no-highlight">2330</i>&nbsp;             */
<b class="fc"><i class="no-highlight">2331</i>&nbsp;            byte[] ohBytes = null;</b>
<i class="no-highlight">2332</i>&nbsp;
<b class="fc"><i class="no-highlight">2333</i>&nbsp;            if (getNormalizedLevel() == 2) {</b>
<b class="fc"><i class="no-highlight">2334</i>&nbsp;                ohBytes = ohCache.getBINBytes(this, idx);</b>
<i class="no-highlight">2335</i>&nbsp;            }
<i class="no-highlight">2336</i>&nbsp;
<b class="fc"><i class="no-highlight">2337</i>&nbsp;            pin();</b>
<i class="no-highlight">2338</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">2339</i>&nbsp;                releaseLatch();</b>
<i class="no-highlight">2340</i>&nbsp;
<b class="fc"><i class="no-highlight">2341</i>&nbsp;                TestHookExecute.doHookIfSet(fetchINHook);</b>
<i class="no-highlight">2342</i>&nbsp;
<b class="fc"><i class="no-highlight">2343</i>&nbsp;                if (ohBytes != null) {</b>
<b class="nc"><i class="no-highlight">2344</i>&nbsp;                    child = ohCache.materializeBIN(envImpl, ohBytes);</b>
<i class="no-highlight">2345</i>&nbsp;                } else {
<b class="fc"><i class="no-highlight">2346</i>&nbsp;                    final WholeEntry wholeEntry = envImpl.getLogManager().</b>
<b class="fc"><i class="no-highlight">2347</i>&nbsp;                        getLogEntryAllowInvisibleAtRecovery(</b>
<b class="fc"><i class="no-highlight">2348</i>&nbsp;                            lsn, getLastLoggedSize(idx));</b>
<i class="no-highlight">2349</i>&nbsp;
<b class="fc"><i class="no-highlight">2350</i>&nbsp;                    final LogEntry logEntry = wholeEntry.getEntry();</b>
<i class="no-highlight">2351</i>&nbsp;
<b class="fc"><i class="no-highlight">2352</i>&nbsp;                    child = (IN) logEntry.getResolvedItem(databaseImpl);</b>
<i class="no-highlight">2353</i>&nbsp;
<b class="fc"><i class="no-highlight">2354</i>&nbsp;                    isMiss = true;</b>
<i class="no-highlight">2355</i>&nbsp;                }
<i class="no-highlight">2356</i>&nbsp;
<b class="fc"><i class="no-highlight">2357</i>&nbsp;                latch(CacheMode.UNCHANGED);</b>
<i class="no-highlight">2358</i>&nbsp;
<i class="no-highlight">2359</i>&nbsp;                /*
<i class="no-highlight">2360</i>&nbsp;                 * The following if statement relies on splits being logged
<i class="no-highlight">2361</i>&nbsp;                 * immediately, or more precisely, the split node and its
<i class="no-highlight">2362</i>&nbsp;                 * new sibling being logged immediately, while both siblings
<i class="no-highlight">2363</i>&nbsp;                 * and their parent are latched exclusively. The reason for
<i class="no-highlight">2364</i>&nbsp;                 * this is as follows: 
<i class="no-highlight">2365</i>&nbsp;                 * 
<i class="no-highlight">2366</i>&nbsp;                 * Let K be the search key. If we are doing a left-deep or
<i class="no-highlight">2367</i>&nbsp;                 * right-deep search, K is -INF or +INF respectively.
<i class="no-highlight">2368</i>&nbsp;                 *
<i class="no-highlight">2369</i>&nbsp;                 * Let P be the parent IN (i.e., &quot;this&quot;) and S be the slot at
<i class="no-highlight">2370</i>&nbsp;                 * the idx position before P was unlatched above. Here, we
<i class="no-highlight">2371</i>&nbsp;                 * view slots as independent objects, not identified by their
<i class="no-highlight">2372</i>&nbsp;                 * position in an IN but by some unique (imaginary) and
<i class="no-highlight">2373</i>&nbsp;                 * immutable id assigned to the slot when it is first inserted
<i class="no-highlight">2374</i>&nbsp;                 * into an IN. 
<i class="no-highlight">2375</i>&nbsp;                 *
<i class="no-highlight">2376</i>&nbsp;                 * Before unlatching P, S was the correct slot to follow down
<i class="no-highlight">2377</i>&nbsp;                 * the tree looking for K. After P is unlatched and then
<i class="no-highlight">2378</i>&nbsp;                 * relatched, let S&#39; be the slot at the idx position, if P
<i class="no-highlight">2379</i>&nbsp;                 * still has an idx position. We consider the following 2 cases:
<i class="no-highlight">2380</i>&nbsp;                 *
<i class="no-highlight">2381</i>&nbsp;                 * 1. S&#39; exists and S&#39;.LSN == S.LSN. Then S and S&#39; are the same
<i class="no-highlight">2382</i>&nbsp;                 * (logical) slot (because two different slots can never cover
<i class="no-highlight">2383</i>&nbsp;                 * overlapping ranges of keys, and as a result, can never point
<i class="no-highlight">2384</i>&nbsp;                 * to the same LSN). Then, S is still the correct slot to take
<i class="no-highlight">2385</i>&nbsp;                 * down the tree, unless the range of keys covered by S has
<i class="no-highlight">2386</i>&nbsp;                 * shrunk while P was unlatched. But the only way for S&#39;s key
<i class="no-highlight">2387</i>&nbsp;                 * range to shrink is for its child IN to split, which could
<i class="no-highlight">2388</i>&nbsp;                 * not have happened because if it did, the before and after
<i class="no-highlight">2389</i>&nbsp;                 * LSNs of S would be different, given that splits are logged
<i class="no-highlight">2390</i>&nbsp;                 * immediately. We conclude that the set of keys covered by
<i class="no-highlight">2391</i>&nbsp;                 * S after P is relatched is the same or a superset of the keys
<i class="no-highlight">2392</i>&nbsp;                 * covered by S before P was unlatched, and thus S (at the idx
<i class="no-highlight">2393</i>&nbsp;                 * position) is still the correct slot to follow.
<i class="no-highlight">2394</i>&nbsp;                 *
<i class="no-highlight">2395</i>&nbsp;                 * 2. There is no idx position in P or S&#39;.LSN != S.LSN. In
<i class="no-highlight">2396</i>&nbsp;                 * this case we cannot be sure if S&#39; (if it exists) is the
<i class="no-highlight">2397</i>&nbsp;                 * the correct slot to follow. So, we (re)search for K in P
<i class="no-highlight">2398</i>&nbsp;                 * to check if P is still the correct parent and find the
<i class="no-highlight">2399</i>&nbsp;                 * correct slot to follow. If this search lands on the 1st or
<i class="no-highlight">2400</i>&nbsp;                 * last slot in P, we may return null because using the key
<i class="no-highlight">2401</i>&nbsp;                 * info contained in P only, we do not know the full range of
<i class="no-highlight">2402</i>&nbsp;                 * keys covered by those two slots. If null is returned, the
<i class="no-highlight">2403</i>&nbsp;                 * caller is expected to restart the tree search from the root.
<i class="no-highlight">2404</i>&nbsp;                 *
<i class="no-highlight">2405</i>&nbsp;                 * Notice that the if conditions are necessary before calling
<i class="no-highlight">2406</i>&nbsp;                 * findEntry(). Without them, we could get into an infinite
<i class="no-highlight">2407</i>&nbsp;                 * loop of search re-tries in the scenario where nothing changes
<i class="no-highlight">2408</i>&nbsp;                 * in the tree and findEntry always lands on the 1st or last
<i class="no-highlight">2409</i>&nbsp;                 * slot in P. The conditions guarantee that we may restart the
<i class="no-highlight">2410</i>&nbsp;                 * tree search only if something changes with S while P is
<i class="no-highlight">2411</i>&nbsp;                 * unlatched (S moves to a different position or a different
<i class="no-highlight">2412</i>&nbsp;                 * IN or it points to a different LSN).
<i class="no-highlight">2413</i>&nbsp;                 * 
<i class="no-highlight">2414</i>&nbsp;                 * Notice also that if P does not split while it is unlatched,
<i class="no-highlight">2415</i>&nbsp;                 * the range of keys covered by P does not change either. This
<i class="no-highlight">2416</i>&nbsp;                 * implies that the correct slot to follow *must* be inside P,
<i class="no-highlight">2417</i>&nbsp;                 * and as a result, the 1st and last slots in P can be trusted.
<i class="no-highlight">2418</i>&nbsp;                 * Unfortunately, however, we have no way to detecting reliably
<i class="no-highlight">2419</i>&nbsp;                 * whether P splits or not.
<i class="no-highlight">2420</i>&nbsp;                 * 
<i class="no-highlight">2421</i>&nbsp;                 * Special care for DBs in DW mode:
<i class="no-highlight">2422</i>&nbsp;                 *
<i class="no-highlight">2423</i>&nbsp;                 * For DBs in DW mode, special care must be taken because
<i class="no-highlight">2424</i>&nbsp;                 * splits are not immediately logged. So, for DW DBs, to avoid
<i class="no-highlight">2425</i>&nbsp;                 * a call to findEntry() we require that not only S&#39;.LSN ==
<i class="no-highlight">2426</i>&nbsp;                 * S.LSN, but also the the child is not cached. These 2
<i class="no-highlight">2427</i>&nbsp;                 * conditions together guarantee that the child did not split
<i class="no-highlight">2428</i>&nbsp;                 * while P was unlatched, because if the child did split, it
<i class="no-highlight">2429</i>&nbsp;                 * was fetched and cached first, so after P is relatched,
<i class="no-highlight">2430</i>&nbsp;                 * either the child would be still cached, or if it was evicted
<i class="no-highlight">2431</i>&nbsp;                 * after the split, S.LSN would have changed.
<i class="no-highlight">2432</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">2433</i>&nbsp;                if (idx &gt;= nEntries ||</b>
<b class="fc"><i class="no-highlight">2434</i>&nbsp;                    getLsn(idx) != lsn ||</b>
<b class="fc"><i class="no-highlight">2435</i>&nbsp;                    (databaseImpl.isDeferredWriteMode() &amp;&amp;</b>
<b class="nc"><i class="no-highlight">2436</i>&nbsp;                     entryTargets.get(idx) != null)) {</b>
<i class="no-highlight">2437</i>&nbsp;
<b class="nc"><i class="no-highlight">2438</i>&nbsp;                    if (searchKey == null) {</b>
<b class="nc"><i class="no-highlight">2439</i>&nbsp;                        return null;</b>
<i class="no-highlight">2440</i>&nbsp;                    }
<i class="no-highlight">2441</i>&nbsp;
<b class="nc"><i class="no-highlight">2442</i>&nbsp;                    idx = findEntry(searchKey, false, false);</b>
<i class="no-highlight">2443</i>&nbsp;
<b class="nc"><i class="no-highlight">2444</i>&nbsp;                    if ((idx == 0 || idx == nEntries - 1) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">2445</i>&nbsp;                        !isKeyInBounds(searchKey)) {</b>
<b class="nc"><i class="no-highlight">2446</i>&nbsp;                        return null;</b>
<i class="no-highlight">2447</i>&nbsp;                    }
<i class="no-highlight">2448</i>&nbsp;                }
<i class="no-highlight">2449</i>&nbsp;
<b class="fc"><i class="no-highlight">2450</i>&nbsp;                if (result != null) {</b>
<b class="nc"><i class="no-highlight">2451</i>&nbsp;                    result.index = idx;</b>
<i class="no-highlight">2452</i>&nbsp;                }
<i class="no-highlight">2453</i>&nbsp;
<i class="no-highlight">2454</i>&nbsp;                /*
<i class="no-highlight">2455</i>&nbsp;                 * &quot;this&quot; is still the correct parent and &quot;idx&quot; points to the
<i class="no-highlight">2456</i>&nbsp;                 * correct slot to follow for the search down the tree. But
<i class="no-highlight">2457</i>&nbsp;                 * what we fetched from the log may be out-of-date by now
<i class="no-highlight">2458</i>&nbsp;                 * (because it was fetched and then updated by other threads)
<i class="no-highlight">2459</i>&nbsp;                 * or it may not be the correct child anymore (&quot;idx&quot; was
<i class="no-highlight">2460</i>&nbsp;                 * changed by the findEntry() call above). We check 5 cases:
<i class="no-highlight">2461</i>&nbsp;                 *
<i class="no-highlight">2462</i>&nbsp;                 * (a) There is already a cached child at the &quot;idx&quot; position.
<i class="no-highlight">2463</i>&nbsp;                 * In this case, we return whatever is there because it has to
<i class="no-highlight">2464</i>&nbsp;                 * be the most recent version of the appropriate child node.
<i class="no-highlight">2465</i>&nbsp;                 * This is true even when a split or reverse split occurred.
<i class="no-highlight">2466</i>&nbsp;                 * The check for isKeyInBounds above is critical in that case.
<i class="no-highlight">2467</i>&nbsp;                 *
<i class="no-highlight">2468</i>&nbsp;                 * (b) There is no cached child at the &quot;idx&quot; slot, but the slot
<i class="no-highlight">2469</i>&nbsp;                 * LSN is not the same as the LSN we read from the log. This is
<i class="no-highlight">2470</i>&nbsp;                 * the case if &quot;idx&quot; was changed by findEntry() or other
<i class="no-highlight">2471</i>&nbsp;                 * threads fetched the same child as this thread, updated it,
<i class="no-highlight">2472</i>&nbsp;                 * and then evicted it. The child we fetched is obsolete and
<i class="no-highlight">2473</i>&nbsp;                 * should not be attached. For simplicity, we just return null
<i class="no-highlight">2474</i>&nbsp;                 * in this (quite rare) case.
<i class="no-highlight">2475</i>&nbsp;                 *
<i class="no-highlight">2476</i>&nbsp;                 * (c) We loaded the BIN from off-heap cache and, similar to
<i class="no-highlight">2477</i>&nbsp;                 * case (b), another thread has loaded the same child, modified
<i class="no-highlight">2478</i>&nbsp;                 * it, and then evicted it, placing it off-heap again. It&#39;s LSN
<i class="no-highlight">2479</i>&nbsp;                 * did not change because it wasn&#39;t logged. We determine
<i class="no-highlight">2480</i>&nbsp;                 * whether the off-heap BIN has changed, and if so then
<i class="no-highlight">2481</i>&nbsp;                 * null is returned. This is also rare.
<i class="no-highlight">2482</i>&nbsp;                 *
<i class="no-highlight">2483</i>&nbsp;                 * (d) The child was loaded from disk (not off-heap cache) but
<i class="no-highlight">2484</i>&nbsp;                 * an off-heap cache entry for this BIN has appeared. Another
<i class="no-highlight">2485</i>&nbsp;                 * thread loaded the BIN from disk and then it was moved
<i class="no-highlight">2486</i>&nbsp;                 * off-heap, possibly after it was modified. We should use the
<i class="no-highlight">2487</i>&nbsp;                 * off-heap version and for simplicity we return null. This is
<i class="no-highlight">2488</i>&nbsp;                 * also rare.
<i class="no-highlight">2489</i>&nbsp;                 *
<i class="no-highlight">2490</i>&nbsp;                 * (e) Otherwise, we attach the fetched/loaded child to the
<i class="no-highlight">2491</i>&nbsp;                 * parent.
<i class="no-highlight">2492</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">2493</i>&nbsp;                if (entryTargets.get(idx) != null) {</b>
<b class="nc"><i class="no-highlight">2494</i>&nbsp;                    child = (IN) entryTargets.get(idx);</b>
<i class="no-highlight">2495</i>&nbsp;
<b class="fc"><i class="no-highlight">2496</i>&nbsp;                } else if (getLsn(idx) != lsn) {</b>
<b class="nc"><i class="no-highlight">2497</i>&nbsp;                    return null;</b>
<i class="no-highlight">2498</i>&nbsp;
<b class="fc"><i class="no-highlight">2499</i>&nbsp;                } else if (ohBytes != null &amp;&amp;</b>
<b class="nc"><i class="no-highlight">2500</i>&nbsp;                           ohCache.haveBINBytesChanged(this, idx, ohBytes)) {</b>
<b class="nc"><i class="no-highlight">2501</i>&nbsp;                    return null;</b>
<i class="no-highlight">2502</i>&nbsp;
<b class="fc"><i class="no-highlight">2503</i>&nbsp;                } else if (ohBytes == null &amp;&amp;</b>
<b class="fc"><i class="no-highlight">2504</i>&nbsp;                           getOffHeapBINId(idx) &gt;= 0) {</b>
<b class="nc"><i class="no-highlight">2505</i>&nbsp;                    return null;</b>
<i class="no-highlight">2506</i>&nbsp;
<i class="no-highlight">2507</i>&nbsp;                } else {
<b class="fc"><i class="no-highlight">2508</i>&nbsp;                    child.latchNoUpdateLRU(databaseImpl);</b>
<i class="no-highlight">2509</i>&nbsp;
<b class="fc"><i class="no-highlight">2510</i>&nbsp;                    if (ohBytes != null) {</b>
<b class="nc"><i class="no-highlight">2511</i>&nbsp;                        child.postLoadInit(this, idx);</b>
<i class="no-highlight">2512</i>&nbsp;                    } else {
<b class="fc"><i class="no-highlight">2513</i>&nbsp;                        child.postFetchInit(databaseImpl, lsn);</b>
<i class="no-highlight">2514</i>&nbsp;                    }
<i class="no-highlight">2515</i>&nbsp;
<b class="fc"><i class="no-highlight">2516</i>&nbsp;                    attachNode(idx, child, null);</b>
<i class="no-highlight">2517</i>&nbsp;
<b class="fc"><i class="no-highlight">2518</i>&nbsp;                    child.releaseLatch();</b>
<i class="no-highlight">2519</i>&nbsp;                }
<i class="no-highlight">2520</i>&nbsp;
<b class="fc"><i class="no-highlight">2521</i>&nbsp;                success = true;</b>
<i class="no-highlight">2522</i>&nbsp;
<b class="nc"><i class="no-highlight">2523</i>&nbsp;            } catch (FileNotFoundException e) {</b>
<b class="nc"><i class="no-highlight">2524</i>&nbsp;                throw new EnvironmentFailureException(</b>
<i class="no-highlight">2525</i>&nbsp;                    envImpl, EnvironmentFailureReason.LOG_FILE_NOT_FOUND,
<b class="nc"><i class="no-highlight">2526</i>&nbsp;                    makeFetchErrorMsg(null, lsn, idx), e);</b>
<i class="no-highlight">2527</i>&nbsp;
<b class="nc"><i class="no-highlight">2528</i>&nbsp;            } catch (EnvironmentFailureException e) {</b>
<b class="nc"><i class="no-highlight">2529</i>&nbsp;                e.addErrorMessage(makeFetchErrorMsg(null, lsn, idx));</b>
<b class="nc"><i class="no-highlight">2530</i>&nbsp;                throw e;</b>
<i class="no-highlight">2531</i>&nbsp;
<b class="nc"><i class="no-highlight">2532</i>&nbsp;            } catch (RuntimeException e) {</b>
<b class="nc"><i class="no-highlight">2533</i>&nbsp;                throw new EnvironmentFailureException(</b>
<i class="no-highlight">2534</i>&nbsp;                    envImpl, EnvironmentFailureReason.LOG_INTEGRITY,
<b class="nc"><i class="no-highlight">2535</i>&nbsp;                    makeFetchErrorMsg(e.toString(), lsn, idx), e);</b>
<i class="no-highlight">2536</i>&nbsp;            } finally {
<i class="no-highlight">2537</i>&nbsp;                /*
<i class="no-highlight">2538</i>&nbsp;                 * Release the parent latch if null is being returned. In this
<i class="no-highlight">2539</i>&nbsp;                 * case, the parent was unlatched earlier during the disk read,
<i class="no-highlight">2540</i>&nbsp;                 * and as a result, the caller cannot make any assumptions
<i class="no-highlight">2541</i>&nbsp;                 * about the state of the parent.
<i class="no-highlight">2542</i>&nbsp;                 *
<i class="no-highlight">2543</i>&nbsp;                 * If we are returning or throwing out of this try block, the
<i class="no-highlight">2544</i>&nbsp;                 * parent may or may not be latched. So, only release the latch
<i class="no-highlight">2545</i>&nbsp;                 * if it is currently held.
<i class="no-highlight">2546</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">2547</i>&nbsp;                if (!success) {</b>
<b class="nc"><i class="no-highlight">2548</i>&nbsp;                    if (child != null) {</b>
<b class="nc"><i class="no-highlight">2549</i>&nbsp;                        child.incFetchStats(envImpl, isMiss);</b>
<i class="no-highlight">2550</i>&nbsp;                    }
<b class="nc"><i class="no-highlight">2551</i>&nbsp;                    releaseLatchIfOwner();</b>
<i class="no-highlight">2552</i>&nbsp;                }
<i class="no-highlight">2553</i>&nbsp;
<b class="fc"><i class="no-highlight">2554</i>&nbsp;                unpin();</b>
<b class="fc"><i class="no-highlight">2555</i>&nbsp;            }</b>
<i class="no-highlight">2556</i>&nbsp;        }
<i class="no-highlight">2557</i>&nbsp;
<b class="fc"><i class="no-highlight">2558</i>&nbsp;        assert(hasCachedChildren() == hasCachedChildrenFlag());</b>
<i class="no-highlight">2559</i>&nbsp;
<b class="fc"><i class="no-highlight">2560</i>&nbsp;        child.incFetchStats(envImpl, isMiss);</b>
<i class="no-highlight">2561</i>&nbsp;
<b class="fc"><i class="no-highlight">2562</i>&nbsp;        return child;</b>
<i class="no-highlight">2563</i>&nbsp;    }
<i class="no-highlight">2564</i>&nbsp;
<i class="no-highlight">2565</i>&nbsp;    /**
<i class="no-highlight">2566</i>&nbsp;     * Returns the idx-th child of &quot;this&quot; upper IN, fetching the child from
<i class="no-highlight">2567</i>&nbsp;     * the log and attaching it to its parent if it is not already attached.
<i class="no-highlight">2568</i>&nbsp;     *
<i class="no-highlight">2569</i>&nbsp;     * On entry, the parent must be EX-latched already and it stays EX-latched
<i class="no-highlight">2570</i>&nbsp;     * for the duration of this method and on return (even in case of
<i class="no-highlight">2571</i>&nbsp;     * exceptions).
<i class="no-highlight">2572</i>&nbsp;     *
<i class="no-highlight">2573</i>&nbsp;     * @param idx The slot of the child to fetch.
<i class="no-highlight">2574</i>&nbsp;     */
<i class="no-highlight">2575</i>&nbsp;    public IN fetchIN(int idx, CacheMode cacheMode) {
<i class="no-highlight">2576</i>&nbsp;
<b class="nc"><i class="no-highlight">2577</i>&nbsp;        assert(isUpperIN());</b>
<b class="nc"><i class="no-highlight">2578</i>&nbsp;        if (!isLatchExclusiveOwner()) {</b>
<b class="nc"><i class="no-highlight">2579</i>&nbsp;            throw unexpectedState(&quot;EX-latch not held before fetch&quot;);</b>
<i class="no-highlight">2580</i>&nbsp;        }
<i class="no-highlight">2581</i>&nbsp;
<b class="nc"><i class="no-highlight">2582</i>&nbsp;        final EnvironmentImpl envImpl = getEnv();</b>
<b class="nc"><i class="no-highlight">2583</i>&nbsp;        final OffHeapCache ohCache = envImpl.getOffHeapCache();</b>
<b class="nc"><i class="no-highlight">2584</i>&nbsp;        boolean isMiss = false;</b>
<i class="no-highlight">2585</i>&nbsp;
<b class="nc"><i class="no-highlight">2586</i>&nbsp;        IN child = (IN) entryTargets.get(idx);</b>
<i class="no-highlight">2587</i>&nbsp;
<b class="nc"><i class="no-highlight">2588</i>&nbsp;        if (child == null) {</b>
<i class="no-highlight">2589</i>&nbsp;
<b class="nc"><i class="no-highlight">2590</i>&nbsp;            final long lsn = getLsn(idx);</b>
<i class="no-highlight">2591</i>&nbsp;
<b class="nc"><i class="no-highlight">2592</i>&nbsp;            if (lsn == DbLsn.NULL_LSN) {</b>
<b class="nc"><i class="no-highlight">2593</i>&nbsp;                throw unexpectedState(</b>
<b class="nc"><i class="no-highlight">2594</i>&nbsp;                    makeFetchErrorMsg(&quot;NULL_LSN in upper IN&quot;, lsn, idx));</b>
<i class="no-highlight">2595</i>&nbsp;            }
<i class="no-highlight">2596</i>&nbsp;
<i class="no-highlight">2597</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">2598</i>&nbsp;                byte[] ohBytes = null;</b>
<i class="no-highlight">2599</i>&nbsp;
<b class="nc"><i class="no-highlight">2600</i>&nbsp;                if (getNormalizedLevel() == 2) {</b>
<b class="nc"><i class="no-highlight">2601</i>&nbsp;                    ohBytes = ohCache.getBINBytes(this, idx);</b>
<b class="nc"><i class="no-highlight">2602</i>&nbsp;                    if (ohBytes != null) {</b>
<b class="nc"><i class="no-highlight">2603</i>&nbsp;                        child = ohCache.materializeBIN(envImpl, ohBytes);</b>
<i class="no-highlight">2604</i>&nbsp;                    }
<i class="no-highlight">2605</i>&nbsp;                }
<i class="no-highlight">2606</i>&nbsp;
<b class="nc"><i class="no-highlight">2607</i>&nbsp;                if (child == null) {</b>
<b class="nc"><i class="no-highlight">2608</i>&nbsp;                    final WholeEntry wholeEntry = envImpl.getLogManager().</b>
<b class="nc"><i class="no-highlight">2609</i>&nbsp;                        getLogEntryAllowInvisibleAtRecovery(</b>
<b class="nc"><i class="no-highlight">2610</i>&nbsp;                            lsn, getLastLoggedSize(idx));</b>
<i class="no-highlight">2611</i>&nbsp;
<b class="nc"><i class="no-highlight">2612</i>&nbsp;                    final LogEntry logEntry = wholeEntry.getEntry();</b>
<b class="nc"><i class="no-highlight">2613</i>&nbsp;                    child = (IN) logEntry.getResolvedItem(databaseImpl);</b>
<i class="no-highlight">2614</i>&nbsp;
<b class="nc"><i class="no-highlight">2615</i>&nbsp;                    isMiss = true;</b>
<i class="no-highlight">2616</i>&nbsp;                }
<i class="no-highlight">2617</i>&nbsp;
<b class="nc"><i class="no-highlight">2618</i>&nbsp;                child.latchNoUpdateLRU(databaseImpl);</b>
<i class="no-highlight">2619</i>&nbsp;
<b class="nc"><i class="no-highlight">2620</i>&nbsp;                if (ohBytes != null) {</b>
<b class="nc"><i class="no-highlight">2621</i>&nbsp;                    child.postLoadInit(this, idx);</b>
<i class="no-highlight">2622</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">2623</i>&nbsp;                    child.postFetchInit(databaseImpl, lsn);</b>
<i class="no-highlight">2624</i>&nbsp;                }
<i class="no-highlight">2625</i>&nbsp;
<b class="nc"><i class="no-highlight">2626</i>&nbsp;                attachNode(idx, child, null);</b>
<i class="no-highlight">2627</i>&nbsp;
<b class="nc"><i class="no-highlight">2628</i>&nbsp;                child.releaseLatch();</b>
<i class="no-highlight">2629</i>&nbsp;
<b class="nc"><i class="no-highlight">2630</i>&nbsp;            } catch (FileNotFoundException e) {</b>
<b class="nc"><i class="no-highlight">2631</i>&nbsp;                throw new EnvironmentFailureException(</b>
<i class="no-highlight">2632</i>&nbsp;                    envImpl, EnvironmentFailureReason.LOG_FILE_NOT_FOUND,
<b class="nc"><i class="no-highlight">2633</i>&nbsp;                    makeFetchErrorMsg(null, lsn, idx), e);</b>
<i class="no-highlight">2634</i>&nbsp;
<b class="nc"><i class="no-highlight">2635</i>&nbsp;            } catch (EnvironmentFailureException e) {</b>
<b class="nc"><i class="no-highlight">2636</i>&nbsp;                e.addErrorMessage(makeFetchErrorMsg(null, lsn, idx));</b>
<b class="nc"><i class="no-highlight">2637</i>&nbsp;                throw e;</b>
<i class="no-highlight">2638</i>&nbsp;
<b class="nc"><i class="no-highlight">2639</i>&nbsp;            } catch (RuntimeException e) {</b>
<b class="nc"><i class="no-highlight">2640</i>&nbsp;                throw new EnvironmentFailureException(</b>
<i class="no-highlight">2641</i>&nbsp;                    envImpl, EnvironmentFailureReason.LOG_INTEGRITY,
<b class="nc"><i class="no-highlight">2642</i>&nbsp;                    makeFetchErrorMsg(e.toString(), lsn, idx), e);</b>
<b class="nc"><i class="no-highlight">2643</i>&nbsp;            }</b>
<i class="no-highlight">2644</i>&nbsp;        }
<i class="no-highlight">2645</i>&nbsp;
<b class="nc"><i class="no-highlight">2646</i>&nbsp;        assert(hasCachedChildren() == hasCachedChildrenFlag());</b>
<i class="no-highlight">2647</i>&nbsp;
<b class="nc"><i class="no-highlight">2648</i>&nbsp;        child.incFetchStats(envImpl, isMiss);</b>
<i class="no-highlight">2649</i>&nbsp;
<b class="nc"><i class="no-highlight">2650</i>&nbsp;        return child;</b>
<i class="no-highlight">2651</i>&nbsp;    }
<i class="no-highlight">2652</i>&nbsp;
<i class="no-highlight">2653</i>&nbsp;    /**
<i class="no-highlight">2654</i>&nbsp;     * Returns the idx-th child of &quot;this&quot; upper IN, loading the child from
<i class="no-highlight">2655</i>&nbsp;     * off-heap and attaching it to its parent if it is not already attached
<i class="no-highlight">2656</i>&nbsp;     * and is cached off-heap. This method does not fetch from disk, and will
<i class="no-highlight">2657</i>&nbsp;     * return null if the child is not in the main or off-heap cache.
<i class="no-highlight">2658</i>&nbsp;     *
<i class="no-highlight">2659</i>&nbsp;     * On entry, the parent must be EX-latched already and it stays EX-latched
<i class="no-highlight">2660</i>&nbsp;     * for the duration of this method and on return (even in case of
<i class="no-highlight">2661</i>&nbsp;     * exceptions).
<i class="no-highlight">2662</i>&nbsp;     *
<i class="no-highlight">2663</i>&nbsp;     * @param idx The slot of the child to fetch.
<i class="no-highlight">2664</i>&nbsp;     *
<i class="no-highlight">2665</i>&nbsp;     * @return null if the LN is not in the main or off-heap cache.
<i class="no-highlight">2666</i>&nbsp;     */
<i class="no-highlight">2667</i>&nbsp;    public IN loadIN(int idx, CacheMode cacheMode) {
<i class="no-highlight">2668</i>&nbsp;
<b class="fc"><i class="no-highlight">2669</i>&nbsp;        assert(isUpperIN());</b>
<b class="fc"><i class="no-highlight">2670</i>&nbsp;        if (!isLatchExclusiveOwner()) {</b>
<b class="nc"><i class="no-highlight">2671</i>&nbsp;            throw unexpectedState(&quot;EX-latch not held before load&quot;);</b>
<i class="no-highlight">2672</i>&nbsp;        }
<i class="no-highlight">2673</i>&nbsp;
<b class="fc"><i class="no-highlight">2674</i>&nbsp;        IN child = (IN) entryTargets.get(idx);</b>
<i class="no-highlight">2675</i>&nbsp;
<b class="fc"><i class="no-highlight">2676</i>&nbsp;        if (child != null) {</b>
<b class="fc"><i class="no-highlight">2677</i>&nbsp;            return child;</b>
<i class="no-highlight">2678</i>&nbsp;        }
<i class="no-highlight">2679</i>&nbsp;
<b class="nc"><i class="no-highlight">2680</i>&nbsp;        if (getNormalizedLevel() != 2) {</b>
<b class="nc"><i class="no-highlight">2681</i>&nbsp;            return null;</b>
<i class="no-highlight">2682</i>&nbsp;        }
<i class="no-highlight">2683</i>&nbsp;
<b class="nc"><i class="no-highlight">2684</i>&nbsp;        final EnvironmentImpl envImpl = getEnv();</b>
<b class="nc"><i class="no-highlight">2685</i>&nbsp;        final OffHeapCache ohCache = envImpl.getOffHeapCache();</b>
<i class="no-highlight">2686</i>&nbsp;
<b class="nc"><i class="no-highlight">2687</i>&nbsp;        final long lsn = getLsn(idx);</b>
<i class="no-highlight">2688</i>&nbsp;
<i class="no-highlight">2689</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">2690</i>&nbsp;            final byte[] ohBytes = ohCache.getBINBytes(this, idx);</b>
<b class="nc"><i class="no-highlight">2691</i>&nbsp;            if (ohBytes == null) {</b>
<b class="nc"><i class="no-highlight">2692</i>&nbsp;                return null;</b>
<i class="no-highlight">2693</i>&nbsp;            }
<i class="no-highlight">2694</i>&nbsp;
<b class="nc"><i class="no-highlight">2695</i>&nbsp;            child = ohCache.materializeBIN(envImpl, ohBytes);</b>
<b class="nc"><i class="no-highlight">2696</i>&nbsp;            child.latchNoUpdateLRU(databaseImpl);</b>
<b class="nc"><i class="no-highlight">2697</i>&nbsp;            child.postLoadInit(this, idx);</b>
<b class="nc"><i class="no-highlight">2698</i>&nbsp;            attachNode(idx, child, null);</b>
<b class="nc"><i class="no-highlight">2699</i>&nbsp;            child.releaseLatch();</b>
<i class="no-highlight">2700</i>&nbsp;
<b class="nc"><i class="no-highlight">2701</i>&nbsp;            return child;</b>
<i class="no-highlight">2702</i>&nbsp;
<b class="nc"><i class="no-highlight">2703</i>&nbsp;        } catch (RuntimeException e) {</b>
<b class="nc"><i class="no-highlight">2704</i>&nbsp;            throw new EnvironmentFailureException(</b>
<i class="no-highlight">2705</i>&nbsp;                envImpl, EnvironmentFailureReason.LOG_INTEGRITY,
<b class="nc"><i class="no-highlight">2706</i>&nbsp;                makeFetchErrorMsg(e.toString(), lsn, idx), e);</b>
<i class="no-highlight">2707</i>&nbsp;        }
<i class="no-highlight">2708</i>&nbsp;    }
<i class="no-highlight">2709</i>&nbsp;
<i class="no-highlight">2710</i>&nbsp;    /**
<i class="no-highlight">2711</i>&nbsp;     * Returns the target of the idx&#39;th entry, fetching from disk if necessary.
<i class="no-highlight">2712</i>&nbsp;     *
<i class="no-highlight">2713</i>&nbsp;     * Null is returned in the following cases:
<i class="no-highlight">2714</i>&nbsp;     *
<i class="no-highlight">2715</i>&nbsp;     * 1. if the LSN is null and the KnownDeleted flag is set; or
<i class="no-highlight">2716</i>&nbsp;     * 2. if the LSN&#39;s file has been cleaned and:
<i class="no-highlight">2717</i>&nbsp;     *    a. the PendingDeleted or KnownDeleted flag is set, or
<i class="no-highlight">2718</i>&nbsp;     *    b. the entry is &quot;probably expired&quot;.
<i class="no-highlight">2719</i>&nbsp;     *
<i class="no-highlight">2720</i>&nbsp;     * Note that checking for PD/KD before calling this method is not
<i class="no-highlight">2721</i>&nbsp;     * sufficient to ensure that null is not returned, because null is also
<i class="no-highlight">2722</i>&nbsp;     * returned for expired records.
<i class="no-highlight">2723</i>&nbsp;     *
<i class="no-highlight">2724</i>&nbsp;     * When null is returned, the caller must treat the record as deleted.
<i class="no-highlight">2725</i>&nbsp;     *
<i class="no-highlight">2726</i>&nbsp;     * Note that null can only be returned for a slot that could contain an LN,
<i class="no-highlight">2727</i>&nbsp;     * not other node types and not a DupCountLN since DupCountLNs are never
<i class="no-highlight">2728</i>&nbsp;     * deleted or expired.
<i class="no-highlight">2729</i>&nbsp;     *
<i class="no-highlight">2730</i>&nbsp;     * An exclusive latch must be held on this BIN.
<i class="no-highlight">2731</i>&nbsp;     *
<i class="no-highlight">2732</i>&nbsp;     * @return the LN or null.
<i class="no-highlight">2733</i>&nbsp;     */
<i class="no-highlight">2734</i>&nbsp;    public final LN fetchLN(int idx, CacheMode cacheMode) {
<i class="no-highlight">2735</i>&nbsp;
<b class="fc"><i class="no-highlight">2736</i>&nbsp;        return (LN) fetchLN(idx, cacheMode, false);</b>
<i class="no-highlight">2737</i>&nbsp;    }
<i class="no-highlight">2738</i>&nbsp;
<i class="no-highlight">2739</i>&nbsp;    /*
<i class="no-highlight">2740</i>&nbsp;     * This method may return either an LN or a DIN child of a BIN. It is meant
<i class="no-highlight">2741</i>&nbsp;     * to be used from DupConvert only.
<i class="no-highlight">2742</i>&nbsp;     */
<i class="no-highlight">2743</i>&nbsp;    public final Node fetchLNOrDIN(int idx, CacheMode cacheMode) {
<i class="no-highlight">2744</i>&nbsp;
<b class="nc"><i class="no-highlight">2745</i>&nbsp;        return fetchLN(idx, cacheMode, true);</b>
<i class="no-highlight">2746</i>&nbsp;    }
<i class="no-highlight">2747</i>&nbsp;
<i class="no-highlight">2748</i>&nbsp;    /*
<i class="no-highlight">2749</i>&nbsp;     * Underlying implementation of the above fetchLNXXX methods.
<i class="no-highlight">2750</i>&nbsp;     */
<i class="no-highlight">2751</i>&nbsp;    private Node fetchLN(int idx, CacheMode cacheMode, boolean dupConvert) {
<i class="no-highlight">2752</i>&nbsp;
<b class="fc"><i class="no-highlight">2753</i>&nbsp;        assert(isBIN());</b>
<i class="no-highlight">2754</i>&nbsp;
<b class="fc"><i class="no-highlight">2755</i>&nbsp;        if (!isLatchExclusiveOwner()) {</b>
<b class="nc"><i class="no-highlight">2756</i>&nbsp;            throw unexpectedState(&quot;EX-latch not held before fetch&quot;);</b>
<i class="no-highlight">2757</i>&nbsp;        }
<i class="no-highlight">2758</i>&nbsp;
<b class="fc"><i class="no-highlight">2759</i>&nbsp;        if (isEntryKnownDeleted(idx)) {</b>
<b class="nc"><i class="no-highlight">2760</i>&nbsp;            return null;</b>
<i class="no-highlight">2761</i>&nbsp;        }
<i class="no-highlight">2762</i>&nbsp;
<b class="fc"><i class="no-highlight">2763</i>&nbsp;        final BIN bin = (BIN) this;</b>
<b class="fc"><i class="no-highlight">2764</i>&nbsp;        final EnvironmentImpl envImpl = getEnv();</b>
<b class="fc"><i class="no-highlight">2765</i>&nbsp;        final OffHeapCache ohCache = envImpl.getOffHeapCache();</b>
<b class="fc"><i class="no-highlight">2766</i>&nbsp;        boolean isMiss = false;</b>
<i class="no-highlight">2767</i>&nbsp;
<b class="fc"><i class="no-highlight">2768</i>&nbsp;        Node child = entryTargets.get(idx);</b>
<i class="no-highlight">2769</i>&nbsp;
<i class="no-highlight">2770</i>&nbsp;        /* Fetch it from disk. */
<b class="fc"><i class="no-highlight">2771</i>&nbsp;        if (child == null) {</b>
<i class="no-highlight">2772</i>&nbsp;
<b class="nc"><i class="no-highlight">2773</i>&nbsp;            final long lsn = getLsn(idx);</b>
<i class="no-highlight">2774</i>&nbsp;
<b class="nc"><i class="no-highlight">2775</i>&nbsp;            if (lsn == DbLsn.NULL_LSN) {</b>
<b class="nc"><i class="no-highlight">2776</i>&nbsp;                throw unexpectedState(makeFetchErrorMsg(</b>
<i class="no-highlight">2777</i>&nbsp;                    &quot;NULL_LSN without KnownDeleted&quot;, lsn, idx));
<i class="no-highlight">2778</i>&nbsp;            }
<i class="no-highlight">2779</i>&nbsp;
<i class="no-highlight">2780</i>&nbsp;            /*
<i class="no-highlight">2781</i>&nbsp;             * Fetch of immediately obsolete LN not allowed. The only exception
<i class="no-highlight">2782</i>&nbsp;             * is during conversion of an old-style dups DB.
<i class="no-highlight">2783</i>&nbsp;             */
<b class="nc"><i class="no-highlight">2784</i>&nbsp;            if (isEmbeddedLN(idx) ||</b>
<b class="nc"><i class="no-highlight">2785</i>&nbsp;                (databaseImpl.isLNImmediatelyObsolete() &amp;&amp; !dupConvert)) {</b>
<b class="nc"><i class="no-highlight">2786</i>&nbsp;                throw unexpectedState(&quot;May not fetch immediately obsolete LN&quot;);</b>
<i class="no-highlight">2787</i>&nbsp;            }
<i class="no-highlight">2788</i>&nbsp;
<i class="no-highlight">2789</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">2790</i>&nbsp;                byte[] lnSlotKey = null;</b>
<i class="no-highlight">2791</i>&nbsp;
<b class="nc"><i class="no-highlight">2792</i>&nbsp;                child = ohCache.loadLN(bin, idx, cacheMode);</b>
<i class="no-highlight">2793</i>&nbsp;
<b class="nc"><i class="no-highlight">2794</i>&nbsp;                if (child == null) {</b>
<b class="nc"><i class="no-highlight">2795</i>&nbsp;                    final WholeEntry wholeEntry = envImpl.getLogManager().</b>
<b class="nc"><i class="no-highlight">2796</i>&nbsp;                        getLogEntryAllowInvisibleAtRecovery(</b>
<b class="nc"><i class="no-highlight">2797</i>&nbsp;                            lsn, getLastLoggedSize(idx));</b>
<i class="no-highlight">2798</i>&nbsp;
<i class="no-highlight">2799</i>&nbsp;                    /* Last logged size is not present before log version 9. */
<b class="nc"><i class="no-highlight">2800</i>&nbsp;                    setLastLoggedSize(</b>
<b class="nc"><i class="no-highlight">2801</i>&nbsp;                        idx, wholeEntry.getHeader().getEntrySize());</b>
<i class="no-highlight">2802</i>&nbsp;
<b class="nc"><i class="no-highlight">2803</i>&nbsp;                    final LogEntry logEntry = wholeEntry.getEntry();</b>
<i class="no-highlight">2804</i>&nbsp;
<b class="nc"><i class="no-highlight">2805</i>&nbsp;                    if (logEntry instanceof LNLogEntry) {</b>
<i class="no-highlight">2806</i>&nbsp;
<b class="nc"><i class="no-highlight">2807</i>&nbsp;                        final LNLogEntry&lt;?&gt; lnEntry =</b>
<b class="nc"><i class="no-highlight">2808</i>&nbsp;                            (LNLogEntry&lt;?&gt;) wholeEntry.getEntry();</b>
<i class="no-highlight">2809</i>&nbsp;
<b class="nc"><i class="no-highlight">2810</i>&nbsp;                        lnEntry.postFetchInit(databaseImpl);</b>
<i class="no-highlight">2811</i>&nbsp;
<b class="nc"><i class="no-highlight">2812</i>&nbsp;                        lnSlotKey = lnEntry.getKey();</b>
<i class="no-highlight">2813</i>&nbsp;
<b class="nc"><i class="no-highlight">2814</i>&nbsp;                        if (cacheMode != CacheMode.EVICT_LN &amp;&amp;</b>
<i class="no-highlight">2815</i>&nbsp;                            cacheMode != CacheMode.EVICT_BIN &amp;&amp;
<i class="no-highlight">2816</i>&nbsp;                            cacheMode != CacheMode.UNCHANGED &amp;&amp;
<i class="no-highlight">2817</i>&nbsp;                            cacheMode != CacheMode.MAKE_COLD) {
<b class="nc"><i class="no-highlight">2818</i>&nbsp;                            getEvictor().moveToPri1LRU(this);</b>
<i class="no-highlight">2819</i>&nbsp;                        }
<i class="no-highlight">2820</i>&nbsp;                    }
<i class="no-highlight">2821</i>&nbsp;
<b class="nc"><i class="no-highlight">2822</i>&nbsp;                    child = (Node) logEntry.getResolvedItem(databaseImpl);</b>
<i class="no-highlight">2823</i>&nbsp;
<b class="nc"><i class="no-highlight">2824</i>&nbsp;                    isMiss = true;</b>
<i class="no-highlight">2825</i>&nbsp;                }
<i class="no-highlight">2826</i>&nbsp;
<b class="nc"><i class="no-highlight">2827</i>&nbsp;                child.postFetchInit(databaseImpl, lsn);</b>
<b class="nc"><i class="no-highlight">2828</i>&nbsp;                attachNode(idx, child, lnSlotKey);</b>
<i class="no-highlight">2829</i>&nbsp;
<b class="nc"><i class="no-highlight">2830</i>&nbsp;            } catch (FileNotFoundException e) {</b>
<i class="no-highlight">2831</i>&nbsp;
<b class="nc"><i class="no-highlight">2832</i>&nbsp;                if (!bin.isDeleted(idx) &amp;&amp;</b>
<b class="nc"><i class="no-highlight">2833</i>&nbsp;                    !bin.isProbablyExpired(idx)) {</b>
<i class="no-highlight">2834</i>&nbsp;
<b class="nc"><i class="no-highlight">2835</i>&nbsp;                    throw new EnvironmentFailureException(</b>
<i class="no-highlight">2836</i>&nbsp;                         envImpl, EnvironmentFailureReason.LOG_FILE_NOT_FOUND,
<b class="nc"><i class="no-highlight">2837</i>&nbsp;                         makeFetchErrorMsg(null, lsn, idx), e);</b>
<i class="no-highlight">2838</i>&nbsp;                }
<i class="no-highlight">2839</i>&nbsp;
<i class="no-highlight">2840</i>&nbsp;                /*
<i class="no-highlight">2841</i>&nbsp;                 * Cleaner got to the log file, so just return null. It is safe
<i class="no-highlight">2842</i>&nbsp;                 * to ignore a deleted file for a KD or PD entry because files
<i class="no-highlight">2843</i>&nbsp;                 * with active txns will not be cleaned.
<i class="no-highlight">2844</i>&nbsp;                 */
<b class="nc"><i class="no-highlight">2845</i>&nbsp;                return null;</b>
<i class="no-highlight">2846</i>&nbsp;
<b class="nc"><i class="no-highlight">2847</i>&nbsp;            } catch (EnvironmentFailureException e) {</b>
<b class="nc"><i class="no-highlight">2848</i>&nbsp;                e.addErrorMessage(makeFetchErrorMsg(null, lsn, idx));</b>
<b class="nc"><i class="no-highlight">2849</i>&nbsp;                throw e;</b>
<i class="no-highlight">2850</i>&nbsp;
<b class="nc"><i class="no-highlight">2851</i>&nbsp;            } catch (RuntimeException e) {</b>
<b class="nc"><i class="no-highlight">2852</i>&nbsp;                throw new EnvironmentFailureException(</b>
<i class="no-highlight">2853</i>&nbsp;                    envImpl, EnvironmentFailureReason.LOG_INTEGRITY,
<b class="nc"><i class="no-highlight">2854</i>&nbsp;                    makeFetchErrorMsg(e.toString(), lsn, idx), e);</b>
<b class="nc"><i class="no-highlight">2855</i>&nbsp;            }</b>
<i class="no-highlight">2856</i>&nbsp;        }
<i class="no-highlight">2857</i>&nbsp;
<b class="fc"><i class="no-highlight">2858</i>&nbsp;        if (child.isLN()) {</b>
<b class="fc"><i class="no-highlight">2859</i>&nbsp;            final LN ln = (LN) child;</b>
<i class="no-highlight">2860</i>&nbsp;
<b class="fc"><i class="no-highlight">2861</i>&nbsp;            if (cacheMode != CacheMode.UNCHANGED &amp;&amp;</b>
<i class="no-highlight">2862</i>&nbsp;                cacheMode != CacheMode.MAKE_COLD) {
<b class="fc"><i class="no-highlight">2863</i>&nbsp;                ln.setFetchedCold(false);</b>
<i class="no-highlight">2864</i>&nbsp;            }
<i class="no-highlight">2865</i>&nbsp;
<b class="fc"><i class="no-highlight">2866</i>&nbsp;            ohCache.freeRedundantLN(bin, idx, ln, cacheMode);</b>
<i class="no-highlight">2867</i>&nbsp;        }
<i class="no-highlight">2868</i>&nbsp;
<b class="fc"><i class="no-highlight">2869</i>&nbsp;        child.incFetchStats(envImpl, isMiss);</b>
<i class="no-highlight">2870</i>&nbsp;
<b class="fc"><i class="no-highlight">2871</i>&nbsp;        return child;</b>
<i class="no-highlight">2872</i>&nbsp;    }
<i class="no-highlight">2873</i>&nbsp;
<i class="no-highlight">2874</i>&nbsp;    /**
<i class="no-highlight">2875</i>&nbsp;     * Return the idx&#39;th LN target, enforcing rules defined by the cache modes
<i class="no-highlight">2876</i>&nbsp;     * for the LN. This method should be called instead of getTarget when a
<i class="no-highlight">2877</i>&nbsp;     * cache mode applies to user operations such as reads and updates.
<i class="no-highlight">2878</i>&nbsp;     */
<i class="no-highlight">2879</i>&nbsp;    public final LN getLN(int idx, CacheMode cacheMode) {
<b class="fc"><i class="no-highlight">2880</i>&nbsp;        assert isBIN();</b>
<i class="no-highlight">2881</i>&nbsp;
<b class="fc"><i class="no-highlight">2882</i>&nbsp;        final LN ln = (LN) entryTargets.get(idx);</b>
<i class="no-highlight">2883</i>&nbsp;
<b class="fc"><i class="no-highlight">2884</i>&nbsp;        if (ln == null) {</b>
<b class="fc"><i class="no-highlight">2885</i>&nbsp;            return null;</b>
<i class="no-highlight">2886</i>&nbsp;        }
<i class="no-highlight">2887</i>&nbsp;
<b class="nc"><i class="no-highlight">2888</i>&nbsp;        if (cacheMode != CacheMode.UNCHANGED &amp;&amp;</b>
<i class="no-highlight">2889</i>&nbsp;            cacheMode != CacheMode.MAKE_COLD) {
<b class="nc"><i class="no-highlight">2890</i>&nbsp;            ln.setFetchedCold(false);</b>
<i class="no-highlight">2891</i>&nbsp;        }
<i class="no-highlight">2892</i>&nbsp;
<b class="nc"><i class="no-highlight">2893</i>&nbsp;        final OffHeapCache ohCache = getOffHeapCache();</b>
<i class="no-highlight">2894</i>&nbsp;
<b class="nc"><i class="no-highlight">2895</i>&nbsp;        if (ohCache.isEnabled()) {</b>
<b class="nc"><i class="no-highlight">2896</i>&nbsp;            ohCache.freeRedundantLN((BIN) this, idx, ln, cacheMode);</b>
<i class="no-highlight">2897</i>&nbsp;        }
<i class="no-highlight">2898</i>&nbsp;
<b class="nc"><i class="no-highlight">2899</i>&nbsp;        return ln;</b>
<i class="no-highlight">2900</i>&nbsp;    }
<i class="no-highlight">2901</i>&nbsp;
<i class="no-highlight">2902</i>&nbsp;    /**
<i class="no-highlight">2903</i>&nbsp;     * Initialize a node that has been read in from the log.
<i class="no-highlight">2904</i>&nbsp;     */
<i class="no-highlight">2905</i>&nbsp;    @Override
<i class="no-highlight">2906</i>&nbsp;    public final void postFetchInit(DatabaseImpl db, long fetchedLsn) {
<b class="fc"><i class="no-highlight">2907</i>&nbsp;        assert isLatchExclusiveOwner();</b>
<i class="no-highlight">2908</i>&nbsp;
<b class="fc"><i class="no-highlight">2909</i>&nbsp;        commonInit(db);</b>
<b class="fc"><i class="no-highlight">2910</i>&nbsp;        setLastLoggedLsn(fetchedLsn);</b>
<b class="fc"><i class="no-highlight">2911</i>&nbsp;        convertDupKeys(); // must be after initMemorySize</b>
<b class="fc"><i class="no-highlight">2912</i>&nbsp;        addToMainCache();</b>
<i class="no-highlight">2913</i>&nbsp;
<b class="fc"><i class="no-highlight">2914</i>&nbsp;        if (isBIN()) {</b>
<b class="fc"><i class="no-highlight">2915</i>&nbsp;            setFetchedCold(true);</b>
<i class="no-highlight">2916</i>&nbsp;        }
<i class="no-highlight">2917</i>&nbsp;
<i class="no-highlight">2918</i>&nbsp;        /* See Database.mutateDeferredWriteBINDeltas. */
<b class="fc"><i class="no-highlight">2919</i>&nbsp;        if (db.isDeferredWriteMode()) {</b>
<b class="nc"><i class="no-highlight">2920</i>&nbsp;            mutateToFullBIN(false);</b>
<i class="no-highlight">2921</i>&nbsp;        }
<b class="fc"><i class="no-highlight">2922</i>&nbsp;    }</b>
<i class="no-highlight">2923</i>&nbsp;
<i class="no-highlight">2924</i>&nbsp;    /**
<i class="no-highlight">2925</i>&nbsp;     * Initialize a BIN loaded from off-heap cache.
<i class="no-highlight">2926</i>&nbsp;     *
<i class="no-highlight">2927</i>&nbsp;     * Does not call setLastLoggedLsn because materialization of the off-heap
<i class="no-highlight">2928</i>&nbsp;     * BIN initializes all fields including the last logged/delta LSNs.
<i class="no-highlight">2929</i>&nbsp;     */
<i class="no-highlight">2930</i>&nbsp;    private void postLoadInit(IN parent, int idx) {
<b class="nc"><i class="no-highlight">2931</i>&nbsp;        assert isLatchExclusiveOwner();</b>
<i class="no-highlight">2932</i>&nbsp;
<b class="nc"><i class="no-highlight">2933</i>&nbsp;        commonInit(parent.databaseImpl);</b>
<b class="nc"><i class="no-highlight">2934</i>&nbsp;        addToMainCache();</b>
<i class="no-highlight">2935</i>&nbsp;
<b class="nc"><i class="no-highlight">2936</i>&nbsp;        if (isBIN()) {</b>
<b class="nc"><i class="no-highlight">2937</i>&nbsp;            setFetchedCold(true);</b>
<b class="nc"><i class="no-highlight">2938</i>&nbsp;            setFetchedColdOffHeap(true);</b>
<i class="no-highlight">2939</i>&nbsp;        }
<i class="no-highlight">2940</i>&nbsp;
<b class="nc"><i class="no-highlight">2941</i>&nbsp;        getEnv().getOffHeapCache().postBINLoad(parent, idx, (BIN) this);</b>
<b class="nc"><i class="no-highlight">2942</i>&nbsp;    }</b>
<i class="no-highlight">2943</i>&nbsp;
<i class="no-highlight">2944</i>&nbsp;    /**
<i class="no-highlight">2945</i>&nbsp;     * Initialize a node read in during recovery.
<i class="no-highlight">2946</i>&nbsp;     */
<i class="no-highlight">2947</i>&nbsp;    public final void postRecoveryInit(DatabaseImpl db, long lastLoggedLsn) {
<b class="nc"><i class="no-highlight">2948</i>&nbsp;        commonInit(db);</b>
<b class="nc"><i class="no-highlight">2949</i>&nbsp;        setLastLoggedLsn(lastLoggedLsn);</b>
<b class="nc"><i class="no-highlight">2950</i>&nbsp;    }</b>
<i class="no-highlight">2951</i>&nbsp;
<i class="no-highlight">2952</i>&nbsp;    /**
<i class="no-highlight">2953</i>&nbsp;     * Common actions of postFetchInit, postLoadInit and postRecoveryInit.
<i class="no-highlight">2954</i>&nbsp;     */
<i class="no-highlight">2955</i>&nbsp;    private void commonInit(DatabaseImpl db) {
<b class="fc"><i class="no-highlight">2956</i>&nbsp;        setDatabase(db);</b>
<b class="fc"><i class="no-highlight">2957</i>&nbsp;        initMemorySize(); // compute before adding to IN list</b>
<b class="fc"><i class="no-highlight">2958</i>&nbsp;    }</b>
<i class="no-highlight">2959</i>&nbsp;
<i class="no-highlight">2960</i>&nbsp;    /**
<i class="no-highlight">2961</i>&nbsp;     * Add to INList and perform eviction related initialization.
<i class="no-highlight">2962</i>&nbsp;     */
<i class="no-highlight">2963</i>&nbsp;    private void addToMainCache() {
<i class="no-highlight">2964</i>&nbsp;
<b class="fc"><i class="no-highlight">2965</i>&nbsp;        getEnv().getInMemoryINs().add(this);</b>
<i class="no-highlight">2966</i>&nbsp;
<b class="fc"><i class="no-highlight">2967</i>&nbsp;        if (!isDIN() &amp;&amp; !isDBIN()) {</b>
<b class="fc"><i class="no-highlight">2968</i>&nbsp;            if (isUpperIN() &amp;&amp; traceLRU) {</b>
<i class="no-highlight">2969</i>&nbsp;                LoggerUtils.envLogMsg(
<i class="no-highlight">2970</i>&nbsp;                    traceLevel, getEnv(),
<i class="no-highlight">2971</i>&nbsp;                    Thread.currentThread().getId() + &quot;-&quot; +
<i class="no-highlight">2972</i>&nbsp;                    Thread.currentThread().getName() +
<i class="no-highlight">2973</i>&nbsp;                    &quot;-&quot; + getEnv().getName() +
<i class="no-highlight">2974</i>&nbsp;                    &quot; postFetchInit(): &quot; +
<i class="no-highlight">2975</i>&nbsp;                    &quot; Adding UIN to LRU: &quot; + getNodeId());
<i class="no-highlight">2976</i>&nbsp;            }
<b class="fc"><i class="no-highlight">2977</i>&nbsp;            getEvictor().addBack(this);</b>
<i class="no-highlight">2978</i>&nbsp;        }
<i class="no-highlight">2979</i>&nbsp;
<i class="no-highlight">2980</i>&nbsp;        /* Compress full BINs after fetching or loading. */
<b class="fc"><i class="no-highlight">2981</i>&nbsp;        if (!(this instanceof DBIN || this instanceof DIN)) {</b>
<b class="fc"><i class="no-highlight">2982</i>&nbsp;            getEnv().lazyCompress(this);</b>
<i class="no-highlight">2983</i>&nbsp;        }
<b class="fc"><i class="no-highlight">2984</i>&nbsp;    }</b>
<i class="no-highlight">2985</i>&nbsp;
<i class="no-highlight">2986</i>&nbsp;    /**
<i class="no-highlight">2987</i>&nbsp;     * Needed only during duplicates conversion, not during normal operation.
<i class="no-highlight">2988</i>&nbsp;     * The needDupKeyConversion field will only be true when first upgrading
<i class="no-highlight">2989</i>&nbsp;     * from JE 4.1.  After the first time an IN is converted, it will be
<i class="no-highlight">2990</i>&nbsp;     * written out in a later file format, so the needDupKeyConversion field
<i class="no-highlight">2991</i>&nbsp;     * will be false and this method will do nothing.  See
<i class="no-highlight">2992</i>&nbsp;     * DupConvert.convertInKeys.
<i class="no-highlight">2993</i>&nbsp;     */
<i class="no-highlight">2994</i>&nbsp;    private void convertDupKeys() {
<i class="no-highlight">2995</i>&nbsp;        /* Do not convert more than once. */
<b class="fc"><i class="no-highlight">2996</i>&nbsp;        if (!needDupKeyConversion) {</b>
<b class="fc"><i class="no-highlight">2997</i>&nbsp;            return;</b>
<i class="no-highlight">2998</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2999</i>&nbsp;        needDupKeyConversion = false;</b>
<b class="nc"><i class="no-highlight">3000</i>&nbsp;        DupConvert.convertInKeys(databaseImpl, this);</b>
<b class="nc"><i class="no-highlight">3001</i>&nbsp;    }</b>
<i class="no-highlight">3002</i>&nbsp;
<i class="no-highlight">3003</i>&nbsp;    /**
<i class="no-highlight">3004</i>&nbsp;     * @see Node#incFetchStats
<i class="no-highlight">3005</i>&nbsp;     */
<i class="no-highlight">3006</i>&nbsp;    @Override
<i class="no-highlight">3007</i>&nbsp;    final void incFetchStats(EnvironmentImpl envImpl, boolean isMiss) {
<b class="fc"><i class="no-highlight">3008</i>&nbsp;        Evictor e = envImpl.getEvictor();</b>
<b class="fc"><i class="no-highlight">3009</i>&nbsp;        if (isBIN()) {</b>
<b class="fc"><i class="no-highlight">3010</i>&nbsp;            e.incBINFetchStats(isMiss, isBINDelta(false/*checLatched*/));</b>
<i class="no-highlight">3011</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">3012</i>&nbsp;            e.incUINFetchStats(isMiss);</b>
<i class="no-highlight">3013</i>&nbsp;        }
<b class="fc"><i class="no-highlight">3014</i>&nbsp;    }</b>
<i class="no-highlight">3015</i>&nbsp;
<i class="no-highlight">3016</i>&nbsp;    public String makeFetchErrorMsg(
<i class="no-highlight">3017</i>&nbsp;        final String msg,
<i class="no-highlight">3018</i>&nbsp;        final long lsn,
<i class="no-highlight">3019</i>&nbsp;        final int idx) {
<i class="no-highlight">3020</i>&nbsp;
<b class="nc"><i class="no-highlight">3021</i>&nbsp;        final byte state = idx &gt;= 0 ? entryStates[idx] : 0;</b>
<i class="no-highlight">3022</i>&nbsp;
<i class="no-highlight">3023</i>&nbsp;        final long expirationTime;
<i class="no-highlight">3024</i>&nbsp;
<b class="nc"><i class="no-highlight">3025</i>&nbsp;        if (isBIN() &amp;&amp; idx &gt;= 0) {</b>
<i class="no-highlight">3026</i>&nbsp;
<b class="nc"><i class="no-highlight">3027</i>&nbsp;            final BIN bin = (BIN) this;</b>
<i class="no-highlight">3028</i>&nbsp;
<b class="nc"><i class="no-highlight">3029</i>&nbsp;            expirationTime = TTL.expirationToSystemTime(</b>
<b class="nc"><i class="no-highlight">3030</i>&nbsp;                bin.getExpiration(idx), isExpirationInHours());</b>
<i class="no-highlight">3031</i>&nbsp;
<b class="nc"><i class="no-highlight">3032</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">3033</i>&nbsp;            expirationTime = 0;</b>
<i class="no-highlight">3034</i>&nbsp;        }
<i class="no-highlight">3035</i>&nbsp;
<b class="nc"><i class="no-highlight">3036</i>&nbsp;        return makeFetchErrorMsg(msg, this, lsn, state, expirationTime);</b>
<i class="no-highlight">3037</i>&nbsp;    }
<i class="no-highlight">3038</i>&nbsp;
<i class="no-highlight">3039</i>&nbsp;    /**
<i class="no-highlight">3040</i>&nbsp;     * @param in parent IN.  Is null when root is fetched.
<i class="no-highlight">3041</i>&nbsp;     */
<i class="no-highlight">3042</i>&nbsp;    static String makeFetchErrorMsg(
<i class="no-highlight">3043</i>&nbsp;        String msg,
<i class="no-highlight">3044</i>&nbsp;        IN in,
<i class="no-highlight">3045</i>&nbsp;        long lsn,
<i class="no-highlight">3046</i>&nbsp;        byte state,
<i class="no-highlight">3047</i>&nbsp;        long expirationTime) {
<i class="no-highlight">3048</i>&nbsp;
<i class="no-highlight">3049</i>&nbsp;        /*
<i class="no-highlight">3050</i>&nbsp;         * Bolster the exception with the LSN, which is critical for
<i class="no-highlight">3051</i>&nbsp;         * debugging. Otherwise, the exception propagates upward and loses the
<i class="no-highlight">3052</i>&nbsp;         * problem LSN.
<i class="no-highlight">3053</i>&nbsp;         */
<b class="nc"><i class="no-highlight">3054</i>&nbsp;        StringBuilder sb = new StringBuilder();</b>
<i class="no-highlight">3055</i>&nbsp;
<b class="nc"><i class="no-highlight">3056</i>&nbsp;        if (in == null) {</b>
<b class="nc"><i class="no-highlight">3057</i>&nbsp;            sb.append(&quot;fetchRoot of &quot;);</b>
<b class="nc"><i class="no-highlight">3058</i>&nbsp;        } else if (in.isBIN()) {</b>
<b class="nc"><i class="no-highlight">3059</i>&nbsp;            sb.append(&quot;fetchLN of &quot;);</b>
<i class="no-highlight">3060</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">3061</i>&nbsp;            sb.append(&quot;fetchIN of &quot;);</b>
<i class="no-highlight">3062</i>&nbsp;        }
<i class="no-highlight">3063</i>&nbsp;
<b class="nc"><i class="no-highlight">3064</i>&nbsp;        if (lsn == DbLsn.NULL_LSN) {</b>
<b class="nc"><i class="no-highlight">3065</i>&nbsp;            sb.append(&quot;null lsn&quot;);</b>
<i class="no-highlight">3066</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">3067</i>&nbsp;            sb.append(DbLsn.getNoFormatString(lsn));</b>
<i class="no-highlight">3068</i>&nbsp;        }
<i class="no-highlight">3069</i>&nbsp;
<b class="nc"><i class="no-highlight">3070</i>&nbsp;        if (in != null) {</b>
<b class="nc"><i class="no-highlight">3071</i>&nbsp;            sb.append(&quot; parent IN=&quot;).append(in.getNodeId());</b>
<b class="nc"><i class="no-highlight">3072</i>&nbsp;            sb.append(&quot; IN class=&quot;).append(in.getClass().getName());</b>
<b class="nc"><i class="no-highlight">3073</i>&nbsp;            sb.append(&quot; lastFullLsn=&quot;);</b>
<b class="nc"><i class="no-highlight">3074</i>&nbsp;            sb.append(DbLsn.getNoFormatString(in.getLastFullLsn()));</b>
<b class="nc"><i class="no-highlight">3075</i>&nbsp;            sb.append(&quot; lastLoggedLsn=&quot;);</b>
<b class="nc"><i class="no-highlight">3076</i>&nbsp;            sb.append(DbLsn.getNoFormatString(in.getLastLoggedLsn()));</b>
<b class="nc"><i class="no-highlight">3077</i>&nbsp;            sb.append(&quot; parent.getDirty()=&quot;).append(in.getDirty());</b>
<i class="no-highlight">3078</i>&nbsp;        }
<i class="no-highlight">3079</i>&nbsp;
<b class="nc"><i class="no-highlight">3080</i>&nbsp;        sb.append(&quot; state=&quot;).append(state);</b>
<i class="no-highlight">3081</i>&nbsp;
<b class="nc"><i class="no-highlight">3082</i>&nbsp;        sb.append(&quot; expires=&quot;);</b>
<i class="no-highlight">3083</i>&nbsp;
<b class="nc"><i class="no-highlight">3084</i>&nbsp;        if (expirationTime != 0) {</b>
<b class="nc"><i class="no-highlight">3085</i>&nbsp;            sb.append(TTL.formatExpirationTime(expirationTime));</b>
<i class="no-highlight">3086</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">3087</i>&nbsp;            sb.append(&quot;never&quot;);</b>
<i class="no-highlight">3088</i>&nbsp;        }
<i class="no-highlight">3089</i>&nbsp;
<b class="nc"><i class="no-highlight">3090</i>&nbsp;        if (msg != null) {</b>
<b class="nc"><i class="no-highlight">3091</i>&nbsp;            sb.append(&quot; &quot;).append(msg);</b>
<i class="no-highlight">3092</i>&nbsp;        }
<i class="no-highlight">3093</i>&nbsp;
<b class="nc"><i class="no-highlight">3094</i>&nbsp;        return sb.toString();</b>
<i class="no-highlight">3095</i>&nbsp;    }
<i class="no-highlight">3096</i>&nbsp;
<i class="no-highlight">3097</i>&nbsp;    public final int findEntry(
<i class="no-highlight">3098</i>&nbsp;        byte[] key,
<i class="no-highlight">3099</i>&nbsp;        boolean indicateIfDuplicate,
<i class="no-highlight">3100</i>&nbsp;        boolean exact) {
<i class="no-highlight">3101</i>&nbsp;
<b class="fc"><i class="no-highlight">3102</i>&nbsp;        return findEntry(key, indicateIfDuplicate, exact, null /*Comparator*/);</b>
<i class="no-highlight">3103</i>&nbsp;    }
<i class="no-highlight">3104</i>&nbsp;
<i class="no-highlight">3105</i>&nbsp;    /**
<i class="no-highlight">3106</i>&nbsp;     * Find the entry in this IN for which key is LTE the key arg.
<i class="no-highlight">3107</i>&nbsp;     *
<i class="no-highlight">3108</i>&nbsp;     * Currently uses a binary search, but eventually, this may use binary or
<i class="no-highlight">3109</i>&nbsp;     * linear search depending on key size, number of entries, etc.
<i class="no-highlight">3110</i>&nbsp;     *
<i class="no-highlight">3111</i>&nbsp;     * This method guarantees that the key parameter, which is the user&#39;s key
<i class="no-highlight">3112</i>&nbsp;     * parameter in user-initiated search operations, is always the left hand
<i class="no-highlight">3113</i>&nbsp;     * parameter to the Comparator.compare method.  This allows a comparator
<i class="no-highlight">3114</i>&nbsp;     * to perform specialized searches, when passed down from upper layers.
<i class="no-highlight">3115</i>&nbsp;     *
<i class="no-highlight">3116</i>&nbsp;     * This is public so that DbCursorTest can access it.
<i class="no-highlight">3117</i>&nbsp;     *
<i class="no-highlight">3118</i>&nbsp;     * Note that the 0&#39;th entry&#39;s key is treated specially in an IN.  It always
<i class="no-highlight">3119</i>&nbsp;     * compares lower than any other key.
<i class="no-highlight">3120</i>&nbsp;     *
<i class="no-highlight">3121</i>&nbsp;     * @param key - the key to search for.
<i class="no-highlight">3122</i>&nbsp;     * @param indicateIfDuplicate - true if EXACT_MATCH should
<i class="no-highlight">3123</i>&nbsp;     * be or&#39;d onto the return value if key is already present in this node.
<i class="no-highlight">3124</i>&nbsp;     * @param exact - true if an exact match must be found.
<i class="no-highlight">3125</i>&nbsp;     * @return offset for the entry that has a key LTE the arg.  0 if key
<i class="no-highlight">3126</i>&nbsp;     * is less than the 1st entry.  -1 if exact is true and no exact match
<i class="no-highlight">3127</i>&nbsp;     * is found.  If indicateIfDuplicate is true and an exact match was found
<i class="no-highlight">3128</i>&nbsp;     * then EXACT_MATCH is or&#39;d onto the return value.
<i class="no-highlight">3129</i>&nbsp;     */
<i class="no-highlight">3130</i>&nbsp;    public final int findEntry(
<i class="no-highlight">3131</i>&nbsp;        byte[] key,
<i class="no-highlight">3132</i>&nbsp;        boolean indicateIfDuplicate,
<i class="no-highlight">3133</i>&nbsp;        boolean exact,
<i class="no-highlight">3134</i>&nbsp;        Comparator&lt;byte[]&gt; comparator) {
<b class="fc"><i class="no-highlight">3135</i>&nbsp;        COUNT_FIND.incrementAndGet();</b>
<i class="no-highlight">3136</i>&nbsp;
<b class="fc"><i class="no-highlight">3137</i>&nbsp;        assert idKeyIsSlotKey();</b>
<i class="no-highlight">3138</i>&nbsp;
<b class="fc"><i class="no-highlight">3139</i>&nbsp;        int high = nEntries - 1;</b>
<b class="fc"><i class="no-highlight">3140</i>&nbsp;        int low = 0;</b>
<b class="fc"><i class="no-highlight">3141</i>&nbsp;        int middle = 0;</b>
<i class="no-highlight">3142</i>&nbsp;
<b class="fc"><i class="no-highlight">3143</i>&nbsp;        if (comparator == null) {</b>
<b class="fc"><i class="no-highlight">3144</i>&nbsp;            comparator = databaseImpl.getKeyComparator();</b>
<i class="no-highlight">3145</i>&nbsp;        }
<i class="no-highlight">3146</i>&nbsp;
<i class="no-highlight">3147</i>&nbsp;        /*
<i class="no-highlight">3148</i>&nbsp;         * Special Treatment of 0th Entry
<i class="no-highlight">3149</i>&nbsp;         * ------------------------------
<i class="no-highlight">3150</i>&nbsp;         * IN&#39;s are special in that they have a entry[0] where the key is a
<i class="no-highlight">3151</i>&nbsp;         * virtual key in that it always compares lower than any other key.
<i class="no-highlight">3152</i>&nbsp;         * BIN&#39;s don&#39;t treat key[0] specially.  But if the caller asked for an
<i class="no-highlight">3153</i>&nbsp;         * exact match or to indicate duplicates, then use the key[0] and
<i class="no-highlight">3154</i>&nbsp;         * forget about the special entry zero comparison.
<i class="no-highlight">3155</i>&nbsp;         *
<i class="no-highlight">3156</i>&nbsp;         * We always use inexact searching to get down to the BIN, and then
<i class="no-highlight">3157</i>&nbsp;         * call findEntry separately on the BIN if necessary.  So the behavior
<i class="no-highlight">3158</i>&nbsp;         * of findEntry is different for BINs and INs, because it&#39;s used in
<i class="no-highlight">3159</i>&nbsp;         * different ways.
<i class="no-highlight">3160</i>&nbsp;         *
<i class="no-highlight">3161</i>&nbsp;         * Consider a tree where the lowest key is &quot;b&quot; and we want to insert
<i class="no-highlight">3162</i>&nbsp;         * &quot;a&quot;.  If we did the comparison (with exact == false), we wouldn&#39;t
<i class="no-highlight">3163</i>&nbsp;         * find the correct (i.e.  the left) path down the tree.  So the
<i class="no-highlight">3164</i>&nbsp;         * virtual key ensures that &quot;a&quot; gets inserted down the left path.
<i class="no-highlight">3165</i>&nbsp;         *
<i class="no-highlight">3166</i>&nbsp;         * The insertion case is a good specific example.  findBinForInsert
<i class="no-highlight">3167</i>&nbsp;         * does inexact searching in the INs only, not the BIN.
<i class="no-highlight">3168</i>&nbsp;         *
<i class="no-highlight">3169</i>&nbsp;         * There&#39;s nothing special about the 0th key itself, only the use of
<i class="no-highlight">3170</i>&nbsp;         * the 0th key in the comparison algorithm.
<i class="no-highlight">3171</i>&nbsp;         */
<b class="fc"><i class="no-highlight">3172</i>&nbsp;        boolean entryZeroSpecialCompare =</b>
<b class="fc"><i class="no-highlight">3173</i>&nbsp;            isUpperIN() &amp;&amp; !exact &amp;&amp; !indicateIfDuplicate;</b>
<i class="no-highlight">3174</i>&nbsp;
<b class="fc"><i class="no-highlight">3175</i>&nbsp;        assert nEntries &gt;= 0;</b>
<i class="no-highlight">3176</i>&nbsp;
<b class="fc"><i class="no-highlight">3177</i>&nbsp;        while (low &lt;= high) {</b>
<i class="no-highlight">3178</i>&nbsp;
<b class="fc"><i class="no-highlight">3179</i>&nbsp;            middle = (high + low) / 2;</b>
<i class="no-highlight">3180</i>&nbsp;            int s;
<i class="no-highlight">3181</i>&nbsp;
<b class="fc"><i class="no-highlight">3182</i>&nbsp;            if (middle == 0 &amp;&amp; entryZeroSpecialCompare) {</b>
<b class="fc"><i class="no-highlight">3183</i>&nbsp;                s = 1;</b>
<i class="no-highlight">3184</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">3185</i>&nbsp;                s = entryKeys.compareKeys(</b>
<i class="no-highlight">3186</i>&nbsp;                    key,  keyPrefix, middle,
<b class="fc"><i class="no-highlight">3187</i>&nbsp;                    haveEmbeddedData(middle), comparator);</b>
<i class="no-highlight">3188</i>&nbsp;            }
<i class="no-highlight">3189</i>&nbsp;
<b class="fc"><i class="no-highlight">3190</i>&nbsp;            if (s &lt; 0) {</b>
<b class="fc"><i class="no-highlight">3191</i>&nbsp;                high = middle - 1;</b>
<b class="fc"><i class="no-highlight">3192</i>&nbsp;            } else if (s &gt; 0) {</b>
<b class="fc"><i class="no-highlight">3193</i>&nbsp;                low = middle + 1;</b>
<i class="no-highlight">3194</i>&nbsp;            } else {
<i class="no-highlight">3195</i>&nbsp;                int ret;
<b class="fc"><i class="no-highlight">3196</i>&nbsp;                if (indicateIfDuplicate) {</b>
<b class="fc"><i class="no-highlight">3197</i>&nbsp;                    ret = middle | EXACT_MATCH;</b>
<i class="no-highlight">3198</i>&nbsp;                } else {
<b class="fc"><i class="no-highlight">3199</i>&nbsp;                    ret = middle;</b>
<i class="no-highlight">3200</i>&nbsp;                }
<i class="no-highlight">3201</i>&nbsp;
<b class="fc"><i class="no-highlight">3202</i>&nbsp;                if ((ret &gt;= 0) &amp;&amp; exact &amp;&amp; isEntryKnownDeleted(ret &amp; 0xffff)) {</b>
<b class="nc"><i class="no-highlight">3203</i>&nbsp;                    return -1;</b>
<i class="no-highlight">3204</i>&nbsp;                } else {
<b class="fc"><i class="no-highlight">3205</i>&nbsp;                    return ret;</b>
<i class="no-highlight">3206</i>&nbsp;                }
<i class="no-highlight">3207</i>&nbsp;            }
<b class="fc"><i class="no-highlight">3208</i>&nbsp;        }</b>
<i class="no-highlight">3209</i>&nbsp;
<i class="no-highlight">3210</i>&nbsp;        /*
<i class="no-highlight">3211</i>&nbsp;         * No match found.  Either return -1 if caller wanted exact matches
<i class="no-highlight">3212</i>&nbsp;         * only, or return entry whose key is &lt; search key.
<i class="no-highlight">3213</i>&nbsp;         */
<b class="fc"><i class="no-highlight">3214</i>&nbsp;        if (exact) {</b>
<b class="fc"><i class="no-highlight">3215</i>&nbsp;            return -1;</b>
<i class="no-highlight">3216</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">3217</i>&nbsp;            return high;</b>
<i class="no-highlight">3218</i>&nbsp;        }
<i class="no-highlight">3219</i>&nbsp;    }
<i class="no-highlight">3220</i>&nbsp;
<i class="no-highlight">3221</i>&nbsp;    /**
<i class="no-highlight">3222</i>&nbsp;     * Inserts a slot with the given key, lsn and child node into this IN, if
<i class="no-highlight">3223</i>&nbsp;     * a slot with the same key does not exist already. The state of the new
<i class="no-highlight">3224</i>&nbsp;     * slot is set to DIRTY. Assumes this node is already latched by the
<i class="no-highlight">3225</i>&nbsp;     * caller.
<i class="no-highlight">3226</i>&nbsp;     *
<i class="no-highlight">3227</i>&nbsp;     * @return true if the entry was successfully inserted, false
<i class="no-highlight">3228</i>&nbsp;     * if it was a duplicate.
<i class="no-highlight">3229</i>&nbsp;     *
<i class="no-highlight">3230</i>&nbsp;     * @throws EnvironmentFailureException if the node is full
<i class="no-highlight">3231</i>&nbsp;     * (it should have been split earlier).
<i class="no-highlight">3232</i>&nbsp;     */
<i class="no-highlight">3233</i>&nbsp;    public final boolean insertEntry(
<i class="no-highlight">3234</i>&nbsp;        Node child,
<i class="no-highlight">3235</i>&nbsp;        byte[] key,
<i class="no-highlight">3236</i>&nbsp;        long childLsn)
<i class="no-highlight">3237</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">3238</i>&nbsp;
<b class="fc"><i class="no-highlight">3239</i>&nbsp;        assert(!isBINDelta());</b>
<i class="no-highlight">3240</i>&nbsp;
<b class="fc"><i class="no-highlight">3241</i>&nbsp;        int res = insertEntry1(</b>
<i class="no-highlight">3242</i>&nbsp;             child, key, null, childLsn, EntryStates.DIRTY_BIT, false);
<i class="no-highlight">3243</i>&nbsp;
<b class="fc"><i class="no-highlight">3244</i>&nbsp;        return (res &amp; INSERT_SUCCESS) != 0;</b>
<i class="no-highlight">3245</i>&nbsp;    }
<i class="no-highlight">3246</i>&nbsp;
<i class="no-highlight">3247</i>&nbsp;    /**
<i class="no-highlight">3248</i>&nbsp;     * Inserts a slot with the given key, lsn and child node into this IN, if
<i class="no-highlight">3249</i>&nbsp;     * a slot with the same key does not exist already. The state of the new
<i class="no-highlight">3250</i>&nbsp;     * slot is set to DIRTY. Assumes this node is already latched by the
<i class="no-highlight">3251</i>&nbsp;     * caller.
<i class="no-highlight">3252</i>&nbsp;     *
<i class="no-highlight">3253</i>&nbsp;     * @param data If the data portion of a record must be embedded in this
<i class="no-highlight">3254</i>&nbsp;     * BIN, &quot;data&quot; stores the record&#39;s data. Null otherwise. See also comment
<i class="no-highlight">3255</i>&nbsp;     * for the keyEntries field. 
<i class="no-highlight">3256</i>&nbsp;     *
<i class="no-highlight">3257</i>&nbsp;     * @return either (1) the index of location in the IN where the entry was
<i class="no-highlight">3258</i>&nbsp;     * inserted |&#39;d with INSERT_SUCCESS, or (2) the index of the duplicate in
<i class="no-highlight">3259</i>&nbsp;     * the IN if the entry was found to be a duplicate.
<i class="no-highlight">3260</i>&nbsp;     *
<i class="no-highlight">3261</i>&nbsp;     * @throws EnvironmentFailureException if the node is full (it should have
<i class="no-highlight">3262</i>&nbsp;     * been split earlier).
<i class="no-highlight">3263</i>&nbsp;     */
<i class="no-highlight">3264</i>&nbsp;    public final int insertEntry1(
<i class="no-highlight">3265</i>&nbsp;        Node child,
<i class="no-highlight">3266</i>&nbsp;        byte[] key,
<i class="no-highlight">3267</i>&nbsp;        byte[] data,
<i class="no-highlight">3268</i>&nbsp;        long childLsn,
<i class="no-highlight">3269</i>&nbsp;        boolean blindInsertion) {
<i class="no-highlight">3270</i>&nbsp;
<b class="fc"><i class="no-highlight">3271</i>&nbsp;        return insertEntry1(</b>
<i class="no-highlight">3272</i>&nbsp;            child, key, data, childLsn, EntryStates.DIRTY_BIT,
<i class="no-highlight">3273</i>&nbsp;            blindInsertion);
<i class="no-highlight">3274</i>&nbsp;    }
<i class="no-highlight">3275</i>&nbsp;
<i class="no-highlight">3276</i>&nbsp;    /**
<i class="no-highlight">3277</i>&nbsp;     * Inserts a slot with the given key, lsn, state, and child node into this
<i class="no-highlight">3278</i>&nbsp;     * IN, if a slot with the same key does not exist already. Assumes this
<i class="no-highlight">3279</i>&nbsp;     * node is already latched by the caller.
<i class="no-highlight">3280</i>&nbsp;     *
<i class="no-highlight">3281</i>&nbsp;     * This returns a failure if there&#39;s a duplicate match. The caller must do
<i class="no-highlight">3282</i>&nbsp;     * the processing to check if the entry is actually deleted and can be
<i class="no-highlight">3283</i>&nbsp;     * overwritten. This is foisted upon the caller rather than handled in this
<i class="no-highlight">3284</i>&nbsp;     * object because there may be some latch releasing/retaking in order to
<i class="no-highlight">3285</i>&nbsp;     * check a child LN.
<i class="no-highlight">3286</i>&nbsp;     *
<i class="no-highlight">3287</i>&nbsp;     * @param data If the data portion of a record must be embedded in this
<i class="no-highlight">3288</i>&nbsp;     * BIN, &quot;data&quot; stores the record&#39;s data. Null otherwise. See also comment
<i class="no-highlight">3289</i>&nbsp;     * for the keyEntries field. 
<i class="no-highlight">3290</i>&nbsp;     *
<i class="no-highlight">3291</i>&nbsp;     * @return either (1) the index of location in the IN where the entry was
<i class="no-highlight">3292</i>&nbsp;     * inserted |&#39;d with INSERT_SUCCESS, or (2) the index of the duplicate in
<i class="no-highlight">3293</i>&nbsp;     * the IN if the entry was found to be a duplicate.
<i class="no-highlight">3294</i>&nbsp;     *
<i class="no-highlight">3295</i>&nbsp;     * @throws EnvironmentFailureException if the node is full (it should have
<i class="no-highlight">3296</i>&nbsp;     * been split earlier).
<i class="no-highlight">3297</i>&nbsp;     */
<i class="no-highlight">3298</i>&nbsp;    public final int insertEntry1(
<i class="no-highlight">3299</i>&nbsp;        Node child,
<i class="no-highlight">3300</i>&nbsp;        byte[] key,
<i class="no-highlight">3301</i>&nbsp;        byte[] data,
<i class="no-highlight">3302</i>&nbsp;        long childLsn,
<i class="no-highlight">3303</i>&nbsp;        byte state,
<i class="no-highlight">3304</i>&nbsp;        boolean blindInsertion) {
<i class="no-highlight">3305</i>&nbsp;
<i class="no-highlight">3306</i>&nbsp;        /*
<i class="no-highlight">3307</i>&nbsp;         * Search without requiring an exact match, but do let us know the
<i class="no-highlight">3308</i>&nbsp;         * index of the match if there is one.
<i class="no-highlight">3309</i>&nbsp;         */
<b class="fc"><i class="no-highlight">3310</i>&nbsp;        int index = findEntry(key, true, false);</b>
<i class="no-highlight">3311</i>&nbsp;
<b class="fc"><i class="no-highlight">3312</i>&nbsp;        if (index &gt;= 0 &amp;&amp; (index &amp; EXACT_MATCH) != 0) {</b>
<i class="no-highlight">3313</i>&nbsp;
<i class="no-highlight">3314</i>&nbsp;            /*
<i class="no-highlight">3315</i>&nbsp;             * There is an exact match.  Don&#39;t insert; let the caller decide
<i class="no-highlight">3316</i>&nbsp;             * what to do with this duplicate.
<i class="no-highlight">3317</i>&nbsp;             */
<b class="fc"><i class="no-highlight">3318</i>&nbsp;            return index &amp; ~IN.EXACT_MATCH;</b>
<i class="no-highlight">3319</i>&nbsp;        }
<i class="no-highlight">3320</i>&nbsp;
<i class="no-highlight">3321</i>&nbsp;        /*
<i class="no-highlight">3322</i>&nbsp;         * There was no key match, but if this is a bin delta, there may be an
<i class="no-highlight">3323</i>&nbsp;         * exact match in the full bin. Mutate to full bin and search again.
<i class="no-highlight">3324</i>&nbsp;         * However, if we know for sure that the key does not exist in the full
<i class="no-highlight">3325</i>&nbsp;         * BIN, then don&#39;t mutate, unless there is no space in the delta to do
<i class="no-highlight">3326</i>&nbsp;         * the insertion.
<i class="no-highlight">3327</i>&nbsp;         */
<b class="fc"><i class="no-highlight">3328</i>&nbsp;        if (isBINDelta()) {</b>
<i class="no-highlight">3329</i>&nbsp;
<b class="fc"><i class="no-highlight">3330</i>&nbsp;            BIN bin = (BIN)this;</b>
<i class="no-highlight">3331</i>&nbsp;
<b class="fc"><i class="no-highlight">3332</i>&nbsp;            boolean doBlindInsertion = (nEntries &lt; getMaxEntries());</b>
<i class="no-highlight">3333</i>&nbsp;
<b class="fc"><i class="no-highlight">3334</i>&nbsp;            if (doBlindInsertion &amp;&amp;</b>
<i class="no-highlight">3335</i>&nbsp;                !blindInsertion &amp;&amp;
<b class="fc"><i class="no-highlight">3336</i>&nbsp;                bin.mayHaveKeyInFullBin(key)) {</b>
<i class="no-highlight">3337</i>&nbsp;
<b class="fc"><i class="no-highlight">3338</i>&nbsp;                doBlindInsertion = false;</b>
<i class="no-highlight">3339</i>&nbsp;            }
<i class="no-highlight">3340</i>&nbsp;
<b class="fc"><i class="no-highlight">3341</i>&nbsp;            if (!doBlindInsertion) {</b>
<i class="no-highlight">3342</i>&nbsp;
<b class="fc"><i class="no-highlight">3343</i>&nbsp;                mutateToFullBIN(true /*leaveFreeSlot*/);</b>
<i class="no-highlight">3344</i>&nbsp;
<b class="fc"><i class="no-highlight">3345</i>&nbsp;                index = findEntry(key, true, false);</b>
<i class="no-highlight">3346</i>&nbsp;
<b class="fc"><i class="no-highlight">3347</i>&nbsp;                if (index &gt;= 0 &amp;&amp; (index &amp; EXACT_MATCH) != 0) {</b>
<b class="nc"><i class="no-highlight">3348</i>&nbsp;                    return index &amp; ~IN.EXACT_MATCH;</b>
<i class="no-highlight">3349</i>&nbsp;                }
<i class="no-highlight">3350</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">3351</i>&nbsp;                getEvictor().incBinDeltaBlindOps();</b>
<i class="no-highlight">3352</i>&nbsp;
<i class="no-highlight">3353</i>&nbsp;                if (traceDeltas) {
<i class="no-highlight">3354</i>&nbsp;                    LoggerUtils.envLogMsg(
<i class="no-highlight">3355</i>&nbsp;                        traceLevel, getEnv(),
<i class="no-highlight">3356</i>&nbsp;                        Thread.currentThread().getId() + &quot;-&quot; +
<i class="no-highlight">3357</i>&nbsp;                        Thread.currentThread().getName() +
<i class="no-highlight">3358</i>&nbsp;                        &quot;-&quot; + getEnv().getName() +
<i class="no-highlight">3359</i>&nbsp;                        (blindInsertion ?
<i class="no-highlight">3360</i>&nbsp;                         &quot; Blind insertion in BIN-delta &quot; :
<i class="no-highlight">3361</i>&nbsp;                         &quot; Blind put in BIN-delta &quot;) +
<i class="no-highlight">3362</i>&nbsp;                        getNodeId() + &quot; nEntries = &quot; +
<i class="no-highlight">3363</i>&nbsp;                        nEntries + &quot; max entries = &quot; +
<i class="no-highlight">3364</i>&nbsp;                        getMaxEntries() +
<i class="no-highlight">3365</i>&nbsp;                        &quot; full BIN entries = &quot; +
<i class="no-highlight">3366</i>&nbsp;                        bin.getFullBinNEntries() +
<i class="no-highlight">3367</i>&nbsp;                        &quot; full BIN max entries = &quot; +
<i class="no-highlight">3368</i>&nbsp;                        bin.getFullBinMaxEntries());
<i class="no-highlight">3369</i>&nbsp;                }
<i class="no-highlight">3370</i>&nbsp;            }
<i class="no-highlight">3371</i>&nbsp;        }
<i class="no-highlight">3372</i>&nbsp;
<b class="fc"><i class="no-highlight">3373</i>&nbsp;        if (nEntries &gt;= getMaxEntries()) {</b>
<b class="nc"><i class="no-highlight">3374</i>&nbsp;            throw unexpectedState(</b>
<b class="nc"><i class="no-highlight">3375</i>&nbsp;                getEnv(),</b>
<b class="nc"><i class="no-highlight">3376</i>&nbsp;                &quot;Node &quot; + getNodeId() +</b>
<i class="no-highlight">3377</i>&nbsp;                &quot; should have been split before calling insertEntry&quot; +
<b class="nc"><i class="no-highlight">3378</i>&nbsp;                &quot; is BIN-delta: &quot; + isBINDelta() +</b>
<i class="no-highlight">3379</i>&nbsp;                &quot; num entries: &quot; + nEntries +
<b class="nc"><i class="no-highlight">3380</i>&nbsp;                &quot; max entries: &quot; + getMaxEntries());</b>
<i class="no-highlight">3381</i>&nbsp;        }
<i class="no-highlight">3382</i>&nbsp;
<i class="no-highlight">3383</i>&nbsp;        /* There was no key match, so insert to the right of this entry. */
<b class="fc"><i class="no-highlight">3384</i>&nbsp;        index++;</b>
<i class="no-highlight">3385</i>&nbsp;
<i class="no-highlight">3386</i>&nbsp;        /* We found a spot for insert, shift entries as needed. */
<b class="fc"><i class="no-highlight">3387</i>&nbsp;        if (index &lt; nEntries) {</b>
<b class="fc"><i class="no-highlight">3388</i>&nbsp;            int oldSize = computeLsnOverhead();</b>
<i class="no-highlight">3389</i>&nbsp;
<i class="no-highlight">3390</i>&nbsp;            /* Adding elements to the LSN array can change the space used. */
<b class="fc"><i class="no-highlight">3391</i>&nbsp;            shiftEntriesRight(index);</b>
<i class="no-highlight">3392</i>&nbsp;
<b class="fc"><i class="no-highlight">3393</i>&nbsp;            updateMemorySize(computeLsnOverhead() - oldSize);</b>
<b class="fc"><i class="no-highlight">3394</i>&nbsp;        } else {</b>
<b class="fc"><i class="no-highlight">3395</i>&nbsp;            nEntries++;</b>
<i class="no-highlight">3396</i>&nbsp;        }
<i class="no-highlight">3397</i>&nbsp;
<b class="fc"><i class="no-highlight">3398</i>&nbsp;        if (isBINDelta()) {</b>
<b class="fc"><i class="no-highlight">3399</i>&nbsp;            ((BIN)this).incFullBinNEntries();</b>
<i class="no-highlight">3400</i>&nbsp;        }
<i class="no-highlight">3401</i>&nbsp;
<b class="fc"><i class="no-highlight">3402</i>&nbsp;        int oldSize = computeLsnOverhead();</b>
<i class="no-highlight">3403</i>&nbsp;
<b class="fc"><i class="no-highlight">3404</i>&nbsp;        if (data == null || databaseImpl.isDeferredWriteMode()) {</b>
<b class="fc"><i class="no-highlight">3405</i>&nbsp;            setTarget(index, child);</b>
<i class="no-highlight">3406</i>&nbsp;        }
<i class="no-highlight">3407</i>&nbsp;
<b class="fc"><i class="no-highlight">3408</i>&nbsp;        setLsnInternal(index, childLsn);</b>
<i class="no-highlight">3409</i>&nbsp;
<b class="fc"><i class="no-highlight">3410</i>&nbsp;        boolean multiSlotChange = insertKey(index, key, data);</b>
<i class="no-highlight">3411</i>&nbsp;
<i class="no-highlight">3412</i>&nbsp;        /*
<i class="no-highlight">3413</i>&nbsp;         * Do this after calling insert key to overwrite whatever state changes
<i class="no-highlight">3414</i>&nbsp;         * were done by the insertEntry() call.
<i class="no-highlight">3415</i>&nbsp;         */
<b class="fc"><i class="no-highlight">3416</i>&nbsp;        entryStates[index] = state;</b>
<i class="no-highlight">3417</i>&nbsp;
<b class="fc"><i class="no-highlight">3418</i>&nbsp;        if (data != null) {</b>
<b class="nc"><i class="no-highlight">3419</i>&nbsp;            setEmbeddedLN(index);</b>
<b class="nc"><i class="no-highlight">3420</i>&nbsp;            if (data.length == 0) {</b>
<b class="nc"><i class="no-highlight">3421</i>&nbsp;                setNoDataLN(index);</b>
<i class="no-highlight">3422</i>&nbsp;            }
<i class="no-highlight">3423</i>&nbsp;        }
<i class="no-highlight">3424</i>&nbsp;
<b class="fc"><i class="no-highlight">3425</i>&nbsp;        adjustCursorsForInsert(index);</b>
<i class="no-highlight">3426</i>&nbsp;
<b class="fc"><i class="no-highlight">3427</i>&nbsp;        updateMemorySize(oldSize,</b>
<b class="fc"><i class="no-highlight">3428</i>&nbsp;                         getEntryInMemorySize(index) +</b>
<b class="fc"><i class="no-highlight">3429</i>&nbsp;                         computeLsnOverhead());</b>
<i class="no-highlight">3430</i>&nbsp;
<b class="fc"><i class="no-highlight">3431</i>&nbsp;        if (multiSlotChange) {</b>
<b class="nc"><i class="no-highlight">3432</i>&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</b>
<i class="no-highlight">3433</i>&nbsp;        }
<i class="no-highlight">3434</i>&nbsp;
<b class="fc"><i class="no-highlight">3435</i>&nbsp;        setDirty(true);</b>
<i class="no-highlight">3436</i>&nbsp;
<b class="fc"><i class="no-highlight">3437</i>&nbsp;        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());</b>
<i class="no-highlight">3438</i>&nbsp;
<b class="fc"><i class="no-highlight">3439</i>&nbsp;        return (index | INSERT_SUCCESS);</b>
<i class="no-highlight">3440</i>&nbsp;    }
<i class="no-highlight">3441</i>&nbsp;
<i class="no-highlight">3442</i>&nbsp;    /**
<i class="no-highlight">3443</i>&nbsp;     * Removes the slot at index from this IN.  Assumes this node is already
<i class="no-highlight">3444</i>&nbsp;     * latched by the caller.
<i class="no-highlight">3445</i>&nbsp;     *
<i class="no-highlight">3446</i>&nbsp;     * @param index The index of the entry to delete from the IN.
<i class="no-highlight">3447</i>&nbsp;     */
<i class="no-highlight">3448</i>&nbsp;    public void deleteEntry(int index) {
<b class="nc"><i class="no-highlight">3449</i>&nbsp;        deleteEntry(index, true /*makeDirty*/, true /*validate*/);</b>
<b class="nc"><i class="no-highlight">3450</i>&nbsp;    }</b>
<i class="no-highlight">3451</i>&nbsp;
<i class="no-highlight">3452</i>&nbsp;    /**
<i class="no-highlight">3453</i>&nbsp;     * Variant that allows specifying whether the IN is dirtied and whether
<i class="no-highlight">3454</i>&nbsp;     * validation takes place. &#39;validate&#39; should be false only in tests.
<i class="no-highlight">3455</i>&nbsp;     *
<i class="no-highlight">3456</i>&nbsp;     * See BIN.compress and INCompressor for a discussion about why slots can
<i class="no-highlight">3457</i>&nbsp;     * be deleted without dirtying the BIN, and why the next delta is
<i class="no-highlight">3458</i>&nbsp;     * prohibited when the slot is dirty.
<i class="no-highlight">3459</i>&nbsp;     */
<i class="no-highlight">3460</i>&nbsp;    void deleteEntry(int index, boolean makeDirty, boolean validate) {
<i class="no-highlight">3461</i>&nbsp;
<b class="nc"><i class="no-highlight">3462</i>&nbsp;        assert !isBINDelta();</b>
<b class="nc"><i class="no-highlight">3463</i>&nbsp;        assert index &gt;= 0 &amp;&amp; index &lt; nEntries;</b>
<b class="nc"><i class="no-highlight">3464</i>&nbsp;        assert !validate || validateSubtreeBeforeDelete(index);</b>
<i class="no-highlight">3465</i>&nbsp;
<b class="nc"><i class="no-highlight">3466</i>&nbsp;        if (makeDirty) {</b>
<b class="nc"><i class="no-highlight">3467</i>&nbsp;            setDirty(true);</b>
<i class="no-highlight">3468</i>&nbsp;        }
<i class="no-highlight">3469</i>&nbsp;
<b class="nc"><i class="no-highlight">3470</i>&nbsp;        if (isDirty(index)) {</b>
<b class="nc"><i class="no-highlight">3471</i>&nbsp;            setProhibitNextDelta(true);</b>
<i class="no-highlight">3472</i>&nbsp;        }
<i class="no-highlight">3473</i>&nbsp;
<b class="nc"><i class="no-highlight">3474</i>&nbsp;        Node child = getTarget(index);</b>
<i class="no-highlight">3475</i>&nbsp;
<b class="nc"><i class="no-highlight">3476</i>&nbsp;        final OffHeapCache ohCache = getEnv().getOffHeapCache();</b>
<b class="nc"><i class="no-highlight">3477</i>&nbsp;        final int level = getNormalizedLevel();</b>
<b class="nc"><i class="no-highlight">3478</i>&nbsp;        if (level == 1) {</b>
<b class="nc"><i class="no-highlight">3479</i>&nbsp;            ohCache.freeLN((BIN) this, index);</b>
<b class="nc"><i class="no-highlight">3480</i>&nbsp;        } else if (level == 2) {</b>
<b class="nc"><i class="no-highlight">3481</i>&nbsp;            ohCache.freeBIN((BIN) child, this, index);</b>
<i class="no-highlight">3482</i>&nbsp;        }
<i class="no-highlight">3483</i>&nbsp;
<b class="nc"><i class="no-highlight">3484</i>&nbsp;        if (child != null &amp;&amp; child.isIN()) {</b>
<b class="nc"><i class="no-highlight">3485</i>&nbsp;            IN childIN = (IN)child;</b>
<b class="nc"><i class="no-highlight">3486</i>&nbsp;            getEnv().getInMemoryINs().remove(childIN);</b>
<i class="no-highlight">3487</i>&nbsp;        }
<i class="no-highlight">3488</i>&nbsp;
<b class="nc"><i class="no-highlight">3489</i>&nbsp;        updateMemorySize(getEntryInMemorySize(index), 0);</b>
<b class="nc"><i class="no-highlight">3490</i>&nbsp;        int oldLSNArraySize = computeLsnOverhead();</b>
<i class="no-highlight">3491</i>&nbsp;
<i class="no-highlight">3492</i>&nbsp;        /*
<i class="no-highlight">3493</i>&nbsp;         * Do the actual deletion. Note: setTarget() must be called before
<i class="no-highlight">3494</i>&nbsp;         * copyEntries() so that the hasCachedChildrenFlag will be properly
<i class="no-highlight">3495</i>&nbsp;         * maintained.
<i class="no-highlight">3496</i>&nbsp;         */
<b class="nc"><i class="no-highlight">3497</i>&nbsp;        setTarget(index, null);</b>
<b class="nc"><i class="no-highlight">3498</i>&nbsp;        copyEntries(index + 1, index, nEntries - index - 1);</b>
<b class="nc"><i class="no-highlight">3499</i>&nbsp;        nEntries--;</b>
<i class="no-highlight">3500</i>&nbsp;
<i class="no-highlight">3501</i>&nbsp;        /* cleanup what used to be the last entry */
<b class="nc"><i class="no-highlight">3502</i>&nbsp;        clearEntry(nEntries);</b>
<i class="no-highlight">3503</i>&nbsp;
<i class="no-highlight">3504</i>&nbsp;        /* setLsnInternal can mutate to an array of longs. */
<b class="nc"><i class="no-highlight">3505</i>&nbsp;        updateMemorySize(oldLSNArraySize, computeLsnOverhead());</b>
<i class="no-highlight">3506</i>&nbsp;
<b class="nc"><i class="no-highlight">3507</i>&nbsp;        assert(isBIN() || hasCachedChildrenFlag() == hasCachedChildren());</b>
<i class="no-highlight">3508</i>&nbsp;
<i class="no-highlight">3509</i>&nbsp;        /*
<i class="no-highlight">3510</i>&nbsp;         * Note that we don&#39;t have to adjust cursors for delete, since
<i class="no-highlight">3511</i>&nbsp;         * there should be nothing pointing at this record.
<i class="no-highlight">3512</i>&nbsp;         */
<b class="nc"><i class="no-highlight">3513</i>&nbsp;        traceDelete(Level.FINEST, index);</b>
<b class="nc"><i class="no-highlight">3514</i>&nbsp;    }</b>
<i class="no-highlight">3515</i>&nbsp;
<i class="no-highlight">3516</i>&nbsp;    /**
<i class="no-highlight">3517</i>&nbsp;     * WARNING: clearEntry() calls entryTargets.set() directly, instead of
<i class="no-highlight">3518</i>&nbsp;     * setTarget(). As a result, the hasCachedChildren flag of the IN is not
<i class="no-highlight">3519</i>&nbsp;     * updated here. The caller is responsible for updating this flag, if
<i class="no-highlight">3520</i>&nbsp;     * needed.
<i class="no-highlight">3521</i>&nbsp;     */
<i class="no-highlight">3522</i>&nbsp;    void clearEntry(int idx) {
<i class="no-highlight">3523</i>&nbsp;
<b class="fc"><i class="no-highlight">3524</i>&nbsp;        entryTargets = entryTargets.set(idx, null, this);</b>
<b class="fc"><i class="no-highlight">3525</i>&nbsp;        entryKeys = entryKeys.set(idx, null, this);</b>
<b class="fc"><i class="no-highlight">3526</i>&nbsp;        offHeapBINIds = offHeapBINIds.set(idx, 0, this);</b>
<b class="fc"><i class="no-highlight">3527</i>&nbsp;        setLsnInternal(idx, DbLsn.NULL_LSN);</b>
<b class="fc"><i class="no-highlight">3528</i>&nbsp;        entryStates[idx] = 0;</b>
<b class="fc"><i class="no-highlight">3529</i>&nbsp;    }</b>
<i class="no-highlight">3530</i>&nbsp;
<i class="no-highlight">3531</i>&nbsp;    /**
<i class="no-highlight">3532</i>&nbsp;     * This method is called after the idx&#39;th child of this node gets logged,
<i class="no-highlight">3533</i>&nbsp;     * and changes position as a result. 
<i class="no-highlight">3534</i>&nbsp;     *
<i class="no-highlight">3535</i>&nbsp;     * @param newLSN The new on-disk position of the child.
<i class="no-highlight">3536</i>&nbsp;     *
<i class="no-highlight">3537</i>&nbsp;     * @param newVLSN The VLSN of the logrec at the new position.
<i class="no-highlight">3538</i>&nbsp;     * For LN children only.
<i class="no-highlight">3539</i>&nbsp;     *
<i class="no-highlight">3540</i>&nbsp;     * @param newSize The size of the logrec at the new position.
<i class="no-highlight">3541</i>&nbsp;     * For LN children only.
<i class="no-highlight">3542</i>&nbsp;     */
<i class="no-highlight">3543</i>&nbsp;    public final void updateEntry(
<i class="no-highlight">3544</i>&nbsp;        int idx,
<i class="no-highlight">3545</i>&nbsp;        long newLSN,
<i class="no-highlight">3546</i>&nbsp;        long newVLSN,
<i class="no-highlight">3547</i>&nbsp;        int newSize) {
<i class="no-highlight">3548</i>&nbsp;
<b class="fc"><i class="no-highlight">3549</i>&nbsp;        setLsn(idx, newLSN);</b>
<i class="no-highlight">3550</i>&nbsp;
<b class="fc"><i class="no-highlight">3551</i>&nbsp;        if (isBIN()) {</b>
<b class="fc"><i class="no-highlight">3552</i>&nbsp;            if (isEmbeddedLN(idx)) {</b>
<b class="nc"><i class="no-highlight">3553</i>&nbsp;                ((BIN)this).setCachedVLSN(idx, newVLSN);</b>
<i class="no-highlight">3554</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">3555</i>&nbsp;                setLastLoggedSize(idx, newSize);</b>
<i class="no-highlight">3556</i>&nbsp;            }
<i class="no-highlight">3557</i>&nbsp;        }
<i class="no-highlight">3558</i>&nbsp;
<b class="fc"><i class="no-highlight">3559</i>&nbsp;        setDirty(true);</b>
<b class="fc"><i class="no-highlight">3560</i>&nbsp;    }</b>
<i class="no-highlight">3561</i>&nbsp;
<i class="no-highlight">3562</i>&nbsp;    /**
<i class="no-highlight">3563</i>&nbsp;     * This method is called only from BIN.applyDelta(). It applies the info
<i class="no-highlight">3564</i>&nbsp;     * extracted from a delta slot to the corresponding slot in the full BIN.
<i class="no-highlight">3565</i>&nbsp;     *
<i class="no-highlight">3566</i>&nbsp;     * Unlike other update methods, the LSN may be NULL_LSN if the KD flag is
<i class="no-highlight">3567</i>&nbsp;     * set. This allows applying a BIN-delta with a NULL_LSN and KD, for an
<i class="no-highlight">3568</i>&nbsp;     * invisible log entry for example.
<i class="no-highlight">3569</i>&nbsp;     *
<i class="no-highlight">3570</i>&nbsp;     * No need to do memory counting in this method because the BIN is not
<i class="no-highlight">3571</i>&nbsp;     * yet attached to the tree.
<i class="no-highlight">3572</i>&nbsp;     */
<i class="no-highlight">3573</i>&nbsp;    final void applyDeltaSlot(
<i class="no-highlight">3574</i>&nbsp;        int idx,
<i class="no-highlight">3575</i>&nbsp;        Node node,
<i class="no-highlight">3576</i>&nbsp;        long lsn,
<i class="no-highlight">3577</i>&nbsp;        int lastLoggedSize,
<i class="no-highlight">3578</i>&nbsp;        byte state,
<i class="no-highlight">3579</i>&nbsp;        byte[] key,
<i class="no-highlight">3580</i>&nbsp;        byte[] data) {
<i class="no-highlight">3581</i>&nbsp;
<b class="fc"><i class="no-highlight">3582</i>&nbsp;        assert(isBIN());</b>
<b class="fc"><i class="no-highlight">3583</i>&nbsp;        assert(!isBINDelta());</b>
<b class="fc"><i class="no-highlight">3584</i>&nbsp;        assert(lsn != DbLsn.NULL_LSN ||</b>
<i class="no-highlight">3585</i>&nbsp;               (state &amp; EntryStates.KNOWN_DELETED_BIT) != 0);
<b class="fc"><i class="no-highlight">3586</i>&nbsp;        assert(node == null || data == null);</b>
<b class="fc"><i class="no-highlight">3587</i>&nbsp;        assert(!getInListResident());</b>
<i class="no-highlight">3588</i>&nbsp;
<b class="fc"><i class="no-highlight">3589</i>&nbsp;        ((BIN) this).freeOffHeapLN(idx);</b>
<i class="no-highlight">3590</i>&nbsp;
<b class="fc"><i class="no-highlight">3591</i>&nbsp;        setLsn(idx, lsn, false/*check*/);</b>
<b class="fc"><i class="no-highlight">3592</i>&nbsp;        setLastLoggedSize(idx, lastLoggedSize);</b>
<b class="fc"><i class="no-highlight">3593</i>&nbsp;        setTarget(idx, node);</b>
<i class="no-highlight">3594</i>&nbsp;
<b class="fc"><i class="no-highlight">3595</i>&nbsp;        updateLNSlotKey(idx, key, data);</b>
<i class="no-highlight">3596</i>&nbsp;
<b class="fc"><i class="no-highlight">3597</i>&nbsp;        assert(isEmbeddedLN(idx) == isEmbeddedLN(state));</b>
<b class="fc"><i class="no-highlight">3598</i>&nbsp;        assert(isNoDataLN(idx) == isNoDataLN(state));</b>
<i class="no-highlight">3599</i>&nbsp;
<b class="fc"><i class="no-highlight">3600</i>&nbsp;        entryStates[idx] = state;</b>
<i class="no-highlight">3601</i>&nbsp;
<b class="fc"><i class="no-highlight">3602</i>&nbsp;        setDirty(true);</b>
<b class="fc"><i class="no-highlight">3603</i>&nbsp;    }</b>
<i class="no-highlight">3604</i>&nbsp;
<i class="no-highlight">3605</i>&nbsp;    /**
<i class="no-highlight">3606</i>&nbsp;     * Update the idx slot of this BIN to reflect a record insertion in an
<i class="no-highlight">3607</i>&nbsp;     * existing KD slot. It is called from CursorImpl.insertRecordInternal(),
<i class="no-highlight">3608</i>&nbsp;     * after logging the insertion op.
<i class="no-highlight">3609</i>&nbsp;     *
<i class="no-highlight">3610</i>&nbsp;     * @param newLN The LN associated with the new record.
<i class="no-highlight">3611</i>&nbsp;     *
<i class="no-highlight">3612</i>&nbsp;     * @param newLSN The LSN of the insertion logrec.
<i class="no-highlight">3613</i>&nbsp;     *
<i class="no-highlight">3614</i>&nbsp;     * @param newSize The size of the insertion logrec.
<i class="no-highlight">3615</i>&nbsp;     *
<i class="no-highlight">3616</i>&nbsp;     * @param newKey The value for the record&#39;s key. It is equal to the current
<i class="no-highlight">3617</i>&nbsp;     * key value in the slot, but may not be identical to that value if a
<i class="no-highlight">3618</i>&nbsp;     * custom comparator is used.
<i class="no-highlight">3619</i>&nbsp;     *
<i class="no-highlight">3620</i>&nbsp;     * @param newData If the record&#39;s data must be embedded in this BIN, &quot;data&quot;
<i class="no-highlight">3621</i>&nbsp;     * stores the record&#39;s data. Null otherwise. See also comment for the
<i class="no-highlight">3622</i>&nbsp;     * keyEntries field.
<i class="no-highlight">3623</i>&nbsp;     */
<i class="no-highlight">3624</i>&nbsp;    public final void insertRecord(
<i class="no-highlight">3625</i>&nbsp;        int idx,
<i class="no-highlight">3626</i>&nbsp;        LN newLN,
<i class="no-highlight">3627</i>&nbsp;        long newLSN,
<i class="no-highlight">3628</i>&nbsp;        int newSize,
<i class="no-highlight">3629</i>&nbsp;        byte[] newKey,
<i class="no-highlight">3630</i>&nbsp;        byte[] newData,
<i class="no-highlight">3631</i>&nbsp;        int expiration,
<i class="no-highlight">3632</i>&nbsp;        boolean expirationInHours) {
<i class="no-highlight">3633</i>&nbsp;
<b class="nc"><i class="no-highlight">3634</i>&nbsp;        assert(isBIN());</b>
<i class="no-highlight">3635</i>&nbsp;
<b class="nc"><i class="no-highlight">3636</i>&nbsp;        final BIN bin = (BIN) this;</b>
<i class="no-highlight">3637</i>&nbsp;
<b class="nc"><i class="no-highlight">3638</i>&nbsp;        bin.freeOffHeapLN(idx); // old version of the LN is stale</b>
<i class="no-highlight">3639</i>&nbsp;
<b class="nc"><i class="no-highlight">3640</i>&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</b>
<i class="no-highlight">3641</i>&nbsp;
<b class="nc"><i class="no-highlight">3642</i>&nbsp;        setLsn(idx, newLSN);</b>
<i class="no-highlight">3643</i>&nbsp;
<b class="nc"><i class="no-highlight">3644</i>&nbsp;        boolean multiSlotChange = updateLNSlotKey(idx, newKey, newData);</b>
<i class="no-highlight">3645</i>&nbsp;
<b class="nc"><i class="no-highlight">3646</i>&nbsp;        if (isEmbeddedLN(idx)) {</b>
<i class="no-highlight">3647</i>&nbsp;
<b class="nc"><i class="no-highlight">3648</i>&nbsp;            clearLastLoggedSize(idx);</b>
<i class="no-highlight">3649</i>&nbsp;
<b class="nc"><i class="no-highlight">3650</i>&nbsp;            bin.setCachedVLSN(idx, newLN.getVLSNSequence());</b>
<i class="no-highlight">3651</i>&nbsp;
<b class="nc"><i class="no-highlight">3652</i>&nbsp;            if (databaseImpl.isDeferredWriteMode()) {</b>
<b class="nc"><i class="no-highlight">3653</i>&nbsp;                setTarget(idx, newLN);</b>
<i class="no-highlight">3654</i>&nbsp;            }
<i class="no-highlight">3655</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">3656</i>&nbsp;            setTarget(idx, newLN);</b>
<b class="nc"><i class="no-highlight">3657</i>&nbsp;            setLastLoggedSize(idx, newSize);</b>
<i class="no-highlight">3658</i>&nbsp;        }
<i class="no-highlight">3659</i>&nbsp;
<b class="nc"><i class="no-highlight">3660</i>&nbsp;        bin.setExpiration(idx, expiration, expirationInHours);</b>
<i class="no-highlight">3661</i>&nbsp;
<b class="nc"><i class="no-highlight">3662</i>&nbsp;        if (multiSlotChange) {</b>
<b class="nc"><i class="no-highlight">3663</i>&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</b>
<i class="no-highlight">3664</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">3665</i>&nbsp;            long newSlotSize = getEntryInMemorySize(idx);</b>
<b class="nc"><i class="no-highlight">3666</i>&nbsp;            updateMemorySize(oldSlotSize, newSlotSize);</b>
<i class="no-highlight">3667</i>&nbsp;        }
<i class="no-highlight">3668</i>&nbsp;
<b class="nc"><i class="no-highlight">3669</i>&nbsp;        clearKnownDeleted(idx);</b>
<b class="nc"><i class="no-highlight">3670</i>&nbsp;        clearPendingDeleted(idx);</b>
<b class="nc"><i class="no-highlight">3671</i>&nbsp;        setDirty(true);</b>
<i class="no-highlight">3672</i>&nbsp;
<b class="nc"><i class="no-highlight">3673</i>&nbsp;        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());</b>
<b class="nc"><i class="no-highlight">3674</i>&nbsp;    }</b>
<i class="no-highlight">3675</i>&nbsp;
<i class="no-highlight">3676</i>&nbsp;    /**
<i class="no-highlight">3677</i>&nbsp;     * Update the idx slot of this BIN to reflect an update of the associated
<i class="no-highlight">3678</i>&nbsp;     * record. It is called from CursorImpl.updateRecordInternal(), after
<i class="no-highlight">3679</i>&nbsp;     * logging the update op.
<i class="no-highlight">3680</i>&nbsp;     *
<i class="no-highlight">3681</i>&nbsp;     * @param oldMemSize If the child LN was cached before the update op, it has
<i class="no-highlight">3682</i>&nbsp;     * already been updated in-place by the caller. In this case, oldMemSize
<i class="no-highlight">3683</i>&nbsp;     * stores the size of the child LN before the update, and it is used to do
<i class="no-highlight">3684</i>&nbsp;     * memory counting. Otherwise oldMemSize is 0 and the newly created LN has
<i class="no-highlight">3685</i>&nbsp;     * not been attached to the tree; it will be attached later by the caller,
<i class="no-highlight">3686</i>&nbsp;     * if needed.
<i class="no-highlight">3687</i>&nbsp;     *
<i class="no-highlight">3688</i>&nbsp;     * @param newLSN The LSN of the update logrec.
<i class="no-highlight">3689</i>&nbsp;     *
<i class="no-highlight">3690</i>&nbsp;     * @param newVLSN The VLSN of the update logrec.
<i class="no-highlight">3691</i>&nbsp;     *
<i class="no-highlight">3692</i>&nbsp;     * @param newSize The on-disk size of the update logrec.
<i class="no-highlight">3693</i>&nbsp;     *
<i class="no-highlight">3694</i>&nbsp;     * @param newKey The new value for the record&#39;s key. It is equal to the
<i class="no-highlight">3695</i>&nbsp;     * current value, but may not be identical to the current value if a
<i class="no-highlight">3696</i>&nbsp;     * custom comparator is used. It may be null, if the caller knows for
<i class="no-highlight">3697</i>&nbsp;     * sure that the key does not change.
<i class="no-highlight">3698</i>&nbsp;     *
<i class="no-highlight">3699</i>&nbsp;     * @param newData If the record&#39;s data must be embedded in this BIN, &quot;data&quot;
<i class="no-highlight">3700</i>&nbsp;     * stores the record&#39;s data. Null otherwise. See also comment for the
<i class="no-highlight">3701</i>&nbsp;     * keyEntries field.
<i class="no-highlight">3702</i>&nbsp;     */
<i class="no-highlight">3703</i>&nbsp;    public final void updateRecord(
<i class="no-highlight">3704</i>&nbsp;        int idx,
<i class="no-highlight">3705</i>&nbsp;        long oldMemSize,
<i class="no-highlight">3706</i>&nbsp;        long newLSN,
<i class="no-highlight">3707</i>&nbsp;        long newVLSN,
<i class="no-highlight">3708</i>&nbsp;        int newSize,
<i class="no-highlight">3709</i>&nbsp;        byte[] newKey,
<i class="no-highlight">3710</i>&nbsp;        byte[] newData,
<i class="no-highlight">3711</i>&nbsp;        int expiration,
<i class="no-highlight">3712</i>&nbsp;        boolean expirationInHours) {
<i class="no-highlight">3713</i>&nbsp;
<b class="fc"><i class="no-highlight">3714</i>&nbsp;        assert(isBIN());</b>
<i class="no-highlight">3715</i>&nbsp;
<b class="fc"><i class="no-highlight">3716</i>&nbsp;        final BIN bin = (BIN) this;</b>
<i class="no-highlight">3717</i>&nbsp;
<b class="fc"><i class="no-highlight">3718</i>&nbsp;        bin.freeOffHeapLN(idx); // old version of the LN is stale</b>
<i class="no-highlight">3719</i>&nbsp;
<b class="fc"><i class="no-highlight">3720</i>&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</b>
<i class="no-highlight">3721</i>&nbsp;
<b class="fc"><i class="no-highlight">3722</i>&nbsp;        setLsn(idx, newLSN);</b>
<i class="no-highlight">3723</i>&nbsp;
<b class="fc"><i class="no-highlight">3724</i>&nbsp;        boolean multiSlotChange = updateLNSlotKey(idx, newKey, newData);</b>
<i class="no-highlight">3725</i>&nbsp;
<b class="fc"><i class="no-highlight">3726</i>&nbsp;        if (isEmbeddedLN(idx)) {</b>
<b class="nc"><i class="no-highlight">3727</i>&nbsp;            clearLastLoggedSize(idx);</b>
<b class="nc"><i class="no-highlight">3728</i>&nbsp;            ((BIN)this).setCachedVLSN(idx, newVLSN);</b>
<i class="no-highlight">3729</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">3730</i>&nbsp;            setLastLoggedSize(idx, newSize);</b>
<i class="no-highlight">3731</i>&nbsp;        }
<i class="no-highlight">3732</i>&nbsp;
<b class="fc"><i class="no-highlight">3733</i>&nbsp;        bin.setExpiration(idx, expiration, expirationInHours);</b>
<i class="no-highlight">3734</i>&nbsp;
<b class="fc"><i class="no-highlight">3735</i>&nbsp;        if (multiSlotChange) {</b>
<b class="nc"><i class="no-highlight">3736</i>&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</b>
<i class="no-highlight">3737</i>&nbsp;        } else {
<i class="no-highlight">3738</i>&nbsp;            /* Update mem size for key change. */
<b class="fc"><i class="no-highlight">3739</i>&nbsp;            long newSlotSize = getEntryInMemorySize(idx);</b>
<b class="fc"><i class="no-highlight">3740</i>&nbsp;            updateMemorySize(oldSlotSize, newSlotSize);</b>
<i class="no-highlight">3741</i>&nbsp;
<i class="no-highlight">3742</i>&nbsp;            /* Update mem size for node change. */
<b class="fc"><i class="no-highlight">3743</i>&nbsp;            Node newLN = entryTargets.get(idx);</b>
<b class="fc"><i class="no-highlight">3744</i>&nbsp;            long newMemSize =</b>
<b class="fc"><i class="no-highlight">3745</i>&nbsp;                (newLN != null ? newLN.getMemorySizeIncludedByParent() : 0);</b>
<b class="fc"><i class="no-highlight">3746</i>&nbsp;            updateMemorySize(oldMemSize, newMemSize);</b>
<i class="no-highlight">3747</i>&nbsp;        }
<i class="no-highlight">3748</i>&nbsp;
<b class="fc"><i class="no-highlight">3749</i>&nbsp;        setDirty(true);</b>
<b class="fc"><i class="no-highlight">3750</i>&nbsp;    }</b>
<i class="no-highlight">3751</i>&nbsp;
<i class="no-highlight">3752</i>&nbsp;    /**
<i class="no-highlight">3753</i>&nbsp;     * Update the idx slot slot of this BIN to reflect a deletion of the 
<i class="no-highlight">3754</i>&nbsp;     * associated record. It is called from CursorImpl.deleteCurrentRecord(),
<i class="no-highlight">3755</i>&nbsp;     * after logging the deletion op.
<i class="no-highlight">3756</i>&nbsp;     *
<i class="no-highlight">3757</i>&nbsp;     * @param oldMemSize If the child LN was cached before the deletion, it
<i class="no-highlight">3758</i>&nbsp;     * has already been updated in-place by the caller (the ln contents have
<i class="no-highlight">3759</i>&nbsp;     * been deleted). In this case, oldMemSize stores the in-memory size of
<i class="no-highlight">3760</i>&nbsp;     * the child LN before the update, and it is used to do memory counting.
<i class="no-highlight">3761</i>&nbsp;     * Otherwise oldMemSize is 0 and the newly created LN has not been attached
<i class="no-highlight">3762</i>&nbsp;     * to the tree; it will be attached later by the caller, if needed.
<i class="no-highlight">3763</i>&nbsp;     *
<i class="no-highlight">3764</i>&nbsp;     * @param newLSN The LSN of the deletion logrec.
<i class="no-highlight">3765</i>&nbsp;     *
<i class="no-highlight">3766</i>&nbsp;     * @param newVLSN The VLSN of the deletion logrec.
<i class="no-highlight">3767</i>&nbsp;     *
<i class="no-highlight">3768</i>&nbsp;     * @param newSize The on-disk size of the deletion logrec.
<i class="no-highlight">3769</i>&nbsp;     */
<i class="no-highlight">3770</i>&nbsp;    public final void deleteRecord(
<i class="no-highlight">3771</i>&nbsp;        int idx,
<i class="no-highlight">3772</i>&nbsp;        long oldMemSize,
<i class="no-highlight">3773</i>&nbsp;        long newLSN,
<i class="no-highlight">3774</i>&nbsp;        long newVLSN,
<i class="no-highlight">3775</i>&nbsp;        int newSize) {
<i class="no-highlight">3776</i>&nbsp;
<b class="nc"><i class="no-highlight">3777</i>&nbsp;        assert(isBIN());</b>
<i class="no-highlight">3778</i>&nbsp;
<b class="nc"><i class="no-highlight">3779</i>&nbsp;        final BIN bin = (BIN) this;</b>
<i class="no-highlight">3780</i>&nbsp;
<b class="nc"><i class="no-highlight">3781</i>&nbsp;        bin.freeOffHeapLN(idx); // old version of the LN is stale</b>
<i class="no-highlight">3782</i>&nbsp;
<b class="nc"><i class="no-highlight">3783</i>&nbsp;        setLsn(idx, newLSN);</b>
<i class="no-highlight">3784</i>&nbsp;
<b class="nc"><i class="no-highlight">3785</i>&nbsp;        if (isEmbeddedLN(idx)) {</b>
<b class="nc"><i class="no-highlight">3786</i>&nbsp;            clearLastLoggedSize(idx);</b>
<b class="nc"><i class="no-highlight">3787</i>&nbsp;            bin.setCachedVLSN(idx, newVLSN);</b>
<i class="no-highlight">3788</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">3789</i>&nbsp;            setLastLoggedSize(idx, newSize);</b>
<i class="no-highlight">3790</i>&nbsp;        }
<i class="no-highlight">3791</i>&nbsp;
<b class="nc"><i class="no-highlight">3792</i>&nbsp;        if (entryTargets.get(idx) != null) {</b>
<i class="no-highlight">3793</i>&nbsp;            /* Update mem size for node change. */
<b class="nc"><i class="no-highlight">3794</i>&nbsp;            assert(oldMemSize != 0);</b>
<b class="nc"><i class="no-highlight">3795</i>&nbsp;            Node newLN = entryTargets.get(idx);</b>
<b class="nc"><i class="no-highlight">3796</i>&nbsp;            long newMemSize = newLN.getMemorySizeIncludedByParent();</b>
<b class="nc"><i class="no-highlight">3797</i>&nbsp;            updateMemorySize(oldMemSize, newMemSize);</b>
<b class="nc"><i class="no-highlight">3798</i>&nbsp;        } else {</b>
<b class="nc"><i class="no-highlight">3799</i>&nbsp;            assert(oldMemSize == 0);</b>
<i class="no-highlight">3800</i>&nbsp;        }
<i class="no-highlight">3801</i>&nbsp;
<b class="nc"><i class="no-highlight">3802</i>&nbsp;        setPendingDeleted(idx);</b>
<b class="nc"><i class="no-highlight">3803</i>&nbsp;        setDirty(true);</b>
<b class="nc"><i class="no-highlight">3804</i>&nbsp;    }</b>
<i class="no-highlight">3805</i>&nbsp;
<i class="no-highlight">3806</i>&nbsp;    /**
<i class="no-highlight">3807</i>&nbsp;     * This method is used by the RecoveryManager to change the current version
<i class="no-highlight">3808</i>&nbsp;     * of a record, either to a later version (in case of redo), or to an 
<i class="no-highlight">3809</i>&nbsp;     * earlier version (in case of undo). The current version may or may not be
<i class="no-highlight">3810</i>&nbsp;     * cached as a child LN of this BIN (it may be only in case of txn abort
<i class="no-highlight">3811</i>&nbsp;     * during normal processing). If it is, it is evicted. The new version is
<i class="no-highlight">3812</i>&nbsp;     * not attached to the in-memory tree, to save memory during crash
<i class="no-highlight">3813</i>&nbsp;     * recovery.
<i class="no-highlight">3814</i>&nbsp;     *
<i class="no-highlight">3815</i>&nbsp;     * @param idx The BIN slot for the record.
<i class="no-highlight">3816</i>&nbsp;     *
<i class="no-highlight">3817</i>&nbsp;     * @param lsn The LSN of the new record version. It may be null in case of
<i class="no-highlight">3818</i>&nbsp;     * undo, if the logrec that is being undone is an insertion and the record
<i class="no-highlight">3819</i>&nbsp;     * did not exist at all in the DB before that insertion.
<i class="no-highlight">3820</i>&nbsp;     *
<i class="no-highlight">3821</i>&nbsp;     * @param knownDeleted True if the new version is a committed deletion.
<i class="no-highlight">3822</i>&nbsp;     *
<i class="no-highlight">3823</i>&nbsp;     * @param pendingDeleted True if the new version is a deletion, which 
<i class="no-highlight">3824</i>&nbsp;     * may or may not be committed.
<i class="no-highlight">3825</i>&nbsp;     *
<i class="no-highlight">3826</i>&nbsp;     * @param key The key of the new version. It is null only if we are undoing
<i class="no-highlight">3827</i>&nbsp;     * and the revert-to version was not embedded (in this case the key of the
<i class="no-highlight">3828</i>&nbsp;     * revert-to version is not stored in the logrec). If it is null and the
<i class="no-highlight">3829</i>&nbsp;     * DB allows key updates, the new record version is fetched from disk to
<i class="no-highlight">3830</i>&nbsp;     * retrieve its key, so that the key values stored in the BIN slots are
<i class="no-highlight">3831</i>&nbsp;     * always transactionally correct.
<i class="no-highlight">3832</i>&nbsp;     *
<i class="no-highlight">3833</i>&nbsp;     * @param data The data of the new version. It is non-null if and only if
<i class="no-highlight">3834</i>&nbsp;     * the new version must be embedded in the BIN.
<i class="no-highlight">3835</i>&nbsp;     *
<i class="no-highlight">3836</i>&nbsp;     * @param vlsn The VLSN of the new version.
<i class="no-highlight">3837</i>&nbsp;     *
<i class="no-highlight">3838</i>&nbsp;     * @param logrecSize The on-disk size of the logrec corresponding to the
<i class="no-highlight">3839</i>&nbsp;     * new version. It may be 0 (i.e. unknown) in case of undo. 
<i class="no-highlight">3840</i>&nbsp;     */
<i class="no-highlight">3841</i>&nbsp;    public final void recoverRecord(
<i class="no-highlight">3842</i>&nbsp;        int idx,
<i class="no-highlight">3843</i>&nbsp;        long lsn,
<i class="no-highlight">3844</i>&nbsp;        boolean knownDeleted,
<i class="no-highlight">3845</i>&nbsp;        boolean pendingDeleted,
<i class="no-highlight">3846</i>&nbsp;        byte[] key,
<i class="no-highlight">3847</i>&nbsp;        byte[] data,
<i class="no-highlight">3848</i>&nbsp;        long vlsn,
<i class="no-highlight">3849</i>&nbsp;        int logrecSize,
<i class="no-highlight">3850</i>&nbsp;        int expiration,
<i class="no-highlight">3851</i>&nbsp;        boolean expirationInHours) {
<i class="no-highlight">3852</i>&nbsp;
<b class="nc"><i class="no-highlight">3853</i>&nbsp;        assert(isBIN());</b>
<i class="no-highlight">3854</i>&nbsp;
<b class="nc"><i class="no-highlight">3855</i>&nbsp;        BIN bin = (BIN) this;</b>
<i class="no-highlight">3856</i>&nbsp;
<b class="nc"><i class="no-highlight">3857</i>&nbsp;        bin.freeOffHeapLN(idx); // old version of the LN is stale</b>
<i class="no-highlight">3858</i>&nbsp;
<b class="nc"><i class="no-highlight">3859</i>&nbsp;        if (lsn == DbLsn.NULL_LSN) {</b>
<i class="no-highlight">3860</i>&nbsp;
<i class="no-highlight">3861</i>&nbsp;            /*
<i class="no-highlight">3862</i>&nbsp;             * A NULL lsn means that we are undoing an insertion that was done
<i class="no-highlight">3863</i>&nbsp;             * without slot reuse. To undo such an insertion we evict the 
<i class="no-highlight">3864</i>&nbsp;             * current version (it may cached only in case of normal txn abort)
<i class="no-highlight">3865</i>&nbsp;             * and set the KD flag in the slot. We also set the LSN to null to
<i class="no-highlight">3866</i>&nbsp;             * ensure that the slot does not point to a logrec that does not
<i class="no-highlight">3867</i>&nbsp;             * reflect the slot&#39;s current state. The slot can then be put on
<i class="no-highlight">3868</i>&nbsp;             * the compressor for complete removal.
<i class="no-highlight">3869</i>&nbsp;             */
<b class="nc"><i class="no-highlight">3870</i>&nbsp;            setKnownDeletedAndEvictLN(idx);</b>
<i class="no-highlight">3871</i>&nbsp;
<b class="nc"><i class="no-highlight">3872</i>&nbsp;            setLsnInternal(idx, DbLsn.NULL_LSN);</b>
<i class="no-highlight">3873</i>&nbsp;
<b class="nc"><i class="no-highlight">3874</i>&nbsp;            bin.queueSlotDeletion(idx);</b>
<i class="no-highlight">3875</i>&nbsp;
<b class="nc"><i class="no-highlight">3876</i>&nbsp;            return;</b>
<i class="no-highlight">3877</i>&nbsp;        }
<i class="no-highlight">3878</i>&nbsp;
<b class="nc"><i class="no-highlight">3879</i>&nbsp;        if (key == null &amp;&amp;</b>
<b class="nc"><i class="no-highlight">3880</i>&nbsp;            databaseImpl.allowsKeyUpdates() &amp;&amp;</b>
<i class="no-highlight">3881</i>&nbsp;            !knownDeleted) {
<i class="no-highlight">3882</i>&nbsp;
<i class="no-highlight">3883</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">3884</i>&nbsp;                WholeEntry wholeEntry = getEnv().getLogManager().</b>
<b class="nc"><i class="no-highlight">3885</i>&nbsp;                    getLogEntryAllowInvisibleAtRecovery(</b>
<b class="nc"><i class="no-highlight">3886</i>&nbsp;                        lsn, getLastLoggedSize(idx));</b>
<i class="no-highlight">3887</i>&nbsp;
<b class="nc"><i class="no-highlight">3888</i>&nbsp;                LNLogEntry&lt;?&gt; logrec = (LNLogEntry&lt;?&gt;) wholeEntry.getEntry();</b>
<b class="nc"><i class="no-highlight">3889</i>&nbsp;                logrec.postFetchInit(getDatabase());</b>
<i class="no-highlight">3890</i>&nbsp;
<b class="nc"><i class="no-highlight">3891</i>&nbsp;                key = logrec.getKey();</b>
<b class="nc"><i class="no-highlight">3892</i>&nbsp;                logrecSize = wholeEntry.getHeader().getEntrySize();</b>
<i class="no-highlight">3893</i>&nbsp;
<b class="nc"><i class="no-highlight">3894</i>&nbsp;            } catch (FileNotFoundException e) {</b>
<b class="nc"><i class="no-highlight">3895</i>&nbsp;                throw new EnvironmentFailureException(</b>
<b class="nc"><i class="no-highlight">3896</i>&nbsp;                    getEnv(), EnvironmentFailureReason.LOG_FILE_NOT_FOUND,</b>
<b class="nc"><i class="no-highlight">3897</i>&nbsp;                    makeFetchErrorMsg(null, lsn, idx), e);</b>
<b class="nc"><i class="no-highlight">3898</i>&nbsp;            }</b>
<i class="no-highlight">3899</i>&nbsp;        }
<i class="no-highlight">3900</i>&nbsp;
<b class="nc"><i class="no-highlight">3901</i>&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</b>
<i class="no-highlight">3902</i>&nbsp;
<b class="nc"><i class="no-highlight">3903</i>&nbsp;        setLsn(idx, lsn);</b>
<b class="nc"><i class="no-highlight">3904</i>&nbsp;        setTarget(idx, null);</b>
<i class="no-highlight">3905</i>&nbsp;
<b class="nc"><i class="no-highlight">3906</i>&nbsp;        boolean multiSlotChange = updateLNSlotKey(idx, key, data);</b>
<i class="no-highlight">3907</i>&nbsp;
<b class="nc"><i class="no-highlight">3908</i>&nbsp;        if (isEmbeddedLN(idx)) {</b>
<b class="nc"><i class="no-highlight">3909</i>&nbsp;            clearLastLoggedSize(idx);</b>
<b class="nc"><i class="no-highlight">3910</i>&nbsp;            bin.setCachedVLSN(idx, vlsn);</b>
<i class="no-highlight">3911</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">3912</i>&nbsp;            setLastLoggedSize(idx, logrecSize);</b>
<i class="no-highlight">3913</i>&nbsp;        }
<i class="no-highlight">3914</i>&nbsp;
<b class="nc"><i class="no-highlight">3915</i>&nbsp;        if (knownDeleted) {</b>
<b class="nc"><i class="no-highlight">3916</i>&nbsp;            assert(!pendingDeleted);</b>
<b class="nc"><i class="no-highlight">3917</i>&nbsp;            setKnownDeleted(idx);</b>
<b class="nc"><i class="no-highlight">3918</i>&nbsp;            bin.queueSlotDeletion(idx);</b>
<i class="no-highlight">3919</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">3920</i>&nbsp;            clearKnownDeleted(idx);</b>
<b class="nc"><i class="no-highlight">3921</i>&nbsp;            if (pendingDeleted) {</b>
<b class="nc"><i class="no-highlight">3922</i>&nbsp;                setPendingDeleted(idx);</b>
<b class="nc"><i class="no-highlight">3923</i>&nbsp;                bin.queueSlotDeletion(idx);</b>
<i class="no-highlight">3924</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">3925</i>&nbsp;                clearPendingDeleted(idx);</b>
<i class="no-highlight">3926</i>&nbsp;            }
<i class="no-highlight">3927</i>&nbsp;        }
<i class="no-highlight">3928</i>&nbsp;
<b class="nc"><i class="no-highlight">3929</i>&nbsp;        bin.setExpiration(idx, expiration, expirationInHours);</b>
<i class="no-highlight">3930</i>&nbsp;
<b class="nc"><i class="no-highlight">3931</i>&nbsp;        if (multiSlotChange) {</b>
<b class="nc"><i class="no-highlight">3932</i>&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</b>
<i class="no-highlight">3933</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">3934</i>&nbsp;            long newSlotSize = getEntryInMemorySize(idx);</b>
<b class="nc"><i class="no-highlight">3935</i>&nbsp;            updateMemorySize(oldSlotSize, newSlotSize);</b>
<i class="no-highlight">3936</i>&nbsp;        }
<i class="no-highlight">3937</i>&nbsp;
<b class="nc"><i class="no-highlight">3938</i>&nbsp;        setDirty(true);</b>
<b class="nc"><i class="no-highlight">3939</i>&nbsp;    }</b>
<i class="no-highlight">3940</i>&nbsp;
<i class="no-highlight">3941</i>&nbsp;    /**
<i class="no-highlight">3942</i>&nbsp;     * Update the cached-child and LSN properties of the idx-th slot. This
<i class="no-highlight">3943</i>&nbsp;     * method is used by the RecoveryManager.recoverChildIN() to change the
<i class="no-highlight">3944</i>&nbsp;     * version of a child IN, a later version The child IN may or may not be
<i class="no-highlight">3945</i>&nbsp;     * already attached to the tree.
<i class="no-highlight">3946</i>&nbsp;     */
<i class="no-highlight">3947</i>&nbsp;    public final void recoverIN(
<i class="no-highlight">3948</i>&nbsp;        int idx,
<i class="no-highlight">3949</i>&nbsp;        Node node,
<i class="no-highlight">3950</i>&nbsp;        long lsn,
<i class="no-highlight">3951</i>&nbsp;        int lastLoggedSize) {
<i class="no-highlight">3952</i>&nbsp;
<b class="nc"><i class="no-highlight">3953</i>&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</b>
<i class="no-highlight">3954</i>&nbsp;
<i class="no-highlight">3955</i>&nbsp;        /*
<i class="no-highlight">3956</i>&nbsp;         * If we are about to detach a cached child IN, make sure that it is
<i class="no-highlight">3957</i>&nbsp;         * not in the INList. This is correct, because this method is called
<i class="no-highlight">3958</i>&nbsp;         * during the recovery phase where the INList is disabled,
<i class="no-highlight">3959</i>&nbsp;         */
<b class="nc"><i class="no-highlight">3960</i>&nbsp;        Node child = getTarget(idx);</b>
<b class="nc"><i class="no-highlight">3961</i>&nbsp;        assert(child == null ||</b>
<b class="nc"><i class="no-highlight">3962</i>&nbsp;               !((IN)child).getInListResident() ||</b>
<i class="no-highlight">3963</i>&nbsp;               child == node/* this is needed by a unit test*/);
<i class="no-highlight">3964</i>&nbsp;
<b class="nc"><i class="no-highlight">3965</i>&nbsp;        setLsn(idx, lsn);</b>
<b class="nc"><i class="no-highlight">3966</i>&nbsp;        setLastLoggedSize(idx, lastLoggedSize);</b>
<b class="nc"><i class="no-highlight">3967</i>&nbsp;        setTarget(idx, node);</b>
<i class="no-highlight">3968</i>&nbsp;
<b class="nc"><i class="no-highlight">3969</i>&nbsp;        long newSlotSize = getEntryInMemorySize(idx);</b>
<b class="nc"><i class="no-highlight">3970</i>&nbsp;        updateMemorySize(oldSlotSize, newSlotSize);</b>
<i class="no-highlight">3971</i>&nbsp;
<b class="nc"><i class="no-highlight">3972</i>&nbsp;        setDirty(true);</b>
<i class="no-highlight">3973</i>&nbsp;
<b class="nc"><i class="no-highlight">3974</i>&nbsp;        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());</b>
<b class="nc"><i class="no-highlight">3975</i>&nbsp;    }</b>
<i class="no-highlight">3976</i>&nbsp;
<i class="no-highlight">3977</i>&nbsp;    /**
<i class="no-highlight">3978</i>&nbsp;     * Attach the given node as the idx-th child of &quot;this&quot; node. If the child
<i class="no-highlight">3979</i>&nbsp;     * node is an LN, update the key of the parent slot to the given key value,
<i class="no-highlight">3980</i>&nbsp;     * if that value is non-null and an update is indeed necessary.
<i class="no-highlight">3981</i>&nbsp;     *
<i class="no-highlight">3982</i>&nbsp;     * This method is called after the child node has been either (a) fetched
<i class="no-highlight">3983</i>&nbsp;     * in from disk and is not dirty, or (b) is a newly created instance that
<i class="no-highlight">3984</i>&nbsp;     * will be written out later by something like a checkpoint. In either
<i class="no-highlight">3985</i>&nbsp;     * case, the slot LSN does not need to be updated.
<i class="no-highlight">3986</i>&nbsp;     *
<i class="no-highlight">3987</i>&nbsp;     * Note: does not dirty the node unless the LN slot key is changed.
<i class="no-highlight">3988</i>&nbsp;     */
<i class="no-highlight">3989</i>&nbsp;    public final void attachNode(int idx, Node node, byte[] newKey) {
<i class="no-highlight">3990</i>&nbsp;
<b class="fc"><i class="no-highlight">3991</i>&nbsp;        assert !(node instanceof IN) || ((IN) node).isLatchExclusiveOwner();</b>
<i class="no-highlight">3992</i>&nbsp;
<b class="fc"><i class="no-highlight">3993</i>&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</b>
<i class="no-highlight">3994</i>&nbsp;
<i class="no-highlight">3995</i>&nbsp;        /* Make sure we are not using this method to detach a cached child */
<b class="fc"><i class="no-highlight">3996</i>&nbsp;        assert(getTarget(idx) == null);</b>
<i class="no-highlight">3997</i>&nbsp;
<b class="fc"><i class="no-highlight">3998</i>&nbsp;        setTarget(idx, node);</b>
<i class="no-highlight">3999</i>&nbsp;
<b class="fc"><i class="no-highlight">4000</i>&nbsp;        boolean multiSlotChange = false;</b>
<i class="no-highlight">4001</i>&nbsp;
<b class="fc"><i class="no-highlight">4002</i>&nbsp;        if (isBIN() &amp;&amp; newKey != null) {</b>
<b class="nc"><i class="no-highlight">4003</i>&nbsp;            assert(!haveEmbeddedData(idx));</b>
<b class="nc"><i class="no-highlight">4004</i>&nbsp;            multiSlotChange = updateLNSlotKey(idx, newKey, null);</b>
<i class="no-highlight">4005</i>&nbsp;        }
<i class="no-highlight">4006</i>&nbsp;
<b class="fc"><i class="no-highlight">4007</i>&nbsp;        if (multiSlotChange) {</b>
<b class="nc"><i class="no-highlight">4008</i>&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</b>
<i class="no-highlight">4009</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">4010</i>&nbsp;            long newSlotSize = getEntryInMemorySize(idx);</b>
<b class="fc"><i class="no-highlight">4011</i>&nbsp;            updateMemorySize(oldSlotSize, newSlotSize);</b>
<i class="no-highlight">4012</i>&nbsp;        }
<i class="no-highlight">4013</i>&nbsp;
<b class="fc"><i class="no-highlight">4014</i>&nbsp;        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());</b>
<b class="fc"><i class="no-highlight">4015</i>&nbsp;    }</b>
<i class="no-highlight">4016</i>&nbsp;
<i class="no-highlight">4017</i>&nbsp;    /*
<i class="no-highlight">4018</i>&nbsp;     * Detach from the tree the child node at the idx-th slot.
<i class="no-highlight">4019</i>&nbsp;     *
<i class="no-highlight">4020</i>&nbsp;     * The most common caller of this method is the evictor. If the child
<i class="no-highlight">4021</i>&nbsp;     * being evicted was dirty, it has just been logged and the lsn of the
<i class="no-highlight">4022</i>&nbsp;     * slot must be updated.
<i class="no-highlight">4023</i>&nbsp;     */
<i class="no-highlight">4024</i>&nbsp;    public final void detachNode(int idx, boolean updateLsn, long newLsn) {
<i class="no-highlight">4025</i>&nbsp;
<b class="fc"><i class="no-highlight">4026</i>&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</b>
<i class="no-highlight">4027</i>&nbsp;
<b class="fc"><i class="no-highlight">4028</i>&nbsp;        Node child = getTarget(idx);</b>
<i class="no-highlight">4029</i>&nbsp;
<b class="fc"><i class="no-highlight">4030</i>&nbsp;        if (updateLsn) {</b>
<b class="fc"><i class="no-highlight">4031</i>&nbsp;            setLsn(idx, newLsn);</b>
<b class="fc"><i class="no-highlight">4032</i>&nbsp;            setDirty(true);</b>
<i class="no-highlight">4033</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4034</i>&nbsp;        setTarget(idx, null);</b>
<i class="no-highlight">4035</i>&nbsp;
<b class="fc"><i class="no-highlight">4036</i>&nbsp;        long newSlotSize = getEntryInMemorySize(idx);</b>
<b class="fc"><i class="no-highlight">4037</i>&nbsp;        updateMemorySize(oldSlotSize, newSlotSize);</b>
<i class="no-highlight">4038</i>&nbsp;
<b class="fc"><i class="no-highlight">4039</i>&nbsp;        if (child != null &amp;&amp; child.isIN()) {</b>
<b class="fc"><i class="no-highlight">4040</i>&nbsp;            getEnv().getInMemoryINs().remove((IN) child);</b>
<i class="no-highlight">4041</i>&nbsp;        }
<i class="no-highlight">4042</i>&nbsp;
<b class="fc"><i class="no-highlight">4043</i>&nbsp;        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());</b>
<b class="fc"><i class="no-highlight">4044</i>&nbsp;    }</b>
<i class="no-highlight">4045</i>&nbsp;
<i class="no-highlight">4046</i>&nbsp;    /**
<i class="no-highlight">4047</i>&nbsp;     * This method is used in DupConvert, where it is called to convert the
<i class="no-highlight">4048</i>&nbsp;     * keys of an upper IN that has just been fetched from the log and is not
<i class="no-highlight">4049</i>&nbsp;     * attached to in-memory tree yet.
<i class="no-highlight">4050</i>&nbsp;     */
<i class="no-highlight">4051</i>&nbsp;    public final void convertKey(int idx, byte[] newKey) {
<i class="no-highlight">4052</i>&nbsp;
<b class="nc"><i class="no-highlight">4053</i>&nbsp;        long oldSlotSize = getEntryInMemorySize(idx);</b>
<i class="no-highlight">4054</i>&nbsp;
<b class="nc"><i class="no-highlight">4055</i>&nbsp;        boolean multiSlotChange = updateKey(idx, newKey, null);</b>
<i class="no-highlight">4056</i>&nbsp;
<b class="nc"><i class="no-highlight">4057</i>&nbsp;        if (multiSlotChange) {</b>
<b class="nc"><i class="no-highlight">4058</i>&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</b>
<i class="no-highlight">4059</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">4060</i>&nbsp;            long newSlotSize = getEntryInMemorySize(idx);</b>
<b class="nc"><i class="no-highlight">4061</i>&nbsp;            updateMemorySize(oldSlotSize, newSlotSize);</b>
<i class="no-highlight">4062</i>&nbsp;        }
<i class="no-highlight">4063</i>&nbsp;
<b class="nc"><i class="no-highlight">4064</i>&nbsp;        setDirty(true);</b>
<i class="no-highlight">4065</i>&nbsp;
<b class="nc"><i class="no-highlight">4066</i>&nbsp;        assert(isBIN() || hasCachedChildren() == hasCachedChildrenFlag());</b>
<b class="nc"><i class="no-highlight">4067</i>&nbsp;    }</b>
<i class="no-highlight">4068</i>&nbsp;
<i class="no-highlight">4069</i>&nbsp;    void copyEntries(final int from, final int to, final int n) {
<i class="no-highlight">4070</i>&nbsp;
<b class="fc"><i class="no-highlight">4071</i>&nbsp;        entryTargets = entryTargets.copy(from, to, n, this);</b>
<b class="fc"><i class="no-highlight">4072</i>&nbsp;        entryKeys = entryKeys.copy(from, to, n, this);</b>
<b class="fc"><i class="no-highlight">4073</i>&nbsp;        offHeapBINIds = offHeapBINIds.copy(from, to, n, this);</b>
<i class="no-highlight">4074</i>&nbsp;
<b class="fc"><i class="no-highlight">4075</i>&nbsp;        System.arraycopy(entryStates, from, entryStates, to, n);</b>
<i class="no-highlight">4076</i>&nbsp;
<b class="fc"><i class="no-highlight">4077</i>&nbsp;        if (entryLsnLongArray == null) {</b>
<b class="fc"><i class="no-highlight">4078</i>&nbsp;            final int fromOff = from &lt;&lt; 2;</b>
<b class="fc"><i class="no-highlight">4079</i>&nbsp;            final int toOff = to &lt;&lt; 2;</b>
<b class="fc"><i class="no-highlight">4080</i>&nbsp;            final int nBytes = n &lt;&lt; 2;</b>
<b class="fc"><i class="no-highlight">4081</i>&nbsp;            System.arraycopy(entryLsnByteArray, fromOff,</b>
<i class="no-highlight">4082</i>&nbsp;                entryLsnByteArray, toOff, nBytes);
<b class="fc"><i class="no-highlight">4083</i>&nbsp;        } else {</b>
<b class="fc"><i class="no-highlight">4084</i>&nbsp;            System.arraycopy(entryLsnLongArray, from,</b>
<i class="no-highlight">4085</i>&nbsp;                entryLsnLongArray, to,
<i class="no-highlight">4086</i>&nbsp;                n);
<i class="no-highlight">4087</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4088</i>&nbsp;    }</b>
<i class="no-highlight">4089</i>&nbsp;
<i class="no-highlight">4090</i>&nbsp;    /**
<i class="no-highlight">4091</i>&nbsp;     * Return true if this node needs splitting.  For the moment, needing to be
<i class="no-highlight">4092</i>&nbsp;     * split is defined by there being no free entries available.
<i class="no-highlight">4093</i>&nbsp;     */
<i class="no-highlight">4094</i>&nbsp;    public final boolean needsSplitting() {
<i class="no-highlight">4095</i>&nbsp;
<b class="fc"><i class="no-highlight">4096</i>&nbsp;        if (isBINDelta()) {</b>
<b class="fc"><i class="no-highlight">4097</i>&nbsp;            BIN bin = (BIN)this;</b>
<b class="fc"><i class="no-highlight">4098</i>&nbsp;            int fullBinNEntries = bin.getFullBinNEntries();</b>
<b class="fc"><i class="no-highlight">4099</i>&nbsp;            int fullBinMaxEntries = bin.getFullBinMaxEntries();</b>
<i class="no-highlight">4100</i>&nbsp;
<b class="fc"><i class="no-highlight">4101</i>&nbsp;            if (fullBinNEntries &lt; 0) {</b>
<i class="no-highlight">4102</i>&nbsp;                /* fullBinNEntries is unknown in logVersions &lt; 10 */
<b class="nc"><i class="no-highlight">4103</i>&nbsp;                mutateToFullBIN(false /*leaveFreeSlot*/);</b>
<i class="no-highlight">4104</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">4105</i>&nbsp;                assert(fullBinNEntries &gt; 0);</b>
<b class="fc"><i class="no-highlight">4106</i>&nbsp;                return ((fullBinMaxEntries - fullBinNEntries) &lt; 1);</b>
<i class="no-highlight">4107</i>&nbsp;            }
<i class="no-highlight">4108</i>&nbsp;        }
<i class="no-highlight">4109</i>&nbsp;
<b class="fc"><i class="no-highlight">4110</i>&nbsp;        return ((getMaxEntries() - nEntries) &lt; 1);</b>
<i class="no-highlight">4111</i>&nbsp;    }
<i class="no-highlight">4112</i>&nbsp;
<i class="no-highlight">4113</i>&nbsp;    /**
<i class="no-highlight">4114</i>&nbsp;     * Split this into two nodes.  Parent IN is passed in parent and should be
<i class="no-highlight">4115</i>&nbsp;     * latched by the caller.
<i class="no-highlight">4116</i>&nbsp;     *
<i class="no-highlight">4117</i>&nbsp;     * childIndex is the index in parent of where &quot;this&quot; can be found.
<i class="no-highlight">4118</i>&nbsp;     */
<i class="no-highlight">4119</i>&nbsp;    public final IN split(
<i class="no-highlight">4120</i>&nbsp;        IN parent,
<i class="no-highlight">4121</i>&nbsp;        int childIndex,
<i class="no-highlight">4122</i>&nbsp;        IN grandParent,
<i class="no-highlight">4123</i>&nbsp;        int maxEntries) {
<i class="no-highlight">4124</i>&nbsp;
<b class="fc"><i class="no-highlight">4125</i>&nbsp;        return splitInternal(parent, childIndex, grandParent, maxEntries, -1);</b>
<i class="no-highlight">4126</i>&nbsp;    }
<i class="no-highlight">4127</i>&nbsp;
<i class="no-highlight">4128</i>&nbsp;    /**
<i class="no-highlight">4129</i>&nbsp;     * Called when we know we are about to split on behalf of a key that is the
<i class="no-highlight">4130</i>&nbsp;     * minimum (leftSide) or maximum (!leftSide) of this node.  This is
<i class="no-highlight">4131</i>&nbsp;     * achieved by just forcing the split to occur either one element in from
<i class="no-highlight">4132</i>&nbsp;     * the left or the right (i.e. splitIndex is 1 or nEntries - 1).
<i class="no-highlight">4133</i>&nbsp;     */
<i class="no-highlight">4134</i>&nbsp;    IN splitSpecial(
<i class="no-highlight">4135</i>&nbsp;        IN parent,
<i class="no-highlight">4136</i>&nbsp;        int parentIndex,
<i class="no-highlight">4137</i>&nbsp;        IN grandParent,
<i class="no-highlight">4138</i>&nbsp;        int maxEntriesPerNode,
<i class="no-highlight">4139</i>&nbsp;        byte[] key,
<i class="no-highlight">4140</i>&nbsp;        boolean leftSide) {
<i class="no-highlight">4141</i>&nbsp;
<b class="fc"><i class="no-highlight">4142</i>&nbsp;        int index = findEntry(key, false, false);</b>
<i class="no-highlight">4143</i>&nbsp;
<b class="fc"><i class="no-highlight">4144</i>&nbsp;        if (leftSide &amp;&amp; index == 0) {</b>
<b class="nc"><i class="no-highlight">4145</i>&nbsp;            return splitInternal(</b>
<i class="no-highlight">4146</i>&nbsp;                parent, parentIndex, grandParent, maxEntriesPerNode, 1);
<i class="no-highlight">4147</i>&nbsp;
<b class="fc"><i class="no-highlight">4148</i>&nbsp;        } else if (!leftSide &amp;&amp; index == (nEntries - 1)) {</b>
<b class="fc"><i class="no-highlight">4149</i>&nbsp;            return splitInternal(</b>
<i class="no-highlight">4150</i>&nbsp;                parent, parentIndex, grandParent, maxEntriesPerNode,
<i class="no-highlight">4151</i>&nbsp;                nEntries - 1);
<i class="no-highlight">4152</i>&nbsp;
<i class="no-highlight">4153</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">4154</i>&nbsp;            return split(</b>
<i class="no-highlight">4155</i>&nbsp;                parent, parentIndex, grandParent, maxEntriesPerNode);
<i class="no-highlight">4156</i>&nbsp;        }
<i class="no-highlight">4157</i>&nbsp;    }
<i class="no-highlight">4158</i>&nbsp;
<i class="no-highlight">4159</i>&nbsp;    final IN splitInternal(
<i class="no-highlight">4160</i>&nbsp;        final IN parent,
<i class="no-highlight">4161</i>&nbsp;        final int childIndex,
<i class="no-highlight">4162</i>&nbsp;        final IN grandParent,
<i class="no-highlight">4163</i>&nbsp;        final int maxEntries,
<i class="no-highlight">4164</i>&nbsp;        int splitIndex)
<i class="no-highlight">4165</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">4166</i>&nbsp;
<b class="fc"><i class="no-highlight">4167</i>&nbsp;        assert(!isBINDelta());</b>
<i class="no-highlight">4168</i>&nbsp;
<i class="no-highlight">4169</i>&nbsp;        /*
<i class="no-highlight">4170</i>&nbsp;         * Find the index of the existing identifierKey so we know which IN
<i class="no-highlight">4171</i>&nbsp;         * (new or old) to put it in.
<i class="no-highlight">4172</i>&nbsp;         */
<b class="fc"><i class="no-highlight">4173</i>&nbsp;        if (identifierKey == null) {</b>
<b class="nc"><i class="no-highlight">4174</i>&nbsp;            throw unexpectedState();</b>
<i class="no-highlight">4175</i>&nbsp;        }
<i class="no-highlight">4176</i>&nbsp;
<b class="fc"><i class="no-highlight">4177</i>&nbsp;        final int idKeyIndex = findEntry(identifierKey, false, false);</b>
<i class="no-highlight">4178</i>&nbsp;
<b class="fc"><i class="no-highlight">4179</i>&nbsp;        if (splitIndex &lt; 0) {</b>
<b class="fc"><i class="no-highlight">4180</i>&nbsp;            splitIndex = nEntries / 2;</b>
<i class="no-highlight">4181</i>&nbsp;        }
<i class="no-highlight">4182</i>&nbsp;
<i class="no-highlight">4183</i>&nbsp;        /* Range of entries to copy to new sibling. */
<i class="no-highlight">4184</i>&nbsp;        final int low, high;
<i class="no-highlight">4185</i>&nbsp;
<b class="fc"><i class="no-highlight">4186</i>&nbsp;        if (idKeyIndex &lt; splitIndex) {</b>
<i class="no-highlight">4187</i>&nbsp;
<i class="no-highlight">4188</i>&nbsp;            /*
<i class="no-highlight">4189</i>&nbsp;             * Current node (this) keeps left half entries.  Right half entries
<i class="no-highlight">4190</i>&nbsp;             * will go in the new node.
<i class="no-highlight">4191</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4192</i>&nbsp;            low = splitIndex;</b>
<b class="fc"><i class="no-highlight">4193</i>&nbsp;            high = nEntries;</b>
<i class="no-highlight">4194</i>&nbsp;        } else {
<i class="no-highlight">4195</i>&nbsp;
<i class="no-highlight">4196</i>&nbsp;            /*
<i class="no-highlight">4197</i>&nbsp;             * Current node (this) keeps right half entries.  Left half entries
<i class="no-highlight">4198</i>&nbsp;             * will go in the new node.
<i class="no-highlight">4199</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4200</i>&nbsp;            low = 0;</b>
<b class="fc"><i class="no-highlight">4201</i>&nbsp;            high = splitIndex;</b>
<i class="no-highlight">4202</i>&nbsp;        }
<i class="no-highlight">4203</i>&nbsp;
<b class="fc"><i class="no-highlight">4204</i>&nbsp;        final byte[] newIdKey = getKey(low);</b>
<i class="no-highlight">4205</i>&nbsp;        long parentLsn;
<i class="no-highlight">4206</i>&nbsp;
<i class="no-highlight">4207</i>&nbsp;        /*
<i class="no-highlight">4208</i>&nbsp;         * Ensure that max entries is large enough to hold the slots being
<i class="no-highlight">4209</i>&nbsp;         * moved to the new sibling, with one spare slot for insertions. This
<i class="no-highlight">4210</i>&nbsp;         * is important when the maxEntries param is less than nEntries in this
<i class="no-highlight">4211</i>&nbsp;         * node, which can occur when the user reduces the fanout or when this
<i class="no-highlight">4212</i>&nbsp;         * node has temporarily grown beyond its original fanout.
<i class="no-highlight">4213</i>&nbsp;         */
<b class="fc"><i class="no-highlight">4214</i>&nbsp;        final IN newSibling = createNewInstance(</b>
<i class="no-highlight">4215</i>&nbsp;            newIdKey,
<b class="fc"><i class="no-highlight">4216</i>&nbsp;            Math.max(maxEntries, high - low + 1),</b>
<i class="no-highlight">4217</i>&nbsp;            level);
<i class="no-highlight">4218</i>&nbsp;
<b class="fc"><i class="no-highlight">4219</i>&nbsp;        newSibling.latch(CacheMode.UNCHANGED);</b>
<i class="no-highlight">4220</i>&nbsp;
<i class="no-highlight">4221</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">4222</i>&nbsp;            boolean addedNewSiblingToCompressorQueue = false;</b>
<b class="fc"><i class="no-highlight">4223</i>&nbsp;            final int newSiblingNEntries = (high - low);</b>
<b class="fc"><i class="no-highlight">4224</i>&nbsp;            final boolean haveCachedChildren = hasCachedChildrenFlag();</b>
<i class="no-highlight">4225</i>&nbsp;
<b class="fc"><i class="no-highlight">4226</i>&nbsp;            assert(isBIN() || haveCachedChildren == hasCachedChildren());</b>
<i class="no-highlight">4227</i>&nbsp;
<b class="fc"><i class="no-highlight">4228</i>&nbsp;            final BIN bin = isBIN() ? (BIN) this : null;</b>
<i class="no-highlight">4229</i>&nbsp;
<i class="no-highlight">4230</i>&nbsp;            /**
<i class="no-highlight">4231</i>&nbsp;             * Distribute entries among the split node and the new sibling.
<i class="no-highlight">4232</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4233</i>&nbsp;            for (int i = low; i &lt; high; i++) {</b>
<i class="no-highlight">4234</i>&nbsp;
<b class="fc"><i class="no-highlight">4235</i>&nbsp;                if (!addedNewSiblingToCompressorQueue &amp;&amp;</b>
<i class="no-highlight">4236</i>&nbsp;                    bin != null &amp;&amp;
<b class="fc"><i class="no-highlight">4237</i>&nbsp;                    bin.isDefunct(i)) {</b>
<i class="no-highlight">4238</i>&nbsp;
<b class="nc"><i class="no-highlight">4239</i>&nbsp;                    addedNewSiblingToCompressorQueue = true;</b>
<b class="nc"><i class="no-highlight">4240</i>&nbsp;                    getEnv().addToCompressorQueue((BIN) newSibling);</b>
<i class="no-highlight">4241</i>&nbsp;                }
<i class="no-highlight">4242</i>&nbsp;
<b class="fc"><i class="no-highlight">4243</i>&nbsp;                newSibling.appendEntryFromOtherNode(this, i);</b>
<b class="fc"><i class="no-highlight">4244</i>&nbsp;                clearEntry(i);</b>
<i class="no-highlight">4245</i>&nbsp;            }
<i class="no-highlight">4246</i>&nbsp;
<b class="fc"><i class="no-highlight">4247</i>&nbsp;            if (low == 0) {</b>
<b class="fc"><i class="no-highlight">4248</i>&nbsp;                shiftEntriesLeft(newSiblingNEntries);</b>
<i class="no-highlight">4249</i>&nbsp;            }
<i class="no-highlight">4250</i>&nbsp;
<b class="fc"><i class="no-highlight">4251</i>&nbsp;            nEntries -= newSiblingNEntries;</b>
<b class="fc"><i class="no-highlight">4252</i>&nbsp;            setDirty(true);</b>
<i class="no-highlight">4253</i>&nbsp;
<b class="fc"><i class="no-highlight">4254</i>&nbsp;            if (isUpperIN() &amp;&amp; haveCachedChildren) {</b>
<b class="fc"><i class="no-highlight">4255</i>&nbsp;                setHasCachedChildrenFlag(hasCachedChildren());</b>
<i class="no-highlight">4256</i>&nbsp;            }
<i class="no-highlight">4257</i>&nbsp;
<b class="fc"><i class="no-highlight">4258</i>&nbsp;            assert(isBIN() ||</b>
<b class="nc"><i class="no-highlight">4259</i>&nbsp;                   hasCachedChildrenFlag() == hasCachedChildren());</b>
<b class="fc"><i class="no-highlight">4260</i>&nbsp;            assert(isBIN() ||</b>
<b class="nc"><i class="no-highlight">4261</i>&nbsp;                   newSibling.hasCachedChildrenFlag() ==</b>
<b class="nc"><i class="no-highlight">4262</i>&nbsp;                   newSibling.hasCachedChildren());</b>
<i class="no-highlight">4263</i>&nbsp;
<b class="fc"><i class="no-highlight">4264</i>&nbsp;            adjustCursors(newSibling, low, high);</b>
<i class="no-highlight">4265</i>&nbsp;
<i class="no-highlight">4266</i>&nbsp;            /*
<i class="no-highlight">4267</i>&nbsp;             * If this node has no key prefix, calculate it now that it has
<i class="no-highlight">4268</i>&nbsp;             * been split.  This must be done before logging, to ensure the
<i class="no-highlight">4269</i>&nbsp;             * prefix information is made persistent [#20799].
<i class="no-highlight">4270</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4271</i>&nbsp;            byte[] newKeyPrefix = computeKeyPrefix(-1);</b>
<b class="fc"><i class="no-highlight">4272</i>&nbsp;            recalcSuffixes(newKeyPrefix, null, null, -1);</b>
<i class="no-highlight">4273</i>&nbsp;
<i class="no-highlight">4274</i>&nbsp;            /* Apply compaction after prefixing [#20799]. */
<b class="fc"><i class="no-highlight">4275</i>&nbsp;            entryKeys = entryKeys.compact(this);</b>
<i class="no-highlight">4276</i>&nbsp;
<i class="no-highlight">4277</i>&nbsp;            /* Only recalc if there are multiple entries in newSibling. */
<b class="fc"><i class="no-highlight">4278</i>&nbsp;            if (newSibling.getNEntries() &gt; 1) {</b>
<b class="fc"><i class="no-highlight">4279</i>&nbsp;                byte[] newSiblingPrefix = newSibling.computeKeyPrefix(-1);</b>
<b class="fc"><i class="no-highlight">4280</i>&nbsp;                newSibling.recalcSuffixes(newSiblingPrefix, null, null, -1);</b>
<i class="no-highlight">4281</i>&nbsp;                /* initMemorySize calls entryKeys.compact. */
<b class="fc"><i class="no-highlight">4282</i>&nbsp;                newSibling.initMemorySize();</b>
<i class="no-highlight">4283</i>&nbsp;            }
<i class="no-highlight">4284</i>&nbsp;
<b class="fc"><i class="no-highlight">4285</i>&nbsp;            assert idKeyIsSlotKey();</b>
<b class="fc"><i class="no-highlight">4286</i>&nbsp;            assert newSibling.idKeyIsSlotKey();</b>
<i class="no-highlight">4287</i>&nbsp;
<i class="no-highlight">4288</i>&nbsp;            /*
<i class="no-highlight">4289</i>&nbsp;             * Update size. newSibling and parent are correct, but this IN has
<i class="no-highlight">4290</i>&nbsp;             * had its entries shifted and is not correct.
<i class="no-highlight">4291</i>&nbsp;             *
<i class="no-highlight">4292</i>&nbsp;             * Also, inMemorySize does not reflect changes that may have
<i class="no-highlight">4293</i>&nbsp;             * resulted from key prefixing related changes, it needs to be
<i class="no-highlight">4294</i>&nbsp;             * brought up to date, so update it appropriately for this and the
<i class="no-highlight">4295</i>&nbsp;             * above reason.
<i class="no-highlight">4296</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4297</i>&nbsp;            EnvironmentImpl env = getEnv();</b>
<b class="fc"><i class="no-highlight">4298</i>&nbsp;            INList inMemoryINs = env.getInMemoryINs();</b>
<b class="fc"><i class="no-highlight">4299</i>&nbsp;            long oldMemorySize = inMemorySize;</b>
<b class="fc"><i class="no-highlight">4300</i>&nbsp;            long newSize = computeMemorySize();</b>
<b class="fc"><i class="no-highlight">4301</i>&nbsp;            updateMemorySize(oldMemorySize, newSize);</b>
<i class="no-highlight">4302</i>&nbsp;
<i class="no-highlight">4303</i>&nbsp;            /*
<i class="no-highlight">4304</i>&nbsp;             * Parent refers to child through an element of the entries array.
<i class="no-highlight">4305</i>&nbsp;             * Depending on which half of the BIN we copied keys from, we
<i class="no-highlight">4306</i>&nbsp;             * either have to adjust one pointer and add a new one, or we have
<i class="no-highlight">4307</i>&nbsp;             * to just add a new pointer to the new sibling.
<i class="no-highlight">4308</i>&nbsp;             *
<i class="no-highlight">4309</i>&nbsp;             * We must use the provisional logging for two reasons:
<i class="no-highlight">4310</i>&nbsp;             *
<i class="no-highlight">4311</i>&nbsp;             *   1) All three log entries must be read atomically. The parent
<i class="no-highlight">4312</i>&nbsp;             *   must get logged last, as all referred-to children must precede
<i class="no-highlight">4313</i>&nbsp;             *   it. Provisional entries guarantee that all three are processed
<i class="no-highlight">4314</i>&nbsp;             *   as a unit. Recovery skips provisional entries, so the changed
<i class="no-highlight">4315</i>&nbsp;             *   children are only used if the parent makes it out to the log.
<i class="no-highlight">4316</i>&nbsp;             *
<i class="no-highlight">4317</i>&nbsp;             *   2) We log all they way to the root to avoid the &quot;great aunt&quot;
<i class="no-highlight">4318</i>&nbsp;             *   problem (see LevelRecorder), and provisional logging is
<i class="no-highlight">4319</i>&nbsp;             *   necessary during a checkpoint for levels less than
<i class="no-highlight">4320</i>&nbsp;             *   maxFlushLevel.
<i class="no-highlight">4321</i>&nbsp;             *
<i class="no-highlight">4322</i>&nbsp;             * We prohibit compression during logging because there should be
<i class="no-highlight">4323</i>&nbsp;             * at least one entry in each IN. Note the use of getKey(0) below.
<i class="no-highlight">4324</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4325</i>&nbsp;            long newSiblingLsn =</b>
<b class="fc"><i class="no-highlight">4326</i>&nbsp;                newSibling.optionalLogProvisionalNoCompress(parent);</b>
<i class="no-highlight">4327</i>&nbsp;
<b class="fc"><i class="no-highlight">4328</i>&nbsp;            long myNewLsn = optionalLogProvisionalNoCompress(parent);</b>
<i class="no-highlight">4329</i>&nbsp;
<b class="fc"><i class="no-highlight">4330</i>&nbsp;            assert nEntries &gt; 0;</b>
<i class="no-highlight">4331</i>&nbsp;
<i class="no-highlight">4332</i>&nbsp;            /*
<i class="no-highlight">4333</i>&nbsp;             * When we update the parent entry, we make sure that we don&#39;t
<i class="no-highlight">4334</i>&nbsp;             * replace the parent&#39;s key that points at &#39;this&#39; with a key that
<i class="no-highlight">4335</i>&nbsp;             * is &gt; than the existing one.  Replacing the parent&#39;s key with
<i class="no-highlight">4336</i>&nbsp;             * something &gt; would effectively render a piece of the subtree
<i class="no-highlight">4337</i>&nbsp;             * inaccessible.  So only replace the parent key with something
<i class="no-highlight">4338</i>&nbsp;             * &lt;= the existing one.  See tree/SplitTest.java for more details
<i class="no-highlight">4339</i>&nbsp;             * on the scenario.
<i class="no-highlight">4340</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4341</i>&nbsp;            if (low == 0) {</b>
<i class="no-highlight">4342</i>&nbsp;
<i class="no-highlight">4343</i>&nbsp;                /*
<i class="no-highlight">4344</i>&nbsp;                 * Change the original entry to point to the new child and add
<i class="no-highlight">4345</i>&nbsp;                 * an entry to point to the newly logged version of this
<i class="no-highlight">4346</i>&nbsp;                 * existing child.
<i class="no-highlight">4347</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">4348</i>&nbsp;                parent.prepareForSlotReuse(childIndex);</b>
<i class="no-highlight">4349</i>&nbsp;
<b class="fc"><i class="no-highlight">4350</i>&nbsp;                parent.updateSplitSlot(</b>
<i class="no-highlight">4351</i>&nbsp;                    childIndex, newSibling, newSiblingLsn, newIdKey);
<i class="no-highlight">4352</i>&nbsp;
<b class="fc"><i class="no-highlight">4353</i>&nbsp;                boolean inserted = parent.insertEntry(</b>
<b class="fc"><i class="no-highlight">4354</i>&nbsp;                    this, getKey(0), myNewLsn);</b>
<b class="fc"><i class="no-highlight">4355</i>&nbsp;                assert inserted;</b>
<b class="fc"><i class="no-highlight">4356</i>&nbsp;            } else {</b>
<i class="no-highlight">4357</i>&nbsp;
<i class="no-highlight">4358</i>&nbsp;                /*
<i class="no-highlight">4359</i>&nbsp;                 * Update the existing child&#39;s LSN to reflect the newly logged
<i class="no-highlight">4360</i>&nbsp;                 * version and insert new child into parent.
<i class="no-highlight">4361</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">4362</i>&nbsp;                parent.updateSplitSlot(childIndex, this, myNewLsn, getKey(0));</b>
<i class="no-highlight">4363</i>&nbsp;
<b class="fc"><i class="no-highlight">4364</i>&nbsp;                boolean inserted = parent.insertEntry(</b>
<i class="no-highlight">4365</i>&nbsp;                    newSibling, newIdKey, newSiblingLsn);
<b class="fc"><i class="no-highlight">4366</i>&nbsp;                assert inserted;</b>
<i class="no-highlight">4367</i>&nbsp;            }
<i class="no-highlight">4368</i>&nbsp;
<b class="fc"><i class="no-highlight">4369</i>&nbsp;            inMemoryINs.add(newSibling);</b>
<i class="no-highlight">4370</i>&nbsp;
<i class="no-highlight">4371</i>&nbsp;            /**
<i class="no-highlight">4372</i>&nbsp;             * Log the parent. Note that the root slot or grandparent slot is
<i class="no-highlight">4373</i>&nbsp;             * not updated with the parent&#39;s LSN here; this is done by
<i class="no-highlight">4374</i>&nbsp;             * Tree.forceSplit.
<i class="no-highlight">4375</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4376</i>&nbsp;            if (parent.isRoot()) {</b>
<b class="fc"><i class="no-highlight">4377</i>&nbsp;                parentLsn = parent.optionalLog();</b>
<i class="no-highlight">4378</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">4379</i>&nbsp;                parentLsn = parent.optionalLogProvisional(grandParent);</b>
<i class="no-highlight">4380</i>&nbsp;            }
<i class="no-highlight">4381</i>&nbsp;
<i class="no-highlight">4382</i>&nbsp;            /* Coordinate the split with an in-progress checkpoint. */
<b class="fc"><i class="no-highlight">4383</i>&nbsp;            env.getCheckpointer().coordinateSplitWithCheckpoint(newSibling);</b>
<i class="no-highlight">4384</i>&nbsp;
<i class="no-highlight">4385</i>&nbsp;            /*
<i class="no-highlight">4386</i>&nbsp;             * Check whether either the old or the new sibling must be added
<i class="no-highlight">4387</i>&nbsp;             * to the LRU (priority-1 LRUSet).
<i class="no-highlight">4388</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4389</i>&nbsp;            assert(!isDIN() &amp;&amp; !isDBIN());</b>
<i class="no-highlight">4390</i>&nbsp;
<b class="fc"><i class="no-highlight">4391</i>&nbsp;            if(isBIN() || !newSibling.hasCachedChildrenFlag()) {</b>
<b class="fc"><i class="no-highlight">4392</i>&nbsp;                if (isUpperIN() &amp;&amp; traceLRU) {</b>
<i class="no-highlight">4393</i>&nbsp;                    LoggerUtils.envLogMsg(
<i class="no-highlight">4394</i>&nbsp;                        traceLevel, getEnv(),
<i class="no-highlight">4395</i>&nbsp;                        &quot;split-newSibling &quot; +
<i class="no-highlight">4396</i>&nbsp;                            Thread.currentThread().getId() + &quot;-&quot; +
<i class="no-highlight">4397</i>&nbsp;                            Thread.currentThread().getName() +
<i class="no-highlight">4398</i>&nbsp;                            &quot;-&quot; + getEnv().getName() +
<i class="no-highlight">4399</i>&nbsp;                            &quot; Adding UIN to LRU: &quot; +
<i class="no-highlight">4400</i>&nbsp;                            newSibling.getNodeId());
<i class="no-highlight">4401</i>&nbsp;                }
<b class="fc"><i class="no-highlight">4402</i>&nbsp;                getEvictor().addBack(newSibling);</b>
<i class="no-highlight">4403</i>&nbsp;            }
<i class="no-highlight">4404</i>&nbsp;
<b class="fc"><i class="no-highlight">4405</i>&nbsp;            if (isUpperIN() &amp;&amp;</b>
<i class="no-highlight">4406</i>&nbsp;                haveCachedChildren &amp;&amp;
<b class="fc"><i class="no-highlight">4407</i>&nbsp;                !hasCachedChildrenFlag()) {</b>
<i class="no-highlight">4408</i>&nbsp;                if (traceLRU) {
<i class="no-highlight">4409</i>&nbsp;                    LoggerUtils.envLogMsg(
<i class="no-highlight">4410</i>&nbsp;                        traceLevel, getEnv(),
<i class="no-highlight">4411</i>&nbsp;                        &quot;split-oldSibling &quot; +
<i class="no-highlight">4412</i>&nbsp;                        Thread.currentThread().getId() + &quot;-&quot; +
<i class="no-highlight">4413</i>&nbsp;                        Thread.currentThread().getName() +
<i class="no-highlight">4414</i>&nbsp;                        &quot;-&quot; + getEnv().getName() +
<i class="no-highlight">4415</i>&nbsp;                        &quot; Adding UIN to LRU: &quot; + getNodeId());
<i class="no-highlight">4416</i>&nbsp;                }
<b class="nc"><i class="no-highlight">4417</i>&nbsp;                getEvictor().addBack(this);</b>
<i class="no-highlight">4418</i>&nbsp;            }
<i class="no-highlight">4419</i>&nbsp;
<i class="no-highlight">4420</i>&nbsp;            /* Debug log this information. */
<b class="fc"><i class="no-highlight">4421</i>&nbsp;            traceSplit(Level.FINE, parent,</b>
<i class="no-highlight">4422</i>&nbsp;                       newSibling, parentLsn, myNewLsn,
<i class="no-highlight">4423</i>&nbsp;                       newSiblingLsn, splitIndex, idKeyIndex, childIndex);
<i class="no-highlight">4424</i>&nbsp;        } finally {
<b class="fc"><i class="no-highlight">4425</i>&nbsp;            newSibling.releaseLatch();</b>
<b class="fc"><i class="no-highlight">4426</i>&nbsp;        }</b>
<i class="no-highlight">4427</i>&nbsp;
<b class="fc"><i class="no-highlight">4428</i>&nbsp;        return newSibling;</b>
<i class="no-highlight">4429</i>&nbsp;    }
<i class="no-highlight">4430</i>&nbsp;
<i class="no-highlight">4431</i>&nbsp;    /**
<i class="no-highlight">4432</i>&nbsp;     * Used for moving entries between BINs during splits.
<i class="no-highlight">4433</i>&nbsp;     */
<i class="no-highlight">4434</i>&nbsp;    void appendEntryFromOtherNode(IN from, int fromIdx) {
<i class="no-highlight">4435</i>&nbsp;
<b class="fc"><i class="no-highlight">4436</i>&nbsp;        assert(!isBINDelta());</b>
<i class="no-highlight">4437</i>&nbsp;
<b class="fc"><i class="no-highlight">4438</i>&nbsp;        final Node target = from.entryTargets.get(fromIdx);</b>
<b class="fc"><i class="no-highlight">4439</i>&nbsp;        final int ohBinId = from.getOffHeapBINId(fromIdx);</b>
<b class="fc"><i class="no-highlight">4440</i>&nbsp;        final boolean ohBinPri2 = from.isOffHeapBINPri2(fromIdx);</b>
<b class="fc"><i class="no-highlight">4441</i>&nbsp;        final boolean ohBinDirty = from.isOffHeapBINDirty(fromIdx);</b>
<b class="fc"><i class="no-highlight">4442</i>&nbsp;        final long lsn = from.getLsn(fromIdx);</b>
<b class="fc"><i class="no-highlight">4443</i>&nbsp;        final byte state = from.entryStates[fromIdx];</b>
<b class="fc"><i class="no-highlight">4444</i>&nbsp;        final byte[] key = from.getKey(fromIdx);</b>
<b class="fc"><i class="no-highlight">4445</i>&nbsp;        final byte[] data = (from.haveEmbeddedData(fromIdx) ?</b>
<b class="nc"><i class="no-highlight">4446</i>&nbsp;                             from.getData(fromIdx) : null);</b>
<i class="no-highlight">4447</i>&nbsp;
<b class="fc"><i class="no-highlight">4448</i>&nbsp;        long oldSize = computeLsnOverhead();</b>
<i class="no-highlight">4449</i>&nbsp;
<b class="fc"><i class="no-highlight">4450</i>&nbsp;        ++nEntries;</b>
<i class="no-highlight">4451</i>&nbsp;
<b class="fc"><i class="no-highlight">4452</i>&nbsp;        int idx = nEntries - 1;</b>
<i class="no-highlight">4453</i>&nbsp;
<i class="no-highlight">4454</i>&nbsp;        /*
<i class="no-highlight">4455</i>&nbsp;         * When calling setTarget for an IN child we must latch it, because
<i class="no-highlight">4456</i>&nbsp;         * setTarget sets the parent.
<i class="no-highlight">4457</i>&nbsp;         */
<b class="fc"><i class="no-highlight">4458</i>&nbsp;        if (target != null &amp;&amp; target.isIN()) {</b>
<b class="fc"><i class="no-highlight">4459</i>&nbsp;            final IN in = (IN) target;</b>
<b class="fc"><i class="no-highlight">4460</i>&nbsp;            in.latchNoUpdateLRU(databaseImpl);</b>
<b class="fc"><i class="no-highlight">4461</i>&nbsp;            setTarget(idx, target);</b>
<b class="fc"><i class="no-highlight">4462</i>&nbsp;            in.releaseLatch();</b>
<b class="fc"><i class="no-highlight">4463</i>&nbsp;        } else {</b>
<b class="fc"><i class="no-highlight">4464</i>&nbsp;            setTarget(idx, target);</b>
<i class="no-highlight">4465</i>&nbsp;        }
<i class="no-highlight">4466</i>&nbsp;
<b class="fc"><i class="no-highlight">4467</i>&nbsp;        boolean multiSlotChange = insertKey(idx, key, data);</b>
<i class="no-highlight">4468</i>&nbsp;
<i class="no-highlight">4469</i>&nbsp;        /* setLsnInternal can mutate to an array of longs. */
<b class="fc"><i class="no-highlight">4470</i>&nbsp;        setLsnInternal(idx, lsn);</b>
<i class="no-highlight">4471</i>&nbsp;
<b class="fc"><i class="no-highlight">4472</i>&nbsp;        entryStates[idx] = state;</b>
<i class="no-highlight">4473</i>&nbsp;
<b class="fc"><i class="no-highlight">4474</i>&nbsp;        if (ohBinId &gt;= 0) {</b>
<b class="nc"><i class="no-highlight">4475</i>&nbsp;            setOffHeapBINId(idx, ohBinId, ohBinPri2, ohBinDirty);</b>
<b class="nc"><i class="no-highlight">4476</i>&nbsp;            getOffHeapCache().setOwner(ohBinId, this);</b>
<i class="no-highlight">4477</i>&nbsp;        }
<i class="no-highlight">4478</i>&nbsp;
<b class="fc"><i class="no-highlight">4479</i>&nbsp;        if (multiSlotChange) {</b>
<b class="nc"><i class="no-highlight">4480</i>&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</b>
<i class="no-highlight">4481</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">4482</i>&nbsp;            long newSize = getEntryInMemorySize(idx) + computeLsnOverhead();</b>
<b class="fc"><i class="no-highlight">4483</i>&nbsp;            updateMemorySize(oldSize, newSize);</b>
<i class="no-highlight">4484</i>&nbsp;        }
<i class="no-highlight">4485</i>&nbsp;
<b class="fc"><i class="no-highlight">4486</i>&nbsp;        setDirty(true);</b>
<b class="fc"><i class="no-highlight">4487</i>&nbsp;    }</b>
<i class="no-highlight">4488</i>&nbsp;
<i class="no-highlight">4489</i>&nbsp;    /**
<i class="no-highlight">4490</i>&nbsp;     * Update a slot that is being split. The slot to be updated here is the
<i class="no-highlight">4491</i>&nbsp;     * one that existed before the split.
<i class="no-highlight">4492</i>&nbsp;     *
<i class="no-highlight">4493</i>&nbsp;     * @param child The new child to be placed under the slot. May be the
<i class="no-highlight">4494</i>&nbsp;     * newly created sibling or the pre-existing sibling.
<i class="no-highlight">4495</i>&nbsp;     * @param lsn The new lsn of the child (the child was logged just before
<i class="no-highlight">4496</i>&nbsp;     * calling this method, so its slot lsn must be updated)
<i class="no-highlight">4497</i>&nbsp;     * @param key The new key for the slot. We should not actually update the
<i class="no-highlight">4498</i>&nbsp;     * slot key, because its value is the lower bound of the key range covered
<i class="no-highlight">4499</i>&nbsp;     * by the slot, and this lower bound does not change as a result of the
<i class="no-highlight">4500</i>&nbsp;     * split (the new slot created as a result of the split is placed to the
<i class="no-highlight">4501</i>&nbsp;     * right of the pre-existing slot). There is however one exception: the
<i class="no-highlight">4502</i>&nbsp;     * key can be updated if &quot;idx&quot; is the 0-slot. The 0-slot key is not a true
<i class="no-highlight">4503</i>&nbsp;     * lower bound; the actual lower bound for the 0-slot is the key in the
<i class="no-highlight">4504</i>&nbsp;     * parent slot for this IN. So, in this case, if the given key is less
<i class="no-highlight">4505</i>&nbsp;     * than the current one, it is better to update the key in order to better
<i class="no-highlight">4506</i>&nbsp;     * approximate the real lower bound (and thus make the isKeyInBounds()
<i class="no-highlight">4507</i>&nbsp;     * method more effective).
<i class="no-highlight">4508</i>&nbsp;     */
<i class="no-highlight">4509</i>&nbsp;    private void updateSplitSlot(
<i class="no-highlight">4510</i>&nbsp;        int idx,
<i class="no-highlight">4511</i>&nbsp;        IN child,
<i class="no-highlight">4512</i>&nbsp;        long lsn,
<i class="no-highlight">4513</i>&nbsp;        byte[] key) {
<i class="no-highlight">4514</i>&nbsp;
<b class="fc"><i class="no-highlight">4515</i>&nbsp;        assert(isUpperIN());</b>
<i class="no-highlight">4516</i>&nbsp;
<b class="fc"><i class="no-highlight">4517</i>&nbsp;        long oldSize = getEntryInMemorySize(idx);</b>
<i class="no-highlight">4518</i>&nbsp;
<b class="fc"><i class="no-highlight">4519</i>&nbsp;        setLsn(idx, lsn);</b>
<b class="fc"><i class="no-highlight">4520</i>&nbsp;        setTarget(idx, child);</b>
<i class="no-highlight">4521</i>&nbsp;
<b class="fc"><i class="no-highlight">4522</i>&nbsp;        if (idx == 0) {</b>
<b class="fc"><i class="no-highlight">4523</i>&nbsp;            int s = entryKeys.compareKeys(</b>
<b class="fc"><i class="no-highlight">4524</i>&nbsp;                key, keyPrefix, idx, haveEmbeddedData(idx),</b>
<b class="fc"><i class="no-highlight">4525</i>&nbsp;                getKeyComparator());</b>
<i class="no-highlight">4526</i>&nbsp;
<b class="fc"><i class="no-highlight">4527</i>&nbsp;            boolean multiSlotChange = false;</b>
<b class="fc"><i class="no-highlight">4528</i>&nbsp;            if (s &lt; 0) {</b>
<b class="fc"><i class="no-highlight">4529</i>&nbsp;                multiSlotChange = updateKey(idx, key, null/*data*/);</b>
<i class="no-highlight">4530</i>&nbsp;            }
<i class="no-highlight">4531</i>&nbsp;
<b class="fc"><i class="no-highlight">4532</i>&nbsp;            if (multiSlotChange) {</b>
<b class="nc"><i class="no-highlight">4533</i>&nbsp;                updateMemorySize(inMemorySize, computeMemorySize());</b>
<i class="no-highlight">4534</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">4535</i>&nbsp;                long newSize = getEntryInMemorySize(idx);</b>
<b class="fc"><i class="no-highlight">4536</i>&nbsp;                updateMemorySize(oldSize, newSize);</b>
<i class="no-highlight">4537</i>&nbsp;            }
<b class="fc"><i class="no-highlight">4538</i>&nbsp;        } else {</b>
<b class="fc"><i class="no-highlight">4539</i>&nbsp;            long newSize = getEntryInMemorySize(idx);</b>
<b class="fc"><i class="no-highlight">4540</i>&nbsp;            updateMemorySize(oldSize, newSize);</b>
<i class="no-highlight">4541</i>&nbsp;        }
<i class="no-highlight">4542</i>&nbsp;
<b class="fc"><i class="no-highlight">4543</i>&nbsp;        setDirty(true);</b>
<i class="no-highlight">4544</i>&nbsp;
<b class="fc"><i class="no-highlight">4545</i>&nbsp;        assert(hasCachedChildren() == hasCachedChildrenFlag());</b>
<b class="fc"><i class="no-highlight">4546</i>&nbsp;    }</b>
<i class="no-highlight">4547</i>&nbsp;
<i class="no-highlight">4548</i>&nbsp;    /**
<i class="no-highlight">4549</i>&nbsp;     * Shift entries to the right by one position, starting with (and
<i class="no-highlight">4550</i>&nbsp;     * including) the entry at index. Increment nEntries by 1. Called
<i class="no-highlight">4551</i>&nbsp;     * in insertEntry1()
<i class="no-highlight">4552</i>&nbsp;     *
<i class="no-highlight">4553</i>&nbsp;     * @param index - The position to start shifting from.
<i class="no-highlight">4554</i>&nbsp;     */
<i class="no-highlight">4555</i>&nbsp;    private void shiftEntriesRight(int index) {
<b class="fc"><i class="no-highlight">4556</i>&nbsp;        copyEntries(index, index + 1, nEntries - index);</b>
<b class="fc"><i class="no-highlight">4557</i>&nbsp;        clearEntry(index);</b>
<b class="fc"><i class="no-highlight">4558</i>&nbsp;        nEntries++;</b>
<b class="fc"><i class="no-highlight">4559</i>&nbsp;        setDirty(true);</b>
<b class="fc"><i class="no-highlight">4560</i>&nbsp;    }</b>
<i class="no-highlight">4561</i>&nbsp;
<i class="no-highlight">4562</i>&nbsp;    /**
<i class="no-highlight">4563</i>&nbsp;     * Shift entries starting at the byHowMuch&#39;th element to the left, thus
<i class="no-highlight">4564</i>&nbsp;     * removing the first byHowMuch&#39;th elements of the entries array.  This
<i class="no-highlight">4565</i>&nbsp;     * always starts at the 0th entry. Caller is responsible for decrementing
<i class="no-highlight">4566</i>&nbsp;     * nEntries.
<i class="no-highlight">4567</i>&nbsp;     *
<i class="no-highlight">4568</i>&nbsp;     * @param byHowMuch - The number of entries to remove from the left side
<i class="no-highlight">4569</i>&nbsp;     * of the entries array.
<i class="no-highlight">4570</i>&nbsp;     */
<i class="no-highlight">4571</i>&nbsp;    private void shiftEntriesLeft(int byHowMuch) {
<b class="fc"><i class="no-highlight">4572</i>&nbsp;        copyEntries(byHowMuch, 0, nEntries - byHowMuch);</b>
<b class="fc"><i class="no-highlight">4573</i>&nbsp;        for (int i = nEntries - byHowMuch; i &lt; nEntries; i++) {</b>
<b class="fc"><i class="no-highlight">4574</i>&nbsp;            clearEntry(i);</b>
<i class="no-highlight">4575</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4576</i>&nbsp;        setDirty(true);</b>
<b class="fc"><i class="no-highlight">4577</i>&nbsp;    }</b>
<i class="no-highlight">4578</i>&nbsp;
<i class="no-highlight">4579</i>&nbsp;    void adjustCursors(
<i class="no-highlight">4580</i>&nbsp;        IN newSibling,
<i class="no-highlight">4581</i>&nbsp;        int newSiblingLow,
<i class="no-highlight">4582</i>&nbsp;        int newSiblingHigh) {
<i class="no-highlight">4583</i>&nbsp;        /* Cursors never refer to IN&#39;s. */
<b class="fc"><i class="no-highlight">4584</i>&nbsp;    }</b>
<i class="no-highlight">4585</i>&nbsp;
<i class="no-highlight">4586</i>&nbsp;    void adjustCursorsForInsert(int insertIndex) {
<i class="no-highlight">4587</i>&nbsp;        /* Cursors never refer to IN&#39;s. */
<b class="fc"><i class="no-highlight">4588</i>&nbsp;    }</b>
<i class="no-highlight">4589</i>&nbsp;
<i class="no-highlight">4590</i>&nbsp;    /**
<i class="no-highlight">4591</i>&nbsp;     * Called prior to changing a slot to contain a different logical node.
<i class="no-highlight">4592</i>&nbsp;     *
<i class="no-highlight">4593</i>&nbsp;     * Necessary to support assertions for transient LSNs in shouldUpdateLsn.
<i class="no-highlight">4594</i>&nbsp;     * Examples: LN slot reuse, and splits where a new node is placed in an
<i class="no-highlight">4595</i>&nbsp;     * existing slot.
<i class="no-highlight">4596</i>&nbsp;     *
<i class="no-highlight">4597</i>&nbsp;     * Also needed to free the off-heap BIN associated with the old node.
<i class="no-highlight">4598</i>&nbsp;     *
<i class="no-highlight">4599</i>&nbsp;     * TODO: This method is no longer used for LN slot reuse, and freeing of
<i class="no-highlight">4600</i>&nbsp;     * the off-heap BIN could be done by the only caller, splitInternal, and
<i class="no-highlight">4601</i>&nbsp;     * then this method could be removed.
<i class="no-highlight">4602</i>&nbsp;     */
<i class="no-highlight">4603</i>&nbsp;    public void prepareForSlotReuse(int idx) {
<i class="no-highlight">4604</i>&nbsp;
<b class="fc"><i class="no-highlight">4605</i>&nbsp;        if (databaseImpl.isDeferredWriteMode()) {</b>
<b class="nc"><i class="no-highlight">4606</i>&nbsp;            setLsn(idx, DbLsn.NULL_LSN, false/*check*/);</b>
<i class="no-highlight">4607</i>&nbsp;        }
<i class="no-highlight">4608</i>&nbsp;
<b class="fc"><i class="no-highlight">4609</i>&nbsp;        final OffHeapCache ohCache = getOffHeapCache();</b>
<b class="fc"><i class="no-highlight">4610</i>&nbsp;        if (ohCache.isEnabled() &amp;&amp; getNormalizedLevel() == 2) {</b>
<b class="nc"><i class="no-highlight">4611</i>&nbsp;            ohCache.freeBIN((BIN) getTarget(idx), this, idx);</b>
<i class="no-highlight">4612</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4613</i>&nbsp;    }</b>
<i class="no-highlight">4614</i>&nbsp;
<i class="no-highlight">4615</i>&nbsp;    /*
<i class="no-highlight">4616</i>&nbsp;     * Get the current memory consumption of this node
<i class="no-highlight">4617</i>&nbsp;     */
<i class="no-highlight">4618</i>&nbsp;    public long getInMemorySize() {
<b class="fc"><i class="no-highlight">4619</i>&nbsp;        return inMemorySize;</b>
<i class="no-highlight">4620</i>&nbsp;    }
<i class="no-highlight">4621</i>&nbsp;
<i class="no-highlight">4622</i>&nbsp;    /**
<i class="no-highlight">4623</i>&nbsp;     * Compute the current memory consumption of this node, after putting
<i class="no-highlight">4624</i>&nbsp;     * its keys in their compact representation, if possible.
<i class="no-highlight">4625</i>&nbsp;     */
<i class="no-highlight">4626</i>&nbsp;    private void initMemorySize() {
<b class="fc"><i class="no-highlight">4627</i>&nbsp;        entryKeys = entryKeys.compact(this);</b>
<b class="fc"><i class="no-highlight">4628</i>&nbsp;        inMemorySize = computeMemorySize();</b>
<b class="fc"><i class="no-highlight">4629</i>&nbsp;    }</b>
<i class="no-highlight">4630</i>&nbsp;
<i class="no-highlight">4631</i>&nbsp;    /**
<i class="no-highlight">4632</i>&nbsp;     * Count up the memory usage attributable to this node alone. LNs children
<i class="no-highlight">4633</i>&nbsp;     * are counted by their BIN parents, but INs are not counted by their
<i class="no-highlight">4634</i>&nbsp;     * parents because they are resident on the IN list.  The identifierKey is
<i class="no-highlight">4635</i>&nbsp;     * &quot;intentionally&quot; not kept track of in the memory budget.
<i class="no-highlight">4636</i>&nbsp;     */
<i class="no-highlight">4637</i>&nbsp;    public long computeMemorySize() {
<i class="no-highlight">4638</i>&nbsp;
<b class="fc"><i class="no-highlight">4639</i>&nbsp;        long calcMemorySize = getFixedMemoryOverhead();</b>
<i class="no-highlight">4640</i>&nbsp;
<b class="fc"><i class="no-highlight">4641</i>&nbsp;        calcMemorySize += MemoryBudget.byteArraySize(entryStates.length);</b>
<i class="no-highlight">4642</i>&nbsp;
<b class="fc"><i class="no-highlight">4643</i>&nbsp;        calcMemorySize += computeLsnOverhead();</b>
<i class="no-highlight">4644</i>&nbsp;
<b class="fc"><i class="no-highlight">4645</i>&nbsp;        for (int i = 0; i &lt; nEntries; i++) {</b>
<b class="fc"><i class="no-highlight">4646</i>&nbsp;            calcMemorySize += getEntryInMemorySize(i);</b>
<i class="no-highlight">4647</i>&nbsp;        }
<i class="no-highlight">4648</i>&nbsp;
<b class="fc"><i class="no-highlight">4649</i>&nbsp;        if (keyPrefix != null) {</b>
<b class="nc"><i class="no-highlight">4650</i>&nbsp;            calcMemorySize += MemoryBudget.byteArraySize(keyPrefix.length);</b>
<i class="no-highlight">4651</i>&nbsp;        }
<i class="no-highlight">4652</i>&nbsp;
<b class="fc"><i class="no-highlight">4653</i>&nbsp;        if (provisionalObsolete != null) {</b>
<b class="nc"><i class="no-highlight">4654</i>&nbsp;            calcMemorySize += provisionalObsolete.getMemorySize();</b>
<i class="no-highlight">4655</i>&nbsp;        }
<i class="no-highlight">4656</i>&nbsp;
<b class="fc"><i class="no-highlight">4657</i>&nbsp;        calcMemorySize += entryTargets.calculateMemorySize();</b>
<b class="fc"><i class="no-highlight">4658</i>&nbsp;        calcMemorySize += entryKeys.calculateMemorySize();</b>
<i class="no-highlight">4659</i>&nbsp;
<b class="fc"><i class="no-highlight">4660</i>&nbsp;        if (offHeapBINIds != null) {</b>
<b class="fc"><i class="no-highlight">4661</i>&nbsp;            calcMemorySize += offHeapBINIds.getMemorySize();</b>
<i class="no-highlight">4662</i>&nbsp;        }
<i class="no-highlight">4663</i>&nbsp;
<b class="fc"><i class="no-highlight">4664</i>&nbsp;        return calcMemorySize;</b>
<i class="no-highlight">4665</i>&nbsp;    }
<i class="no-highlight">4666</i>&nbsp;
<i class="no-highlight">4667</i>&nbsp;    /*
<i class="no-highlight">4668</i>&nbsp;     * Overridden by subclasses.
<i class="no-highlight">4669</i>&nbsp;     */
<i class="no-highlight">4670</i>&nbsp;    protected long getFixedMemoryOverhead() {
<b class="fc"><i class="no-highlight">4671</i>&nbsp;        return MemoryBudget.IN_FIXED_OVERHEAD;</b>
<i class="no-highlight">4672</i>&nbsp;    }
<i class="no-highlight">4673</i>&nbsp;
<i class="no-highlight">4674</i>&nbsp;    /*
<i class="no-highlight">4675</i>&nbsp;     * Compute the memory consumption for storing this node&#39;s LSNs
<i class="no-highlight">4676</i>&nbsp;     */
<i class="no-highlight">4677</i>&nbsp;    private int computeLsnOverhead() {
<b class="fc"><i class="no-highlight">4678</i>&nbsp;        return (entryLsnLongArray == null) ?</b>
<b class="fc"><i class="no-highlight">4679</i>&nbsp;            MemoryBudget.byteArraySize(entryLsnByteArray.length) :</b>
<i class="no-highlight">4680</i>&nbsp;            MemoryBudget.ARRAY_OVERHEAD +
<i class="no-highlight">4681</i>&nbsp;                (entryLsnLongArray.length *
<i class="no-highlight">4682</i>&nbsp;                 MemoryBudget.PRIMITIVE_LONG_ARRAY_ITEM_OVERHEAD);
<i class="no-highlight">4683</i>&nbsp;    }
<i class="no-highlight">4684</i>&nbsp;
<i class="no-highlight">4685</i>&nbsp;    private long getEntryInMemorySize(int idx) {
<i class="no-highlight">4686</i>&nbsp;
<i class="no-highlight">4687</i>&nbsp;        /*
<i class="no-highlight">4688</i>&nbsp;         * Do not count state size here, since it is counted as overhead
<i class="no-highlight">4689</i>&nbsp;         * during initialization.
<i class="no-highlight">4690</i>&nbsp;         */
<b class="fc"><i class="no-highlight">4691</i>&nbsp;        long ret = 0;</b>
<i class="no-highlight">4692</i>&nbsp;
<i class="no-highlight">4693</i>&nbsp;        /*
<i class="no-highlight">4694</i>&nbsp;         * Don&#39;t count the key size if the representation has already
<i class="no-highlight">4695</i>&nbsp;         * accounted for it.
<i class="no-highlight">4696</i>&nbsp;         */
<b class="fc"><i class="no-highlight">4697</i>&nbsp;        if (!entryKeys.accountsForKeyByteMemUsage()) {</b>
<i class="no-highlight">4698</i>&nbsp;
<i class="no-highlight">4699</i>&nbsp;            /*
<i class="no-highlight">4700</i>&nbsp;             * Materialize the key object only if needed, thus avoiding the
<i class="no-highlight">4701</i>&nbsp;             * object allocation cost when possible.
<i class="no-highlight">4702</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4703</i>&nbsp;            final byte[] key = entryKeys.get(idx);</b>
<b class="fc"><i class="no-highlight">4704</i>&nbsp;            if (key != null) {</b>
<b class="fc"><i class="no-highlight">4705</i>&nbsp;                ret += MemoryBudget.byteArraySize(key.length);</b>
<i class="no-highlight">4706</i>&nbsp;            }
<i class="no-highlight">4707</i>&nbsp;        }
<i class="no-highlight">4708</i>&nbsp;
<b class="fc"><i class="no-highlight">4709</i>&nbsp;        final Node target = entryTargets.get(idx);</b>
<b class="fc"><i class="no-highlight">4710</i>&nbsp;        if (target != null) {</b>
<b class="fc"><i class="no-highlight">4711</i>&nbsp;            ret += target.getMemorySizeIncludedByParent();</b>
<i class="no-highlight">4712</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4713</i>&nbsp;        return ret;</b>
<i class="no-highlight">4714</i>&nbsp;    }
<i class="no-highlight">4715</i>&nbsp;
<i class="no-highlight">4716</i>&nbsp;    /**
<i class="no-highlight">4717</i>&nbsp;     * Compacts the representation of the IN, if possible.
<i class="no-highlight">4718</i>&nbsp;     *
<i class="no-highlight">4719</i>&nbsp;     * Called by the evictor to reduce memory usage. Should not be called too
<i class="no-highlight">4720</i>&nbsp;     * often (e.g., every CRUD operation), since this could cause lots of
<i class="no-highlight">4721</i>&nbsp;     * memory allocations as the representations contract and expend, resulting
<i class="no-highlight">4722</i>&nbsp;     * in expensive GC.
<i class="no-highlight">4723</i>&nbsp;     *
<i class="no-highlight">4724</i>&nbsp;     * @return number of bytes reclaimed.
<i class="no-highlight">4725</i>&nbsp;     */
<i class="no-highlight">4726</i>&nbsp;    public long compactMemory() {
<i class="no-highlight">4727</i>&nbsp;
<b class="fc"><i class="no-highlight">4728</i>&nbsp;        final long oldSize = inMemorySize;</b>
<b class="fc"><i class="no-highlight">4729</i>&nbsp;        final INKeyRep oldKeyRep = entryKeys;</b>
<i class="no-highlight">4730</i>&nbsp;
<b class="fc"><i class="no-highlight">4731</i>&nbsp;        entryTargets = entryTargets.compact(this);</b>
<b class="fc"><i class="no-highlight">4732</i>&nbsp;        entryKeys = entryKeys.compact(this);</b>
<b class="fc"><i class="no-highlight">4733</i>&nbsp;        offHeapBINIds = offHeapBINIds.compact(this, EMPTY_OFFHEAP_BIN_IDS);</b>
<i class="no-highlight">4734</i>&nbsp;
<i class="no-highlight">4735</i>&nbsp;        /*
<i class="no-highlight">4736</i>&nbsp;         * Note that we only need to account for mem usage changes in the key
<i class="no-highlight">4737</i>&nbsp;         * rep here, not the target rep.  The target rep, unlike the key rep,
<i class="no-highlight">4738</i>&nbsp;         * updates its mem usage internally, and the responsibility for mem
<i class="no-highlight">4739</i>&nbsp;         * usage of contained nodes is fixed -- it is always managed by the IN.
<i class="no-highlight">4740</i>&nbsp;         *
<i class="no-highlight">4741</i>&nbsp;         * When the key rep changes, the accountsForKeyByteMemUsage property
<i class="no-highlight">4742</i>&nbsp;         * also changes. Recalc the size of the entire IN, because
<i class="no-highlight">4743</i>&nbsp;         * responsibility for managing contained key byte mem usage has shifted
<i class="no-highlight">4744</i>&nbsp;         * between the key rep and the IN parent.
<i class="no-highlight">4745</i>&nbsp;         */
<b class="fc"><i class="no-highlight">4746</i>&nbsp;        if (entryKeys != oldKeyRep) {</b>
<b class="fc"><i class="no-highlight">4747</i>&nbsp;            updateMemorySize(inMemorySize, computeMemorySize());</b>
<i class="no-highlight">4748</i>&nbsp;        }
<i class="no-highlight">4749</i>&nbsp;
<b class="fc"><i class="no-highlight">4750</i>&nbsp;        return oldSize - inMemorySize;</b>
<i class="no-highlight">4751</i>&nbsp;    }
<i class="no-highlight">4752</i>&nbsp;
<i class="no-highlight">4753</i>&nbsp;    /**
<i class="no-highlight">4754</i>&nbsp;     * Returns the amount of memory currently budgeted for this IN.
<i class="no-highlight">4755</i>&nbsp;     */
<i class="no-highlight">4756</i>&nbsp;    public long getBudgetedMemorySize() {
<b class="fc"><i class="no-highlight">4757</i>&nbsp;        return inMemorySize - accumulatedDelta;</b>
<i class="no-highlight">4758</i>&nbsp;    }
<i class="no-highlight">4759</i>&nbsp;
<i class="no-highlight">4760</i>&nbsp;    /**
<i class="no-highlight">4761</i>&nbsp;     * Called as part of a memory budget reset (during a checkpoint) to clear
<i class="no-highlight">4762</i>&nbsp;     * the accumulated delta and return the total memory size.
<i class="no-highlight">4763</i>&nbsp;     */
<i class="no-highlight">4764</i>&nbsp;    public long resetAndGetMemorySize() {
<b class="fc"><i class="no-highlight">4765</i>&nbsp;        accumulatedDelta = 0;</b>
<b class="fc"><i class="no-highlight">4766</i>&nbsp;        return inMemorySize;</b>
<i class="no-highlight">4767</i>&nbsp;    }
<i class="no-highlight">4768</i>&nbsp;
<i class="no-highlight">4769</i>&nbsp;    protected void updateMemorySize(long oldSize, long newSize) {
<b class="fc"><i class="no-highlight">4770</i>&nbsp;        long delta = newSize - oldSize;</b>
<b class="fc"><i class="no-highlight">4771</i>&nbsp;        updateMemorySize(delta);</b>
<b class="fc"><i class="no-highlight">4772</i>&nbsp;    }</b>
<i class="no-highlight">4773</i>&nbsp;
<i class="no-highlight">4774</i>&nbsp;    /*
<i class="no-highlight">4775</i>&nbsp;     * Called when a cached child is replaced by another cached child.
<i class="no-highlight">4776</i>&nbsp;     */
<i class="no-highlight">4777</i>&nbsp;    void updateMemorySize(Node oldNode, Node newNode) {
<b class="nc"><i class="no-highlight">4778</i>&nbsp;        long delta = 0;</b>
<b class="nc"><i class="no-highlight">4779</i>&nbsp;        if (newNode != null) {</b>
<b class="nc"><i class="no-highlight">4780</i>&nbsp;            delta = newNode.getMemorySizeIncludedByParent();</b>
<i class="no-highlight">4781</i>&nbsp;        }
<i class="no-highlight">4782</i>&nbsp;
<b class="nc"><i class="no-highlight">4783</i>&nbsp;        if (oldNode != null) {</b>
<b class="nc"><i class="no-highlight">4784</i>&nbsp;            delta -= oldNode.getMemorySizeIncludedByParent();</b>
<i class="no-highlight">4785</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4786</i>&nbsp;        updateMemorySize(delta);</b>
<b class="nc"><i class="no-highlight">4787</i>&nbsp;    }</b>
<i class="no-highlight">4788</i>&nbsp;
<i class="no-highlight">4789</i>&nbsp;    /*
<i class="no-highlight">4790</i>&nbsp;     * Change this.onMemorySize by the given delta and update the memory
<i class="no-highlight">4791</i>&nbsp;     * budget for the cache, but only if the accummulated delta for this
<i class="no-highlight">4792</i>&nbsp;     * node exceeds the ACCUMULATED_LIMIT threshold and this IN is actually
<i class="no-highlight">4793</i>&nbsp;     * on the IN list. (For example, when we create new INs, they are
<i class="no-highlight">4794</i>&nbsp;     * manipulated off the IN list before being added; if we updated the
<i class="no-highlight">4795</i>&nbsp;     * environment wide cache then, we&#39;d end up double counting.)
<i class="no-highlight">4796</i>&nbsp;     */
<i class="no-highlight">4797</i>&nbsp;    void updateMemorySize(long delta) {
<i class="no-highlight">4798</i>&nbsp;
<b class="fc"><i class="no-highlight">4799</i>&nbsp;        if (delta == 0) {</b>
<b class="fc"><i class="no-highlight">4800</i>&nbsp;            return;</b>
<i class="no-highlight">4801</i>&nbsp;        }
<i class="no-highlight">4802</i>&nbsp;
<b class="fc"><i class="no-highlight">4803</i>&nbsp;        inMemorySize += delta;</b>
<i class="no-highlight">4804</i>&nbsp;
<b class="fc"><i class="no-highlight">4805</i>&nbsp;        if (getInListResident()) {</b>
<i class="no-highlight">4806</i>&nbsp;
<i class="no-highlight">4807</i>&nbsp;            /*
<i class="no-highlight">4808</i>&nbsp;             * This assertion is disabled if the environment is invalid to
<i class="no-highlight">4809</i>&nbsp;             * avoid spurious assertions during testing of IO errors.  If the
<i class="no-highlight">4810</i>&nbsp;             * environment is invalid, memory budgeting errors are irrelevant.
<i class="no-highlight">4811</i>&nbsp;             * [#21929]
<i class="no-highlight">4812</i>&nbsp;             */
<b class="fc"><i class="no-highlight">4813</i>&nbsp;            assert</b>
<b class="nc"><i class="no-highlight">4814</i>&nbsp;                inMemorySize &gt;= getFixedMemoryOverhead() ||</b>
<b class="nc"><i class="no-highlight">4815</i>&nbsp;                !getEnv().isValid():</b>
<i class="no-highlight">4816</i>&nbsp;                &quot;delta: &quot; + delta + &quot; inMemorySize: &quot; + inMemorySize +
<b class="nc"><i class="no-highlight">4817</i>&nbsp;                &quot; overhead: &quot; + getFixedMemoryOverhead() +</b>
<b class="nc"><i class="no-highlight">4818</i>&nbsp;                &quot; computed: &quot; + computeMemorySize() +</b>
<b class="nc"><i class="no-highlight">4819</i>&nbsp;                &quot; dump: &quot; + toString() + assertPrintMemorySize();</b>
<i class="no-highlight">4820</i>&nbsp;
<b class="fc"><i class="no-highlight">4821</i>&nbsp;            accumulatedDelta += delta;</b>
<b class="fc"><i class="no-highlight">4822</i>&nbsp;            if (accumulatedDelta &gt; ACCUMULATED_LIMIT ||</b>
<i class="no-highlight">4823</i>&nbsp;                accumulatedDelta &lt; -ACCUMULATED_LIMIT) {
<b class="fc"><i class="no-highlight">4824</i>&nbsp;                updateMemoryBudget();</b>
<i class="no-highlight">4825</i>&nbsp;            }
<i class="no-highlight">4826</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4827</i>&nbsp;    }</b>
<i class="no-highlight">4828</i>&nbsp;
<i class="no-highlight">4829</i>&nbsp;    /**
<i class="no-highlight">4830</i>&nbsp;     * Move the accumulated delta to the memory budget.
<i class="no-highlight">4831</i>&nbsp;     */
<i class="no-highlight">4832</i>&nbsp;    public void updateMemoryBudget() {
<b class="fc"><i class="no-highlight">4833</i>&nbsp;        final EnvironmentImpl env = getEnv();</b>
<b class="fc"><i class="no-highlight">4834</i>&nbsp;        env.getInMemoryINs().memRecalcUpdate(this, accumulatedDelta);</b>
<b class="fc"><i class="no-highlight">4835</i>&nbsp;        env.getMemoryBudget().updateTreeMemoryUsage(accumulatedDelta);</b>
<b class="fc"><i class="no-highlight">4836</i>&nbsp;        accumulatedDelta = 0;</b>
<b class="fc"><i class="no-highlight">4837</i>&nbsp;    }</b>
<i class="no-highlight">4838</i>&nbsp;
<i class="no-highlight">4839</i>&nbsp;    /**
<i class="no-highlight">4840</i>&nbsp;     * Returns the treeAdmin memory in objects referenced by this IN.
<i class="no-highlight">4841</i>&nbsp;     * Specifically, this refers to the DbFileSummaryMap held by
<i class="no-highlight">4842</i>&nbsp;     * MapLNs
<i class="no-highlight">4843</i>&nbsp;     */
<i class="no-highlight">4844</i>&nbsp;    public long getTreeAdminMemorySize() {
<b class="fc"><i class="no-highlight">4845</i>&nbsp;        return 0;  // by default, no treeAdminMemory</b>
<i class="no-highlight">4846</i>&nbsp;    }
<i class="no-highlight">4847</i>&nbsp;
<i class="no-highlight">4848</i>&nbsp;    /*
<i class="no-highlight">4849</i>&nbsp;     *  Utility method used during unit testing.
<i class="no-highlight">4850</i>&nbsp;     */
<i class="no-highlight">4851</i>&nbsp;    protected long printMemorySize() {
<i class="no-highlight">4852</i>&nbsp;
<b class="nc"><i class="no-highlight">4853</i>&nbsp;        final long inOverhead = getFixedMemoryOverhead();</b>
<i class="no-highlight">4854</i>&nbsp;
<b class="nc"><i class="no-highlight">4855</i>&nbsp;        final long statesOverhead =</b>
<b class="nc"><i class="no-highlight">4856</i>&nbsp;            MemoryBudget.byteArraySize(entryStates.length);</b>
<i class="no-highlight">4857</i>&nbsp;
<b class="nc"><i class="no-highlight">4858</i>&nbsp;        final int lsnOverhead =  computeLsnOverhead();</b>
<i class="no-highlight">4859</i>&nbsp;
<b class="nc"><i class="no-highlight">4860</i>&nbsp;        int entryOverhead = 0;</b>
<b class="nc"><i class="no-highlight">4861</i>&nbsp;        for (int i = 0; i &lt; nEntries; i++) {</b>
<b class="nc"><i class="no-highlight">4862</i>&nbsp;            entryOverhead += getEntryInMemorySize(i);</b>
<i class="no-highlight">4863</i>&nbsp;        }
<i class="no-highlight">4864</i>&nbsp;
<b class="nc"><i class="no-highlight">4865</i>&nbsp;        final int keyPrefixOverhead =  (keyPrefix != null) ?</b>
<b class="nc"><i class="no-highlight">4866</i>&nbsp;            MemoryBudget.byteArraySize(keyPrefix.length) : 0;</b>
<i class="no-highlight">4867</i>&nbsp;
<b class="nc"><i class="no-highlight">4868</i>&nbsp;        final int provisionalOverhead = (provisionalObsolete != null) ?</b>
<b class="nc"><i class="no-highlight">4869</i>&nbsp;            provisionalObsolete.getMemorySize() : 0;</b>
<i class="no-highlight">4870</i>&nbsp;
<b class="nc"><i class="no-highlight">4871</i>&nbsp;        final long targetRepOverhead = entryTargets.calculateMemorySize();</b>
<b class="nc"><i class="no-highlight">4872</i>&nbsp;        final long keyRepOverhead = entryKeys.calculateMemorySize();</b>
<b class="nc"><i class="no-highlight">4873</i>&nbsp;        final long total = inOverhead + statesOverhead + lsnOverhead +</b>
<i class="no-highlight">4874</i>&nbsp;             entryOverhead + keyPrefixOverhead +  provisionalOverhead +
<i class="no-highlight">4875</i>&nbsp;             targetRepOverhead + keyRepOverhead;
<i class="no-highlight">4876</i>&nbsp;
<b class="nc"><i class="no-highlight">4877</i>&nbsp;        final long offHeapBINIdOverhead = offHeapBINIds.getMemorySize();</b>
<i class="no-highlight">4878</i>&nbsp;
<b class="nc"><i class="no-highlight">4879</i>&nbsp;        System.out.println(&quot; nEntries:&quot; + nEntries +</b>
<i class="no-highlight">4880</i>&nbsp;                           &quot;/&quot; + entryStates.length +
<i class="no-highlight">4881</i>&nbsp;                           &quot; in: &quot; + inOverhead +
<i class="no-highlight">4882</i>&nbsp;                           &quot; states: &quot; + statesOverhead +
<i class="no-highlight">4883</i>&nbsp;                           &quot; entry: &quot; + entryOverhead +
<i class="no-highlight">4884</i>&nbsp;                           &quot; lsn: &quot; + lsnOverhead +
<i class="no-highlight">4885</i>&nbsp;                           &quot; keyPrefix: &quot; + keyPrefixOverhead +
<i class="no-highlight">4886</i>&nbsp;                           &quot; provisional: &quot; + provisionalOverhead +
<b class="nc"><i class="no-highlight">4887</i>&nbsp;                           &quot; targetRep(&quot; + entryTargets.getType() + &quot;): &quot; +</b>
<i class="no-highlight">4888</i>&nbsp;                           targetRepOverhead +
<b class="nc"><i class="no-highlight">4889</i>&nbsp;                           &quot; keyRep(&quot; + entryKeys.getType() +&quot;): &quot; +</b>
<i class="no-highlight">4890</i>&nbsp;                           keyRepOverhead +
<i class="no-highlight">4891</i>&nbsp;                           &quot; offHeapBINIds: &quot; + offHeapBINIdOverhead +
<i class="no-highlight">4892</i>&nbsp;                           &quot; Total: &quot; + total +
<i class="no-highlight">4893</i>&nbsp;                           &quot; inMemorySize: &quot; + inMemorySize);
<b class="nc"><i class="no-highlight">4894</i>&nbsp;        return total;</b>
<i class="no-highlight">4895</i>&nbsp;    }
<i class="no-highlight">4896</i>&nbsp;
<i class="no-highlight">4897</i>&nbsp;    /* Utility method used to print memory size in an assertion. */
<i class="no-highlight">4898</i>&nbsp;    private boolean assertPrintMemorySize() {
<b class="nc"><i class="no-highlight">4899</i>&nbsp;        printMemorySize();</b>
<b class="nc"><i class="no-highlight">4900</i>&nbsp;        return true;</b>
<i class="no-highlight">4901</i>&nbsp;    }
<i class="no-highlight">4902</i>&nbsp;
<i class="no-highlight">4903</i>&nbsp;    public boolean verifyMemorySize() {
<i class="no-highlight">4904</i>&nbsp;
<b class="nc"><i class="no-highlight">4905</i>&nbsp;        long calcMemorySize = computeMemorySize();</b>
<b class="nc"><i class="no-highlight">4906</i>&nbsp;        if (calcMemorySize != inMemorySize) {</b>
<i class="no-highlight">4907</i>&nbsp;
<b class="nc"><i class="no-highlight">4908</i>&nbsp;            String msg = &quot;-Warning: Out of sync. Should be &quot; +</b>
<i class="no-highlight">4909</i>&nbsp;                calcMemorySize + &quot; / actual: &quot; + inMemorySize +
<b class="nc"><i class="no-highlight">4910</i>&nbsp;                &quot; node: &quot; + getNodeId();</b>
<b class="nc"><i class="no-highlight">4911</i>&nbsp;            LoggerUtils.envLogMsg(Level.INFO, getEnv(), msg);</b>
<i class="no-highlight">4912</i>&nbsp;
<b class="nc"><i class="no-highlight">4913</i>&nbsp;            System.out.println(msg);</b>
<b class="nc"><i class="no-highlight">4914</i>&nbsp;            printMemorySize();</b>
<i class="no-highlight">4915</i>&nbsp;
<b class="nc"><i class="no-highlight">4916</i>&nbsp;            return false;</b>
<i class="no-highlight">4917</i>&nbsp;        }
<b class="nc"><i class="no-highlight">4918</i>&nbsp;        return true;</b>
<i class="no-highlight">4919</i>&nbsp;    }
<i class="no-highlight">4920</i>&nbsp;
<i class="no-highlight">4921</i>&nbsp;    /**
<i class="no-highlight">4922</i>&nbsp;     * Adds (increments) or removes (decrements) the cache stats for the key
<i class="no-highlight">4923</i>&nbsp;     * and target representations.  Used when rep objects are being replaced
<i class="no-highlight">4924</i>&nbsp;     * with a new instance, rather than by calling their mutator methods.
<i class="no-highlight">4925</i>&nbsp;     * Specifically, it is called when mutating from full bin to bin delta
<i class="no-highlight">4926</i>&nbsp;     * or vice-versa.
<i class="no-highlight">4927</i>&nbsp;     */
<i class="no-highlight">4928</i>&nbsp;    protected void updateRepCacheStats(boolean increment) {
<b class="fc"><i class="no-highlight">4929</i>&nbsp;        assert(isBIN());</b>
<b class="fc"><i class="no-highlight">4930</i>&nbsp;        entryKeys.updateCacheStats(increment, this);</b>
<b class="fc"><i class="no-highlight">4931</i>&nbsp;        entryTargets.updateCacheStats(increment, this);</b>
<b class="fc"><i class="no-highlight">4932</i>&nbsp;    }</b>
<i class="no-highlight">4933</i>&nbsp;
<i class="no-highlight">4934</i>&nbsp;    protected int getCompactMaxKeyLength() {
<b class="fc"><i class="no-highlight">4935</i>&nbsp;        return getEnv().getCompactMaxKeyLength();</b>
<i class="no-highlight">4936</i>&nbsp;    }
<i class="no-highlight">4937</i>&nbsp;
<i class="no-highlight">4938</i>&nbsp;    /**
<i class="no-highlight">4939</i>&nbsp;     * Called when adding/removing this IN to/from the INList.
<i class="no-highlight">4940</i>&nbsp;     */
<i class="no-highlight">4941</i>&nbsp;    public void setInListResident(boolean resident) {
<i class="no-highlight">4942</i>&nbsp;
<b class="fc"><i class="no-highlight">4943</i>&nbsp;        if (!resident) {</b>
<i class="no-highlight">4944</i>&nbsp;            /* Decrement the stats before clearing its residency */
<b class="fc"><i class="no-highlight">4945</i>&nbsp;            entryTargets.updateCacheStats(false, this);</b>
<b class="fc"><i class="no-highlight">4946</i>&nbsp;            entryKeys.updateCacheStats(false, this);</b>
<i class="no-highlight">4947</i>&nbsp;        }
<i class="no-highlight">4948</i>&nbsp;
<b class="fc"><i class="no-highlight">4949</i>&nbsp;        if (resident) {</b>
<b class="fc"><i class="no-highlight">4950</i>&nbsp;            flags |= IN_RESIDENT_BIT;</b>
<i class="no-highlight">4951</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">4952</i>&nbsp;            flags &amp;= ~IN_RESIDENT_BIT;</b>
<i class="no-highlight">4953</i>&nbsp;        }
<i class="no-highlight">4954</i>&nbsp;
<b class="fc"><i class="no-highlight">4955</i>&nbsp;        if (resident) {</b>
<i class="no-highlight">4956</i>&nbsp;            /* Increment the stats after setting its residency. */
<b class="fc"><i class="no-highlight">4957</i>&nbsp;            entryTargets.updateCacheStats(true, this);</b>
<b class="fc"><i class="no-highlight">4958</i>&nbsp;            entryKeys.updateCacheStats(true, this);</b>
<i class="no-highlight">4959</i>&nbsp;        }
<b class="fc"><i class="no-highlight">4960</i>&nbsp;    }</b>
<i class="no-highlight">4961</i>&nbsp;
<i class="no-highlight">4962</i>&nbsp;    /**
<i class="no-highlight">4963</i>&nbsp;     * Returns whether this IN is on the INList.
<i class="no-highlight">4964</i>&nbsp;     */
<i class="no-highlight">4965</i>&nbsp;    public boolean getInListResident() {
<b class="fc"><i class="no-highlight">4966</i>&nbsp;        return (flags &amp; IN_RESIDENT_BIT) != 0;</b>
<i class="no-highlight">4967</i>&nbsp;    }
<i class="no-highlight">4968</i>&nbsp;
<i class="no-highlight">4969</i>&nbsp;    public IN getPrevLRUNode() {
<b class="fc"><i class="no-highlight">4970</i>&nbsp;    	return prevLRUNode;</b>
<i class="no-highlight">4971</i>&nbsp;    }
<i class="no-highlight">4972</i>&nbsp;
<i class="no-highlight">4973</i>&nbsp;    public void setPrevLRUNode(IN node) {
<b class="fc"><i class="no-highlight">4974</i>&nbsp;    	prevLRUNode = node;</b>
<b class="fc"><i class="no-highlight">4975</i>&nbsp;    }</b>
<i class="no-highlight">4976</i>&nbsp;
<i class="no-highlight">4977</i>&nbsp;    public IN getNextLRUNode() {
<b class="fc"><i class="no-highlight">4978</i>&nbsp;    	return nextLRUNode;</b>
<i class="no-highlight">4979</i>&nbsp;    }
<i class="no-highlight">4980</i>&nbsp;
<i class="no-highlight">4981</i>&nbsp;    public void setNextLRUNode(IN node) {
<b class="fc"><i class="no-highlight">4982</i>&nbsp;    	nextLRUNode = node;</b>
<b class="fc"><i class="no-highlight">4983</i>&nbsp;    }</b>
<i class="no-highlight">4984</i>&nbsp;
<i class="no-highlight">4985</i>&nbsp;    /**
<i class="no-highlight">4986</i>&nbsp;     * Try to compact or otherwise reclaim memory in this IN and return the
<i class="no-highlight">4987</i>&nbsp;     * number of bytes reclaimed. For example, a BIN should evict LNs, if
<i class="no-highlight">4988</i>&nbsp;     * possible.
<i class="no-highlight">4989</i>&nbsp;     *
<i class="no-highlight">4990</i>&nbsp;     * Used by the evictor to reclaim memory by some means short of evicting
<i class="no-highlight">4991</i>&nbsp;     * the entire node.  If a positive value is returned, the evictor will
<i class="no-highlight">4992</i>&nbsp;     * postpone full eviction of this node.
<i class="no-highlight">4993</i>&nbsp;     */
<i class="no-highlight">4994</i>&nbsp;    public long partialEviction() {
<b class="fc"><i class="no-highlight">4995</i>&nbsp;        return 0;</b>
<i class="no-highlight">4996</i>&nbsp;    }
<i class="no-highlight">4997</i>&nbsp;
<i class="no-highlight">4998</i>&nbsp;    /**
<i class="no-highlight">4999</i>&nbsp;     * Returns whether any child is non-null in the main or off-heap cache.
<i class="no-highlight">5000</i>&nbsp;     */
<i class="no-highlight">5001</i>&nbsp;    public boolean hasCachedChildren() {
<b class="fc"><i class="no-highlight">5002</i>&nbsp;        assert isLatchOwner();</b>
<i class="no-highlight">5003</i>&nbsp;
<b class="fc"><i class="no-highlight">5004</i>&nbsp;        for (int i = 0; i &lt; getNEntries(); i++) {</b>
<b class="fc"><i class="no-highlight">5005</i>&nbsp;            if (entryTargets.get(i) != null) {</b>
<b class="fc"><i class="no-highlight">5006</i>&nbsp;                return true;</b>
<i class="no-highlight">5007</i>&nbsp;            }
<i class="no-highlight">5008</i>&nbsp;        }
<i class="no-highlight">5009</i>&nbsp;
<b class="fc"><i class="no-highlight">5010</i>&nbsp;        return false;</b>
<i class="no-highlight">5011</i>&nbsp;    }
<i class="no-highlight">5012</i>&nbsp;
<i class="no-highlight">5013</i>&nbsp;    /**
<i class="no-highlight">5014</i>&nbsp;     * Disallow delta on next log. Set to true (a) when we we delete a slot
<i class="no-highlight">5015</i>&nbsp;     * from a BIN, (b) when the cleaner marks a BIN as dirty so that it will
<i class="no-highlight">5016</i>&nbsp;     * be migrated during the next checkpoint.
<i class="no-highlight">5017</i>&nbsp;     */
<i class="no-highlight">5018</i>&nbsp;    public void setProhibitNextDelta(boolean val) {
<i class="no-highlight">5019</i>&nbsp;
<b class="fc"><i class="no-highlight">5020</i>&nbsp;        if (!isBIN()) {</b>
<b class="nc"><i class="no-highlight">5021</i>&nbsp;            return;</b>
<i class="no-highlight">5022</i>&nbsp;        }
<i class="no-highlight">5023</i>&nbsp;
<b class="fc"><i class="no-highlight">5024</i>&nbsp;        if (val) {</b>
<b class="nc"><i class="no-highlight">5025</i>&nbsp;            flags |= IN_PROHIBIT_NEXT_DELTA_BIT;</b>
<i class="no-highlight">5026</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">5027</i>&nbsp;            flags &amp;= ~IN_PROHIBIT_NEXT_DELTA_BIT;</b>
<i class="no-highlight">5028</i>&nbsp;        }
<b class="fc"><i class="no-highlight">5029</i>&nbsp;    }</b>
<i class="no-highlight">5030</i>&nbsp;
<i class="no-highlight">5031</i>&nbsp;    public boolean getProhibitNextDelta() {
<b class="fc"><i class="no-highlight">5032</i>&nbsp;        return (flags &amp; IN_PROHIBIT_NEXT_DELTA_BIT) != 0;</b>
<i class="no-highlight">5033</i>&nbsp;    }
<i class="no-highlight">5034</i>&nbsp;
<i class="no-highlight">5035</i>&nbsp;    /*
<i class="no-highlight">5036</i>&nbsp;     * Validate the subtree that we&#39;re about to delete.  Make sure there aren&#39;t
<i class="no-highlight">5037</i>&nbsp;     * more than one valid entry on each IN and that the last level of the tree
<i class="no-highlight">5038</i>&nbsp;     * is empty. Also check that there are no cursors on any bins in this
<i class="no-highlight">5039</i>&nbsp;     * subtree. Assumes caller is holding the latch on this parent node.
<i class="no-highlight">5040</i>&nbsp;     *
<i class="no-highlight">5041</i>&nbsp;     * While we could latch couple down the tree, rather than hold latches as
<i class="no-highlight">5042</i>&nbsp;     * we descend, we are presumably about to delete this subtree so
<i class="no-highlight">5043</i>&nbsp;     * concurrency shouldn&#39;t be an issue.
<i class="no-highlight">5044</i>&nbsp;     *
<i class="no-highlight">5045</i>&nbsp;     * @return true if the subtree rooted at the entry specified by &quot;index&quot; is
<i class="no-highlight">5046</i>&nbsp;     * ok to delete.
<i class="no-highlight">5047</i>&nbsp;     *
<i class="no-highlight">5048</i>&nbsp;     * Overriden by BIN class.
<i class="no-highlight">5049</i>&nbsp;     */
<i class="no-highlight">5050</i>&nbsp;    boolean validateSubtreeBeforeDelete(int index)
<i class="no-highlight">5051</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">5052</i>&nbsp;
<b class="nc"><i class="no-highlight">5053</i>&nbsp;        if (index &gt;= nEntries) {</b>
<i class="no-highlight">5054</i>&nbsp;
<i class="no-highlight">5055</i>&nbsp;            /*
<i class="no-highlight">5056</i>&nbsp;             * There&#39;s no entry here, so of course this entry is deletable.
<i class="no-highlight">5057</i>&nbsp;             */
<b class="nc"><i class="no-highlight">5058</i>&nbsp;            return true;</b>
<i class="no-highlight">5059</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">5060</i>&nbsp;            IN child = fetchIN(index, CacheMode.UNCHANGED);</b>
<i class="no-highlight">5061</i>&nbsp;
<b class="nc"><i class="no-highlight">5062</i>&nbsp;            boolean needToLatch = !child.isLatchExclusiveOwner();</b>
<i class="no-highlight">5063</i>&nbsp;
<i class="no-highlight">5064</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">5065</i>&nbsp;                if (needToLatch) {</b>
<b class="nc"><i class="no-highlight">5066</i>&nbsp;                    child.latch(CacheMode.UNCHANGED);</b>
<i class="no-highlight">5067</i>&nbsp;                }
<b class="nc"><i class="no-highlight">5068</i>&nbsp;                return child.isValidForDelete();</b>
<i class="no-highlight">5069</i>&nbsp;            } finally {
<b class="nc"><i class="no-highlight">5070</i>&nbsp;                if (needToLatch &amp;&amp; isLatchOwner()) {</b>
<b class="nc"><i class="no-highlight">5071</i>&nbsp;                    child.releaseLatch();</b>
<i class="no-highlight">5072</i>&nbsp;                }
<b class="nc"><i class="no-highlight">5073</i>&nbsp;            }</b>
<i class="no-highlight">5074</i>&nbsp;        }
<i class="no-highlight">5075</i>&nbsp;    }
<i class="no-highlight">5076</i>&nbsp;
<i class="no-highlight">5077</i>&nbsp;    /**
<i class="no-highlight">5078</i>&nbsp;     * Check if this node fits the qualifications for being part of a deletable
<i class="no-highlight">5079</i>&nbsp;     * subtree. It can only have one IN child and no LN children.
<i class="no-highlight">5080</i>&nbsp;     *
<i class="no-highlight">5081</i>&nbsp;     * Note: the method is overwritten by BIN and LN.
<i class="no-highlight">5082</i>&nbsp;     * BIN.isValidForDelete() will not fetch any child LNs.
<i class="no-highlight">5083</i>&nbsp;     * LN.isValidForDelete() simply returns false.
<i class="no-highlight">5084</i>&nbsp;     *
<i class="no-highlight">5085</i>&nbsp;     * We assume that this is only called under an assert.
<i class="no-highlight">5086</i>&nbsp;     */
<i class="no-highlight">5087</i>&nbsp;    @Override
<i class="no-highlight">5088</i>&nbsp;    boolean isValidForDelete()
<i class="no-highlight">5089</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">5090</i>&nbsp;
<b class="nc"><i class="no-highlight">5091</i>&nbsp;        assert(!isBINDelta());</b>
<i class="no-highlight">5092</i>&nbsp;
<i class="no-highlight">5093</i>&nbsp;        /*
<i class="no-highlight">5094</i>&nbsp;         * Can only have one valid child, and that child should be
<i class="no-highlight">5095</i>&nbsp;         * deletable.
<i class="no-highlight">5096</i>&nbsp;         */
<b class="nc"><i class="no-highlight">5097</i>&nbsp;        if (nEntries &gt; 1) {            // more than 1 entry.</b>
<b class="nc"><i class="no-highlight">5098</i>&nbsp;            return false;</b>
<i class="no-highlight">5099</i>&nbsp;
<b class="nc"><i class="no-highlight">5100</i>&nbsp;        } else if (nEntries == 1) {    // 1 entry, check child</b>
<b class="nc"><i class="no-highlight">5101</i>&nbsp;            IN child = fetchIN(0, CacheMode.UNCHANGED);</b>
<b class="nc"><i class="no-highlight">5102</i>&nbsp;            boolean needToLatch = !child.isLatchExclusiveOwner();</b>
<b class="nc"><i class="no-highlight">5103</i>&nbsp;            if (needToLatch) {</b>
<b class="nc"><i class="no-highlight">5104</i>&nbsp;                child.latch(CacheMode.UNCHANGED);</b>
<i class="no-highlight">5105</i>&nbsp;            }
<i class="no-highlight">5106</i>&nbsp;
<b class="nc"><i class="no-highlight">5107</i>&nbsp;            boolean ret = false;</b>
<i class="no-highlight">5108</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">5109</i>&nbsp;                if (child.isBINDelta()) {</b>
<b class="nc"><i class="no-highlight">5110</i>&nbsp;                    return false;</b>
<i class="no-highlight">5111</i>&nbsp;                }
<i class="no-highlight">5112</i>&nbsp;
<b class="nc"><i class="no-highlight">5113</i>&nbsp;                ret = child.isValidForDelete();</b>
<i class="no-highlight">5114</i>&nbsp;
<i class="no-highlight">5115</i>&nbsp;            } finally {
<b class="nc"><i class="no-highlight">5116</i>&nbsp;                if (needToLatch) {</b>
<b class="nc"><i class="no-highlight">5117</i>&nbsp;                    child.releaseLatch();</b>
<i class="no-highlight">5118</i>&nbsp;                }
<b class="nc"><i class="no-highlight">5119</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">5120</i>&nbsp;            return ret;</b>
<i class="no-highlight">5121</i>&nbsp;        } else {                       // 0 entries.
<b class="nc"><i class="no-highlight">5122</i>&nbsp;            return true;</b>
<i class="no-highlight">5123</i>&nbsp;        }
<i class="no-highlight">5124</i>&nbsp;    }
<i class="no-highlight">5125</i>&nbsp;
<i class="no-highlight">5126</i>&nbsp;    /**
<i class="no-highlight">5127</i>&nbsp;     * Add self and children to this in-memory IN list. Called by recovery, can
<i class="no-highlight">5128</i>&nbsp;     * run with no latching.
<i class="no-highlight">5129</i>&nbsp;     */
<i class="no-highlight">5130</i>&nbsp;    @Override
<i class="no-highlight">5131</i>&nbsp;    final void rebuildINList(INList inList)
<i class="no-highlight">5132</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">5133</i>&nbsp;
<i class="no-highlight">5134</i>&nbsp;        /*
<i class="no-highlight">5135</i>&nbsp;         * Recompute your in memory size first and then add yourself to the
<i class="no-highlight">5136</i>&nbsp;         * list.
<i class="no-highlight">5137</i>&nbsp;         */
<b class="nc"><i class="no-highlight">5138</i>&nbsp;        initMemorySize();</b>
<i class="no-highlight">5139</i>&nbsp;
<b class="nc"><i class="no-highlight">5140</i>&nbsp;        inList.add(this);</b>
<i class="no-highlight">5141</i>&nbsp;
<b class="nc"><i class="no-highlight">5142</i>&nbsp;        boolean hasCachedChildren = false;</b>
<i class="no-highlight">5143</i>&nbsp;
<i class="no-highlight">5144</i>&nbsp;        /*
<i class="no-highlight">5145</i>&nbsp;         * Add your children if they&#39;re resident. (LNs know how to stop the
<i class="no-highlight">5146</i>&nbsp;         * flow).
<i class="no-highlight">5147</i>&nbsp;         */
<b class="nc"><i class="no-highlight">5148</i>&nbsp;        for (int i = 0; i &lt; nEntries; i++) {</b>
<b class="nc"><i class="no-highlight">5149</i>&nbsp;            Node n = getTarget(i);</b>
<b class="nc"><i class="no-highlight">5150</i>&nbsp;            if (n != null) {</b>
<b class="nc"><i class="no-highlight">5151</i>&nbsp;                n.rebuildINList(inList);</b>
<b class="nc"><i class="no-highlight">5152</i>&nbsp;                hasCachedChildren = true;</b>
<i class="no-highlight">5153</i>&nbsp;            }
<b class="nc"><i class="no-highlight">5154</i>&nbsp;            if (getOffHeapBINId(i) &gt;= 0) {</b>
<b class="nc"><i class="no-highlight">5155</i>&nbsp;                hasCachedChildren = true;</b>
<i class="no-highlight">5156</i>&nbsp;            }
<i class="no-highlight">5157</i>&nbsp;        }
<i class="no-highlight">5158</i>&nbsp;
<b class="nc"><i class="no-highlight">5159</i>&nbsp;        if (isUpperIN()) {</b>
<b class="nc"><i class="no-highlight">5160</i>&nbsp;            if (hasCachedChildren) {</b>
<b class="nc"><i class="no-highlight">5161</i>&nbsp;                setHasCachedChildrenFlag(true);</b>
<i class="no-highlight">5162</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">5163</i>&nbsp;                setHasCachedChildrenFlag(false);</b>
<b class="nc"><i class="no-highlight">5164</i>&nbsp;                if (!isDIN()) {</b>
<i class="no-highlight">5165</i>&nbsp;                    if (traceLRU) {
<i class="no-highlight">5166</i>&nbsp;                        LoggerUtils.envLogMsg(
<i class="no-highlight">5167</i>&nbsp;                            traceLevel, getEnv(),
<i class="no-highlight">5168</i>&nbsp;                            &quot;rebuildINList &quot; +
<i class="no-highlight">5169</i>&nbsp;                            Thread.currentThread().getId() +
<i class="no-highlight">5170</i>&nbsp;                            &quot;-&quot; +
<i class="no-highlight">5171</i>&nbsp;                            Thread.currentThread().getName() +
<i class="no-highlight">5172</i>&nbsp;                            &quot;-&quot; + getEnv().getName() +
<i class="no-highlight">5173</i>&nbsp;                            &quot; Adding UIN to LRU: &quot; +
<i class="no-highlight">5174</i>&nbsp;                            getNodeId());
<i class="no-highlight">5175</i>&nbsp;                    }
<b class="nc"><i class="no-highlight">5176</i>&nbsp;                    getEvictor().addBack(this);</b>
<i class="no-highlight">5177</i>&nbsp;                }
<i class="no-highlight">5178</i>&nbsp;            }
<b class="nc"><i class="no-highlight">5179</i>&nbsp;        } else if (isBIN() &amp;&amp; !isDBIN()) {</b>
<b class="nc"><i class="no-highlight">5180</i>&nbsp;            getEvictor().addBack(this);</b>
<i class="no-highlight">5181</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5182</i>&nbsp;    }</b>
<i class="no-highlight">5183</i>&nbsp;
<i class="no-highlight">5184</i>&nbsp;    /*
<i class="no-highlight">5185</i>&nbsp;     * DbStat support.
<i class="no-highlight">5186</i>&nbsp;     */
<i class="no-highlight">5187</i>&nbsp;    void accumulateStats(TreeWalkerStatsAccumulator acc) {
<b class="nc"><i class="no-highlight">5188</i>&nbsp;        acc.processIN(this, getNodeId(), getLevel());</b>
<b class="nc"><i class="no-highlight">5189</i>&nbsp;    }</b>
<i class="no-highlight">5190</i>&nbsp;
<i class="no-highlight">5191</i>&nbsp;    /**
<i class="no-highlight">5192</i>&nbsp;     * Sets the last logged LSN, which for a BIN may be a delta.
<i class="no-highlight">5193</i>&nbsp;     *
<i class="no-highlight">5194</i>&nbsp;     * It is called from IN.postFetch/RecoveryInit(). If the logrec we have
<i class="no-highlight">5195</i>&nbsp;     * just read was a BINDelta, this.lastFullVersion has already been set (in
<i class="no-highlight">5196</i>&nbsp;     * BINDeltaLogEntry.readMainItem() or in OldBinDelta.reconstituteBIN()).
<i class="no-highlight">5197</i>&nbsp;     * So, this method will set this.lastDeltaVersion. Otherwise, if the
<i class="no-highlight">5198</i>&nbsp;     * logrec was a full BIN, this.lastFullVersion has not been set yet,
<i class="no-highlight">5199</i>&nbsp;     * and it will be set here. In this case, this.lastDeltaVersion will
<i class="no-highlight">5200</i>&nbsp;     * remain NULL.
<i class="no-highlight">5201</i>&nbsp;     */
<i class="no-highlight">5202</i>&nbsp;    public void setLastLoggedLsn(long lsn) {
<i class="no-highlight">5203</i>&nbsp;
<b class="fc"><i class="no-highlight">5204</i>&nbsp;        if (isBIN()) {</b>
<b class="fc"><i class="no-highlight">5205</i>&nbsp;            if (getLastFullLsn() == DbLsn.NULL_LSN) {</b>
<b class="fc"><i class="no-highlight">5206</i>&nbsp;                setLastFullLsn(lsn);</b>
<i class="no-highlight">5207</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">5208</i>&nbsp;                ((BIN)this).setLastDeltaLsn(lsn);</b>
<i class="no-highlight">5209</i>&nbsp;            }
<i class="no-highlight">5210</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">5211</i>&nbsp;            setLastFullLsn(lsn);</b>
<i class="no-highlight">5212</i>&nbsp;        }
<b class="fc"><i class="no-highlight">5213</i>&nbsp;    }</b>
<i class="no-highlight">5214</i>&nbsp;
<i class="no-highlight">5215</i>&nbsp;    /**
<i class="no-highlight">5216</i>&nbsp;     * Returns the LSN of the last last logged version of this IN, or NULL_LSN
<i class="no-highlight">5217</i>&nbsp;     * if never logged.
<i class="no-highlight">5218</i>&nbsp;     */
<i class="no-highlight">5219</i>&nbsp;    public final long getLastLoggedLsn() {
<b class="fc"><i class="no-highlight">5220</i>&nbsp;        if (isBIN()) {</b>
<b class="fc"><i class="no-highlight">5221</i>&nbsp;            return (getLastDeltaLsn() != DbLsn.NULL_LSN ?</b>
<b class="fc"><i class="no-highlight">5222</i>&nbsp;                    getLastDeltaLsn() :</b>
<b class="fc"><i class="no-highlight">5223</i>&nbsp;                    getLastFullLsn());</b>
<i class="no-highlight">5224</i>&nbsp;        }
<i class="no-highlight">5225</i>&nbsp;
<b class="fc"><i class="no-highlight">5226</i>&nbsp;        return getLastFullLsn();</b>
<i class="no-highlight">5227</i>&nbsp;    }
<i class="no-highlight">5228</i>&nbsp;
<i class="no-highlight">5229</i>&nbsp;    /**
<i class="no-highlight">5230</i>&nbsp;     * Sets the last full version LSN.
<i class="no-highlight">5231</i>&nbsp;     */
<i class="no-highlight">5232</i>&nbsp;    public final void setLastFullLsn(long lsn) {
<b class="fc"><i class="no-highlight">5233</i>&nbsp;        lastFullVersion = lsn;</b>
<b class="fc"><i class="no-highlight">5234</i>&nbsp;    }</b>
<i class="no-highlight">5235</i>&nbsp;
<i class="no-highlight">5236</i>&nbsp;    /**
<i class="no-highlight">5237</i>&nbsp;     * Returns the last full version LSN, or NULL_LSN if never logged.
<i class="no-highlight">5238</i>&nbsp;     */
<i class="no-highlight">5239</i>&nbsp;    public final long getLastFullLsn() {
<b class="fc"><i class="no-highlight">5240</i>&nbsp;        return lastFullVersion;</b>
<i class="no-highlight">5241</i>&nbsp;    }
<i class="no-highlight">5242</i>&nbsp;
<i class="no-highlight">5243</i>&nbsp;    /**
<i class="no-highlight">5244</i>&nbsp;     * Returns the last delta version LSN, or NULL_LSN if a delta was not last
<i class="no-highlight">5245</i>&nbsp;     * logged. For BINs, it just returns the value of the lastDeltaVersion
<i class="no-highlight">5246</i>&nbsp;     * field. Public for unit testing.
<i class="no-highlight">5247</i>&nbsp;     */
<i class="no-highlight">5248</i>&nbsp;    public long getLastDeltaLsn() {
<b class="fc"><i class="no-highlight">5249</i>&nbsp;        return DbLsn.NULL_LSN;</b>
<i class="no-highlight">5250</i>&nbsp;    }
<i class="no-highlight">5251</i>&nbsp;
<i class="no-highlight">5252</i>&nbsp;    /*
<i class="no-highlight">5253</i>&nbsp;     * Logging support
<i class="no-highlight">5254</i>&nbsp;     */
<i class="no-highlight">5255</i>&nbsp;
<i class="no-highlight">5256</i>&nbsp;    /**
<i class="no-highlight">5257</i>&nbsp;     * When splits and checkpoints intermingle in a deferred write databases,
<i class="no-highlight">5258</i>&nbsp;     * a checkpoint target may appear which has a valid target but a null LSN.
<i class="no-highlight">5259</i>&nbsp;     * Deferred write dbs are written out in checkpoint style by either
<i class="no-highlight">5260</i>&nbsp;     * Database.sync() or a checkpoint which has cleaned a file containing
<i class="no-highlight">5261</i>&nbsp;     * deferred write entries. For example,
<i class="no-highlight">5262</i>&nbsp;     *   INa
<i class="no-highlight">5263</i>&nbsp;     *    |
<i class="no-highlight">5264</i>&nbsp;     *   BINb
<i class="no-highlight">5265</i>&nbsp;     *
<i class="no-highlight">5266</i>&nbsp;     *  A checkpoint or Database.sync starts
<i class="no-highlight">5267</i>&nbsp;     *  The INList is traversed, dirty nodes are selected
<i class="no-highlight">5268</i>&nbsp;     *  BINb is bypassed on the INList, since it&#39;s not dirty
<i class="no-highlight">5269</i>&nbsp;     *  BINb is split, creating a new sibling, BINc, and dirtying INa
<i class="no-highlight">5270</i>&nbsp;     *  INa is selected as a dirty node for the ckpt
<i class="no-highlight">5271</i>&nbsp;     *
<i class="no-highlight">5272</i>&nbsp;     * If this happens, INa is in the selected dirty set, but not its dirty
<i class="no-highlight">5273</i>&nbsp;     * child BINb and new child BINc.
<i class="no-highlight">5274</i>&nbsp;     *
<i class="no-highlight">5275</i>&nbsp;     * In a durable db, the existence of BINb and BINc are logged
<i class="no-highlight">5276</i>&nbsp;     * anyway. But in a deferred write db, there is an entry that points to
<i class="no-highlight">5277</i>&nbsp;     * BINc, but no logged version.
<i class="no-highlight">5278</i>&nbsp;     *
<i class="no-highlight">5279</i>&nbsp;     * This will not cause problems with eviction, because INa can&#39;t be
<i class="no-highlight">5280</i>&nbsp;     * evicted until BINb and BINc are logged, are non-dirty, and are detached.
<i class="no-highlight">5281</i>&nbsp;     * But it can cause problems at recovery, because INa will have a null LSN
<i class="no-highlight">5282</i>&nbsp;     * for a valid entry, and the LN children of BINc will not find a home.
<i class="no-highlight">5283</i>&nbsp;     * To prevent this, search for all dirty children that might have been
<i class="no-highlight">5284</i>&nbsp;     * missed during the selection phase, and write them out. It&#39;s not
<i class="no-highlight">5285</i>&nbsp;     * sufficient to write only null-LSN children, because the existing sibling
<i class="no-highlight">5286</i>&nbsp;     * must be logged lest LN children recover twice (once in the new sibling,
<i class="no-highlight">5287</i>&nbsp;     * once in the old existing sibling.
<i class="no-highlight">5288</i>&nbsp;     *
<i class="no-highlight">5289</i>&nbsp;     * TODO:
<i class="no-highlight">5290</i>&nbsp;     * Would the problem above be solved by logging dirty nodes using a tree
<i class="no-highlight">5291</i>&nbsp;     * traversal (post-order), rather than using the dirty map?
<i class="no-highlight">5292</i>&nbsp;     *
<i class="no-highlight">5293</i>&nbsp;     * Overriden by BIN class.
<i class="no-highlight">5294</i>&nbsp;     */
<i class="no-highlight">5295</i>&nbsp;    public void logDirtyChildren()
<i class="no-highlight">5296</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">5297</i>&nbsp;
<b class="nc"><i class="no-highlight">5298</i>&nbsp;        assert(!isBINDelta());</b>
<i class="no-highlight">5299</i>&nbsp;
<b class="nc"><i class="no-highlight">5300</i>&nbsp;        EnvironmentImpl envImpl = getDatabase().getEnv();</b>
<i class="no-highlight">5301</i>&nbsp;
<i class="no-highlight">5302</i>&nbsp;        /* Look for targets that are dirty. */
<b class="nc"><i class="no-highlight">5303</i>&nbsp;        for (int i = 0; i &lt; getNEntries(); i++) {</b>
<i class="no-highlight">5304</i>&nbsp;
<b class="nc"><i class="no-highlight">5305</i>&nbsp;            IN child = (IN) getTarget(i);</b>
<i class="no-highlight">5306</i>&nbsp;
<b class="nc"><i class="no-highlight">5307</i>&nbsp;            if (child != null) {</b>
<b class="nc"><i class="no-highlight">5308</i>&nbsp;                child.latch(CacheMode.UNCHANGED);</b>
<i class="no-highlight">5309</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">5310</i>&nbsp;                    if (child.getDirty()) {</b>
<i class="no-highlight">5311</i>&nbsp;                        /* Ask descendants to log their children. */
<b class="nc"><i class="no-highlight">5312</i>&nbsp;                        child.logDirtyChildren();</b>
<b class="nc"><i class="no-highlight">5313</i>&nbsp;                        long childLsn =</b>
<b class="nc"><i class="no-highlight">5314</i>&nbsp;                            child.log(false, // allowDeltas</b>
<i class="no-highlight">5315</i>&nbsp;                                      true,  // isProvisional
<i class="no-highlight">5316</i>&nbsp;                                      true,  // backgroundIO
<i class="no-highlight">5317</i>&nbsp;                                      this); // parent
<i class="no-highlight">5318</i>&nbsp;
<b class="nc"><i class="no-highlight">5319</i>&nbsp;                        updateEntry(</b>
<i class="no-highlight">5320</i>&nbsp;                            i, childLsn, VLSN.NULL_VLSN_SEQUENCE,
<i class="no-highlight">5321</i>&nbsp;                            0/*lastLoggedSize*/);
<i class="no-highlight">5322</i>&nbsp;                    }
<i class="no-highlight">5323</i>&nbsp;                } finally {
<b class="nc"><i class="no-highlight">5324</i>&nbsp;                    child.releaseLatch();</b>
<b class="nc"><i class="no-highlight">5325</i>&nbsp;                }</b>
<i class="no-highlight">5326</i>&nbsp;            }
<i class="no-highlight">5327</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5328</i>&nbsp;    }</b>
<i class="no-highlight">5329</i>&nbsp;
<i class="no-highlight">5330</i>&nbsp;    public final long log() {
<b class="fc"><i class="no-highlight">5331</i>&nbsp;        return logInternal(</b>
<i class="no-highlight">5332</i>&nbsp;            this, null, false /*allowDeltas*/, true /*allowCompress*/,
<i class="no-highlight">5333</i>&nbsp;            Provisional.NO, false /*backgroundIO*/, null /*parent*/);
<i class="no-highlight">5334</i>&nbsp;    }
<i class="no-highlight">5335</i>&nbsp;
<i class="no-highlight">5336</i>&nbsp;    public final long log(
<i class="no-highlight">5337</i>&nbsp;        boolean allowDeltas,
<i class="no-highlight">5338</i>&nbsp;        boolean isProvisional,
<i class="no-highlight">5339</i>&nbsp;        boolean backgroundIO,
<i class="no-highlight">5340</i>&nbsp;        IN parent) {
<i class="no-highlight">5341</i>&nbsp;
<b class="nc"><i class="no-highlight">5342</i>&nbsp;        return logInternal(</b>
<i class="no-highlight">5343</i>&nbsp;            this, null, allowDeltas, true /*allowCompress*/,
<i class="no-highlight">5344</i>&nbsp;            isProvisional ? Provisional.YES : Provisional.NO,
<i class="no-highlight">5345</i>&nbsp;            backgroundIO, parent);
<i class="no-highlight">5346</i>&nbsp;    }
<i class="no-highlight">5347</i>&nbsp;
<i class="no-highlight">5348</i>&nbsp;    public final long log(
<i class="no-highlight">5349</i>&nbsp;        boolean allowDeltas,
<i class="no-highlight">5350</i>&nbsp;        Provisional provisional,
<i class="no-highlight">5351</i>&nbsp;        boolean backgroundIO,
<i class="no-highlight">5352</i>&nbsp;        IN parent) {
<i class="no-highlight">5353</i>&nbsp;
<b class="fc"><i class="no-highlight">5354</i>&nbsp;        return logInternal(</b>
<i class="no-highlight">5355</i>&nbsp;            this, null, allowDeltas, true /*allowCompress*/, provisional, backgroundIO,
<i class="no-highlight">5356</i>&nbsp;            parent);
<i class="no-highlight">5357</i>&nbsp;    }
<i class="no-highlight">5358</i>&nbsp;
<i class="no-highlight">5359</i>&nbsp;    public final long optionalLog() {
<i class="no-highlight">5360</i>&nbsp;
<b class="fc"><i class="no-highlight">5361</i>&nbsp;        if (databaseImpl.isDeferredWriteMode()) {</b>
<b class="nc"><i class="no-highlight">5362</i>&nbsp;            return getLastLoggedLsn();</b>
<i class="no-highlight">5363</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">5364</i>&nbsp;            return logInternal(</b>
<i class="no-highlight">5365</i>&nbsp;                this, null, false /*allowDeltas*/, true /*allowCompress*/,
<i class="no-highlight">5366</i>&nbsp;                Provisional.NO, false /*backgroundIO*/, null /*parent*/);
<i class="no-highlight">5367</i>&nbsp;        }
<i class="no-highlight">5368</i>&nbsp;    }
<i class="no-highlight">5369</i>&nbsp;
<i class="no-highlight">5370</i>&nbsp;    public long optionalLogProvisional(IN parent) {
<b class="fc"><i class="no-highlight">5371</i>&nbsp;        return optionalLogProvisional(parent, true /*allowCompress*/);</b>
<i class="no-highlight">5372</i>&nbsp;    }
<i class="no-highlight">5373</i>&nbsp;
<i class="no-highlight">5374</i>&nbsp;    long optionalLogProvisionalNoCompress(IN parent) {
<b class="fc"><i class="no-highlight">5375</i>&nbsp;        return optionalLogProvisional(parent, false /*allowCompress*/);</b>
<i class="no-highlight">5376</i>&nbsp;    }
<i class="no-highlight">5377</i>&nbsp;
<i class="no-highlight">5378</i>&nbsp;    private long optionalLogProvisional(IN parent, boolean allowCompress) {
<i class="no-highlight">5379</i>&nbsp;
<b class="fc"><i class="no-highlight">5380</i>&nbsp;        if (databaseImpl.isDeferredWriteMode()) {</b>
<b class="nc"><i class="no-highlight">5381</i>&nbsp;            return getLastLoggedLsn();</b>
<i class="no-highlight">5382</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">5383</i>&nbsp;            return logInternal(</b>
<i class="no-highlight">5384</i>&nbsp;                this, null, false /*allowDeltas*/, allowCompress,
<i class="no-highlight">5385</i>&nbsp;                Provisional.YES, false /*backgroundIO*/, parent);
<i class="no-highlight">5386</i>&nbsp;        }
<i class="no-highlight">5387</i>&nbsp;    }
<i class="no-highlight">5388</i>&nbsp;
<i class="no-highlight">5389</i>&nbsp;    public static long logEntry(
<i class="no-highlight">5390</i>&nbsp;        INLogEntry&lt;BIN&gt; logEntry,
<i class="no-highlight">5391</i>&nbsp;        Provisional provisional,
<i class="no-highlight">5392</i>&nbsp;        boolean backgroundIO,
<i class="no-highlight">5393</i>&nbsp;        IN parent) {
<i class="no-highlight">5394</i>&nbsp;
<b class="nc"><i class="no-highlight">5395</i>&nbsp;        return logInternal(</b>
<i class="no-highlight">5396</i>&nbsp;            null, logEntry, true /*allowDeltas*/, false /*allowCompress*/,
<i class="no-highlight">5397</i>&nbsp;            provisional, backgroundIO, parent);
<i class="no-highlight">5398</i>&nbsp;    }
<i class="no-highlight">5399</i>&nbsp;
<i class="no-highlight">5400</i>&nbsp;    /**
<i class="no-highlight">5401</i>&nbsp;     * Bottleneck method for all IN logging.
<i class="no-highlight">5402</i>&nbsp;     *
<i class="no-highlight">5403</i>&nbsp;     * If &#39;node&#39; is non-null, &#39;logEntry&#39; must be null.
<i class="no-highlight">5404</i>&nbsp;     * If &#39;node&#39; is null, &#39;logEntry&#39; and &#39;parent&#39; must be non-null.
<i class="no-highlight">5405</i>&nbsp;     *
<i class="no-highlight">5406</i>&nbsp;     * When &#39;logEntry&#39; is non-null we are logging an off-heap BIN, and it is
<i class="no-highlight">5407</i>&nbsp;     * not resident in the main cache. The lastFull/DeltaLsns are not updated
<i class="no-highlight">5408</i>&nbsp;     * here, and this must be done instead by the caller.
<i class="no-highlight">5409</i>&nbsp;     *
<i class="no-highlight">5410</i>&nbsp;     * When &#39;node&#39; is non-null, &#39;parent&#39; may or may not be null. It must be
<i class="no-highlight">5411</i>&nbsp;     * non-null when logging provisionally, since obsolete LSNs are added to
<i class="no-highlight">5412</i>&nbsp;     * the parent&#39;s collection.
<i class="no-highlight">5413</i>&nbsp;     */
<i class="no-highlight">5414</i>&nbsp;    private static long logInternal(
<i class="no-highlight">5415</i>&nbsp;        final IN node,
<i class="no-highlight">5416</i>&nbsp;        INLogEntry&lt;?&gt; logEntry,
<i class="no-highlight">5417</i>&nbsp;        final boolean allowDeltas,
<i class="no-highlight">5418</i>&nbsp;        final boolean allowCompress,
<i class="no-highlight">5419</i>&nbsp;        final Provisional provisional,
<i class="no-highlight">5420</i>&nbsp;        final boolean backgroundIO,
<i class="no-highlight">5421</i>&nbsp;        final IN parent) {
<i class="no-highlight">5422</i>&nbsp;
<b class="fc"><i class="no-highlight">5423</i>&nbsp;        assert node == null || node.isLatchExclusiveOwner();</b>
<b class="fc"><i class="no-highlight">5424</i>&nbsp;        assert parent == null || parent.isLatchExclusiveOwner();</b>
<b class="fc"><i class="no-highlight">5425</i>&nbsp;        assert node != null || parent != null;</b>
<b class="fc"><i class="no-highlight">5426</i>&nbsp;        assert (node == null) != (logEntry == null);</b>
<i class="no-highlight">5427</i>&nbsp;
<b class="fc"><i class="no-highlight">5428</i>&nbsp;        final DatabaseImpl dbImpl =</b>
<b class="fc"><i class="no-highlight">5429</i>&nbsp;            (node != null) ? node.getDatabase() : parent.getDatabase();</b>
<i class="no-highlight">5430</i>&nbsp;
<b class="fc"><i class="no-highlight">5431</i>&nbsp;        final EnvironmentImpl envImpl = dbImpl.getEnv();</b>
<i class="no-highlight">5432</i>&nbsp;
<b class="fc"><i class="no-highlight">5433</i>&nbsp;        final boolean countObsoleteNow =</b>
<b class="fc"><i class="no-highlight">5434</i>&nbsp;            provisional != Provisional.YES || dbImpl.isTemporary();</b>
<i class="no-highlight">5435</i>&nbsp;
<b class="fc"><i class="no-highlight">5436</i>&nbsp;        final boolean isBin = (node != null) ?</b>
<b class="fc"><i class="no-highlight">5437</i>&nbsp;            node.isBIN() : (parent.getNormalizedLevel() == 2);</b>
<i class="no-highlight">5438</i>&nbsp;
<b class="fc"><i class="no-highlight">5439</i>&nbsp;        final BIN bin = (node != null &amp;&amp; isBin) ? ((BIN) node) : null;</b>
<i class="no-highlight">5440</i>&nbsp;
<i class="no-highlight">5441</i>&nbsp;        final boolean isDelta;
<i class="no-highlight">5442</i>&nbsp;
<b class="fc"><i class="no-highlight">5443</i>&nbsp;        if (isBin) {</b>
<b class="fc"><i class="no-highlight">5444</i>&nbsp;            if (logEntry != null) {</b>
<i class="no-highlight">5445</i>&nbsp;                /*
<i class="no-highlight">5446</i>&nbsp;                 * When a logEntry is supplied (node/bin are null), the logic
<i class="no-highlight">5447</i>&nbsp;                 * below is implemented by OffHeapCache.createBINLogEntry.
<i class="no-highlight">5448</i>&nbsp;                 */
<b class="nc"><i class="no-highlight">5449</i>&nbsp;                isDelta = logEntry.isBINDelta();</b>
<i class="no-highlight">5450</i>&nbsp;            } else {
<i class="no-highlight">5451</i>&nbsp;                /* Compress non-dirty slots before determining delta status. */
<b class="fc"><i class="no-highlight">5452</i>&nbsp;                if (allowCompress) {</b>
<b class="fc"><i class="no-highlight">5453</i>&nbsp;                    envImpl.lazyCompress(bin, false /*compressDirtySlots*/);</b>
<i class="no-highlight">5454</i>&nbsp;                }
<i class="no-highlight">5455</i>&nbsp;
<b class="fc"><i class="no-highlight">5456</i>&nbsp;                isDelta = bin.isBINDelta() ||</b>
<b class="fc"><i class="no-highlight">5457</i>&nbsp;                    (allowDeltas &amp;&amp; bin.shouldLogDelta());</b>
<i class="no-highlight">5458</i>&nbsp;
<i class="no-highlight">5459</i>&nbsp;                /* Be sure that we didn&#39;t illegally mutate to a delta. */
<b class="fc"><i class="no-highlight">5460</i>&nbsp;                assert (!(isDelta &amp;&amp; bin.isDeltaProhibited()));</b>
<i class="no-highlight">5461</i>&nbsp;
<i class="no-highlight">5462</i>&nbsp;                /* Also compress dirty slots, if we will not log a delta. */
<b class="fc"><i class="no-highlight">5463</i>&nbsp;                if (allowCompress &amp;&amp; !isDelta) {</b>
<b class="fc"><i class="no-highlight">5464</i>&nbsp;                    envImpl.lazyCompress(bin, true /*compressDirtySlots*/);</b>
<i class="no-highlight">5465</i>&nbsp;                }
<i class="no-highlight">5466</i>&nbsp;
<i class="no-highlight">5467</i>&nbsp;                /*
<i class="no-highlight">5468</i>&nbsp;                 * Write dirty LNs in deferred-write databases after
<i class="no-highlight">5469</i>&nbsp;                 * compression to reduce total logging, at least for temp DBs.
<i class="no-highlight">5470</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">5471</i>&nbsp;                if (dbImpl.isDeferredWriteMode()) {</b>
<b class="nc"><i class="no-highlight">5472</i>&nbsp;                    bin.logDirtyChildren();</b>
<i class="no-highlight">5473</i>&nbsp;                }
<i class="no-highlight">5474</i>&nbsp;
<b class="fc"><i class="no-highlight">5475</i>&nbsp;                logEntry = isDelta ?</b>
<i class="no-highlight">5476</i>&nbsp;                    (new BINDeltaLogEntry(bin)) :
<i class="no-highlight">5477</i>&nbsp;                    (new INLogEntry&lt;&gt;(bin));
<i class="no-highlight">5478</i>&nbsp;            }
<i class="no-highlight">5479</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">5480</i>&nbsp;            assert node != null;</b>
<i class="no-highlight">5481</i>&nbsp;
<b class="fc"><i class="no-highlight">5482</i>&nbsp;            isDelta = false;</b>
<b class="fc"><i class="no-highlight">5483</i>&nbsp;            logEntry = new INLogEntry&lt;&gt;(node);</b>
<i class="no-highlight">5484</i>&nbsp;        }
<i class="no-highlight">5485</i>&nbsp;
<b class="fc"><i class="no-highlight">5486</i>&nbsp;        final LogParams params = new LogParams();</b>
<b class="fc"><i class="no-highlight">5487</i>&nbsp;        params.entry = logEntry;</b>
<b class="fc"><i class="no-highlight">5488</i>&nbsp;        params.provisional = provisional;</b>
<b class="fc"><i class="no-highlight">5489</i>&nbsp;        params.repContext = ReplicationContext.NO_REPLICATE;</b>
<b class="fc"><i class="no-highlight">5490</i>&nbsp;        params.nodeDb = dbImpl;</b>
<b class="fc"><i class="no-highlight">5491</i>&nbsp;        params.backgroundIO = backgroundIO;</b>
<i class="no-highlight">5492</i>&nbsp;
<i class="no-highlight">5493</i>&nbsp;        /*
<i class="no-highlight">5494</i>&nbsp;         * For delta logging:
<i class="no-highlight">5495</i>&nbsp;         *  + Count lastDeltaVersion obsolete, if non-null.
<i class="no-highlight">5496</i>&nbsp;         *  + Set lastDeltaVersion to newly logged LSN.
<i class="no-highlight">5497</i>&nbsp;         *  + Leave lastFullVersion unchanged.
<i class="no-highlight">5498</i>&nbsp;         *
<i class="no-highlight">5499</i>&nbsp;         * For full version logging:
<i class="no-highlight">5500</i>&nbsp;         *  + Count lastFullVersion and lastDeltaVersion obsolete, if non-null.
<i class="no-highlight">5501</i>&nbsp;         *  + Set lastFullVersion to newly logged LSN.
<i class="no-highlight">5502</i>&nbsp;         *  + Set lastDeltaVersion to null.
<i class="no-highlight">5503</i>&nbsp;         */
<b class="fc"><i class="no-highlight">5504</i>&nbsp;        final long oldLsn =</b>
<b class="fc"><i class="no-highlight">5505</i>&nbsp;            isDelta ? DbLsn.NULL_LSN : logEntry.getPrevFullLsn();</b>
<i class="no-highlight">5506</i>&nbsp;
<b class="fc"><i class="no-highlight">5507</i>&nbsp;        final long auxOldLsn = logEntry.getPrevDeltaLsn();</b>
<i class="no-highlight">5508</i>&nbsp;
<i class="no-highlight">5509</i>&nbsp;        /*
<i class="no-highlight">5510</i>&nbsp;         * Determine whether to count the prior version of an IN (as well as
<i class="no-highlight">5511</i>&nbsp;         * accumulated provisionally obsolete LSNs for child nodes) obsolete
<i class="no-highlight">5512</i>&nbsp;         * when logging the new version.
<i class="no-highlight">5513</i>&nbsp;         *
<i class="no-highlight">5514</i>&nbsp;         * True is set if we are logging the IN non-provisionally, since the
<i class="no-highlight">5515</i>&nbsp;         * non-provisional version durably replaces the prior version and
<i class="no-highlight">5516</i>&nbsp;         * causes all provisional children to also become durable.
<i class="no-highlight">5517</i>&nbsp;         *
<i class="no-highlight">5518</i>&nbsp;         * True is also set if the database is temporary. Since we never use a
<i class="no-highlight">5519</i>&nbsp;         * temporary DB past recovery, prior versions of an IN are never used.
<i class="no-highlight">5520</i>&nbsp;         * [#16928]
<i class="no-highlight">5521</i>&nbsp;         */
<b class="fc"><i class="no-highlight">5522</i>&nbsp;        if (countObsoleteNow) {</b>
<b class="fc"><i class="no-highlight">5523</i>&nbsp;            params.oldLsn = oldLsn;</b>
<b class="fc"><i class="no-highlight">5524</i>&nbsp;            params.auxOldLsn = auxOldLsn;</b>
<b class="fc"><i class="no-highlight">5525</i>&nbsp;            params.packedObsoleteInfo =</b>
<i class="no-highlight">5526</i>&nbsp;                (node != null) ? node.provisionalObsolete : null;
<i class="no-highlight">5527</i>&nbsp;        }
<i class="no-highlight">5528</i>&nbsp;
<i class="no-highlight">5529</i>&nbsp;        /* Log it. */
<b class="fc"><i class="no-highlight">5530</i>&nbsp;        final LogItem item = envImpl.getLogManager().log(params);</b>
<i class="no-highlight">5531</i>&nbsp;
<b class="fc"><i class="no-highlight">5532</i>&nbsp;        if (node != null) {</b>
<b class="fc"><i class="no-highlight">5533</i>&nbsp;            node.setDirty(false);</b>
<i class="no-highlight">5534</i>&nbsp;        }
<i class="no-highlight">5535</i>&nbsp;
<b class="fc"><i class="no-highlight">5536</i>&nbsp;        if (countObsoleteNow) {</b>
<b class="fc"><i class="no-highlight">5537</i>&nbsp;            if (node != null) {</b>
<b class="fc"><i class="no-highlight">5538</i>&nbsp;                node.discardProvisionalObsolete();</b>
<i class="no-highlight">5539</i>&nbsp;            }
<b class="fc"><i class="no-highlight">5540</i>&nbsp;        } else if (parent != null) {</b>
<b class="fc"><i class="no-highlight">5541</i>&nbsp;            parent.trackProvisionalObsolete(node, oldLsn);</b>
<b class="fc"><i class="no-highlight">5542</i>&nbsp;            parent.trackProvisionalObsolete(node, auxOldLsn);</b>
<i class="no-highlight">5543</i>&nbsp;            /*
<i class="no-highlight">5544</i>&nbsp;             * TODO:
<i class="no-highlight">5545</i>&nbsp;             * The parent is null and provisional is YES when evicting the root
<i class="no-highlight">5546</i>&nbsp;             * of a DW DB. How does obsolete counting happen?
<i class="no-highlight">5547</i>&nbsp;             */
<i class="no-highlight">5548</i>&nbsp;        }
<i class="no-highlight">5549</i>&nbsp;
<b class="fc"><i class="no-highlight">5550</i>&nbsp;        if (bin != null) {</b>
<i class="no-highlight">5551</i>&nbsp;            /*
<i class="no-highlight">5552</i>&nbsp;             * When a logEntry is supplied (node/bin are null), the logic
<i class="no-highlight">5553</i>&nbsp;             * below is implemented by OffHeapCache.postBINLog.
<i class="no-highlight">5554</i>&nbsp;             */
<b class="fc"><i class="no-highlight">5555</i>&nbsp;            if (isDelta) {</b>
<b class="fc"><i class="no-highlight">5556</i>&nbsp;                bin.setLastDeltaLsn(item.lsn);</b>
<i class="no-highlight">5557</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">5558</i>&nbsp;                bin.setLastFullLsn(item.lsn);</b>
<b class="fc"><i class="no-highlight">5559</i>&nbsp;                bin.setLastDeltaLsn(DbLsn.NULL_LSN);</b>
<i class="no-highlight">5560</i>&nbsp;            }
<i class="no-highlight">5561</i>&nbsp;
<b class="fc"><i class="no-highlight">5562</i>&nbsp;            bin.setProhibitNextDelta(false);</b>
<i class="no-highlight">5563</i>&nbsp;
<b class="fc"><i class="no-highlight">5564</i>&nbsp;        } else if (node != null) {</b>
<b class="fc"><i class="no-highlight">5565</i>&nbsp;            node.setLastFullLsn(item.lsn);</b>
<i class="no-highlight">5566</i>&nbsp;        }
<i class="no-highlight">5567</i>&nbsp;
<b class="fc"><i class="no-highlight">5568</i>&nbsp;        final Evictor evictor = envImpl.getEvictor();</b>
<i class="no-highlight">5569</i>&nbsp;
<b class="fc"><i class="no-highlight">5570</i>&nbsp;        if (node != null &amp;&amp; evictor.getUseDirtyLRUSet()) {</b>
<i class="no-highlight">5571</i>&nbsp;
<i class="no-highlight">5572</i>&nbsp;            /*
<i class="no-highlight">5573</i>&nbsp;             * To capture all cases where a node needs to be moved to the
<i class="no-highlight">5574</i>&nbsp;             * priority-1 LRUSet after being cleaned, we invoke moveToPri1LRU()
<i class="no-highlight">5575</i>&nbsp;             * from IN.afterLog(). This includes the case where the node is
<i class="no-highlight">5576</i>&nbsp;             * being logged as part of being evicted, in which case we don&#39;t
<i class="no-highlight">5577</i>&nbsp;             * really want it to go back to the LRU. However, this is ok
<i class="no-highlight">5578</i>&nbsp;             * because moveToPri1LRU() checks whether the node is actually
<i class="no-highlight">5579</i>&nbsp;             * in the priority-2 LRUSet before moving it to the priority-1
<i class="no-highlight">5580</i>&nbsp;             * LRUSet.
<i class="no-highlight">5581</i>&nbsp;             */
<i class="no-highlight">5582</i>&nbsp;            if (traceLRU &amp;&amp; node.isUpperIN()) {
<i class="no-highlight">5583</i>&nbsp;                LoggerUtils.envLogMsg(
<i class="no-highlight">5584</i>&nbsp;                    traceLevel, envImpl,
<i class="no-highlight">5585</i>&nbsp;                    Thread.currentThread().getId() + &quot;-&quot; +
<i class="no-highlight">5586</i>&nbsp;                        Thread.currentThread().getName() +
<i class="no-highlight">5587</i>&nbsp;                        &quot;-&quot; + envImpl.getName() +
<i class="no-highlight">5588</i>&nbsp;                        &quot; afterLogCommon(): &quot; +
<i class="no-highlight">5589</i>&nbsp;                        &quot; Moving UIN to mixed LRU: &quot; + node.getNodeId());
<i class="no-highlight">5590</i>&nbsp;            }
<b class="fc"><i class="no-highlight">5591</i>&nbsp;            evictor.moveToPri1LRU(node);</b>
<i class="no-highlight">5592</i>&nbsp;        }
<i class="no-highlight">5593</i>&nbsp;
<b class="fc"><i class="no-highlight">5594</i>&nbsp;        return item.lsn;</b>
<i class="no-highlight">5595</i>&nbsp;    }
<i class="no-highlight">5596</i>&nbsp;
<i class="no-highlight">5597</i>&nbsp;    /**
<i class="no-highlight">5598</i>&nbsp;     * Adds the given obsolete LSN and any tracked obsolete LSNs for the given
<i class="no-highlight">5599</i>&nbsp;     * child IN to this IN&#39;s tracking list.  This method is called to track
<i class="no-highlight">5600</i>&nbsp;     * obsolete LSNs when a child IN is logged provisionally.  Such LSNs
<i class="no-highlight">5601</i>&nbsp;     * cannot be considered obsolete until an ancestor IN is logged
<i class="no-highlight">5602</i>&nbsp;     * non-provisionally.
<i class="no-highlight">5603</i>&nbsp;     */
<i class="no-highlight">5604</i>&nbsp;    void trackProvisionalObsolete(final IN childIN, final long obsoleteLsn) {
<i class="no-highlight">5605</i>&nbsp;
<b class="fc"><i class="no-highlight">5606</i>&nbsp;        final boolean moveChildInfo =</b>
<i class="no-highlight">5607</i>&nbsp;            (childIN != null &amp;&amp; childIN.provisionalObsolete != null);
<i class="no-highlight">5608</i>&nbsp;
<b class="fc"><i class="no-highlight">5609</i>&nbsp;        final boolean addChildLsn = (obsoleteLsn != DbLsn.NULL_LSN);</b>
<i class="no-highlight">5610</i>&nbsp;
<b class="fc"><i class="no-highlight">5611</i>&nbsp;        if (!moveChildInfo &amp;&amp; !addChildLsn) {</b>
<b class="fc"><i class="no-highlight">5612</i>&nbsp;            return;</b>
<i class="no-highlight">5613</i>&nbsp;        }
<i class="no-highlight">5614</i>&nbsp;
<b class="fc"><i class="no-highlight">5615</i>&nbsp;        final int oldMemSize = (provisionalObsolete != null) ?</b>
<b class="fc"><i class="no-highlight">5616</i>&nbsp;             provisionalObsolete.getMemorySize() : 0;</b>
<i class="no-highlight">5617</i>&nbsp;
<b class="fc"><i class="no-highlight">5618</i>&nbsp;        if (moveChildInfo) {</b>
<b class="fc"><i class="no-highlight">5619</i>&nbsp;            if (provisionalObsolete != null) {</b>
<i class="no-highlight">5620</i>&nbsp;                /* Append child info to parent info. */
<b class="nc"><i class="no-highlight">5621</i>&nbsp;                provisionalObsolete.copyObsoleteInfo</b>
<b class="nc"><i class="no-highlight">5622</i>&nbsp;                    (childIN.provisionalObsolete);</b>
<i class="no-highlight">5623</i>&nbsp;            } else {
<i class="no-highlight">5624</i>&nbsp;                /* Move reference from child to parent. */
<b class="fc"><i class="no-highlight">5625</i>&nbsp;                provisionalObsolete = childIN.provisionalObsolete;</b>
<i class="no-highlight">5626</i>&nbsp;            }
<b class="fc"><i class="no-highlight">5627</i>&nbsp;            childIN.updateMemorySize(</b>
<b class="fc"><i class="no-highlight">5628</i>&nbsp;                0 - childIN.provisionalObsolete.getMemorySize());</b>
<b class="fc"><i class="no-highlight">5629</i>&nbsp;            childIN.provisionalObsolete = null;</b>
<i class="no-highlight">5630</i>&nbsp;        }
<i class="no-highlight">5631</i>&nbsp;
<b class="fc"><i class="no-highlight">5632</i>&nbsp;        if (addChildLsn) {</b>
<b class="fc"><i class="no-highlight">5633</i>&nbsp;            if (provisionalObsolete == null) {</b>
<b class="fc"><i class="no-highlight">5634</i>&nbsp;                provisionalObsolete = new PackedObsoleteInfo();</b>
<i class="no-highlight">5635</i>&nbsp;            }
<b class="fc"><i class="no-highlight">5636</i>&nbsp;            provisionalObsolete.addObsoleteInfo(obsoleteLsn);</b>
<i class="no-highlight">5637</i>&nbsp;        }
<i class="no-highlight">5638</i>&nbsp;
<b class="fc"><i class="no-highlight">5639</i>&nbsp;        updateMemorySize(oldMemSize,</b>
<i class="no-highlight">5640</i>&nbsp;                         (provisionalObsolete != null) ?
<b class="fc"><i class="no-highlight">5641</i>&nbsp;                         provisionalObsolete.getMemorySize() :</b>
<i class="no-highlight">5642</i>&nbsp;                         0);
<b class="fc"><i class="no-highlight">5643</i>&nbsp;    }</b>
<i class="no-highlight">5644</i>&nbsp;
<i class="no-highlight">5645</i>&nbsp;    /**
<i class="no-highlight">5646</i>&nbsp;     * Discards the provisional obsolete tracking information in this node
<i class="no-highlight">5647</i>&nbsp;     * after it has been counted in the live tracker.  This method is called
<i class="no-highlight">5648</i>&nbsp;     * after this node is logged non-provisionally.
<i class="no-highlight">5649</i>&nbsp;     */
<i class="no-highlight">5650</i>&nbsp;    private void discardProvisionalObsolete()
<i class="no-highlight">5651</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">5652</i>&nbsp;
<b class="fc"><i class="no-highlight">5653</i>&nbsp;        if (provisionalObsolete != null) {</b>
<b class="fc"><i class="no-highlight">5654</i>&nbsp;            updateMemorySize(0 - provisionalObsolete.getMemorySize());</b>
<b class="fc"><i class="no-highlight">5655</i>&nbsp;            provisionalObsolete = null;</b>
<i class="no-highlight">5656</i>&nbsp;        }
<b class="fc"><i class="no-highlight">5657</i>&nbsp;    }</b>
<i class="no-highlight">5658</i>&nbsp;
<i class="no-highlight">5659</i>&nbsp;    /*
<i class="no-highlight">5660</i>&nbsp;     * NOOP for upper INs. Overriden by BIN class.
<i class="no-highlight">5661</i>&nbsp;     */
<i class="no-highlight">5662</i>&nbsp;    public void mutateToFullBIN(boolean leaveFreeSlot) {
<b class="fc"><i class="no-highlight">5663</i>&nbsp;    }</b>
<i class="no-highlight">5664</i>&nbsp;
<i class="no-highlight">5665</i>&nbsp;    private int getNEntriesToWrite(boolean deltasOnly) {
<b class="fc"><i class="no-highlight">5666</i>&nbsp;        if (!deltasOnly) {</b>
<b class="fc"><i class="no-highlight">5667</i>&nbsp;            return nEntries;</b>
<i class="no-highlight">5668</i>&nbsp;        }
<b class="fc"><i class="no-highlight">5669</i>&nbsp;        return getNDeltas();</b>
<i class="no-highlight">5670</i>&nbsp;    }
<i class="no-highlight">5671</i>&nbsp;
<i class="no-highlight">5672</i>&nbsp;    public final int getNDeltas() {
<b class="fc"><i class="no-highlight">5673</i>&nbsp;        int n = 0;</b>
<b class="fc"><i class="no-highlight">5674</i>&nbsp;        for (int i = 0; i &lt; nEntries; i++) {</b>
<b class="fc"><i class="no-highlight">5675</i>&nbsp;            if (!isDirty(i)) {</b>
<b class="fc"><i class="no-highlight">5676</i>&nbsp;                continue;</b>
<i class="no-highlight">5677</i>&nbsp;            }
<b class="fc"><i class="no-highlight">5678</i>&nbsp;            n += 1;</b>
<i class="no-highlight">5679</i>&nbsp;        }
<b class="fc"><i class="no-highlight">5680</i>&nbsp;        return n;</b>
<i class="no-highlight">5681</i>&nbsp;    }
<i class="no-highlight">5682</i>&nbsp;
<i class="no-highlight">5683</i>&nbsp;    /**
<i class="no-highlight">5684</i>&nbsp;     * @see Node#getGenericLogType
<i class="no-highlight">5685</i>&nbsp;     */
<i class="no-highlight">5686</i>&nbsp;    @Override
<i class="no-highlight">5687</i>&nbsp;    public final LogEntryType getGenericLogType() {
<b class="nc"><i class="no-highlight">5688</i>&nbsp;        return getLogType();</b>
<i class="no-highlight">5689</i>&nbsp;    }
<i class="no-highlight">5690</i>&nbsp;
<i class="no-highlight">5691</i>&nbsp;    /**
<i class="no-highlight">5692</i>&nbsp;     * Get the log type of this node.
<i class="no-highlight">5693</i>&nbsp;     */
<i class="no-highlight">5694</i>&nbsp;    public LogEntryType getLogType() {
<b class="fc"><i class="no-highlight">5695</i>&nbsp;        return LogEntryType.LOG_IN;</b>
<i class="no-highlight">5696</i>&nbsp;    }
<i class="no-highlight">5697</i>&nbsp;
<i class="no-highlight">5698</i>&nbsp;    /**
<i class="no-highlight">5699</i>&nbsp;     * @see Loggable#getLogSize
<i class="no-highlight">5700</i>&nbsp;     *
<i class="no-highlight">5701</i>&nbsp;     * Overrriden by DIN and DBIN classes.
<i class="no-highlight">5702</i>&nbsp;     */
<i class="no-highlight">5703</i>&nbsp;    @Override
<i class="no-highlight">5704</i>&nbsp;    public int getLogSize() {
<b class="nc"><i class="no-highlight">5705</i>&nbsp;        return getLogSize(false);</b>
<i class="no-highlight">5706</i>&nbsp;    }
<i class="no-highlight">5707</i>&nbsp;
<i class="no-highlight">5708</i>&nbsp;    public final int getLogSize(boolean deltasOnly) {
<i class="no-highlight">5709</i>&nbsp;
<b class="fc"><i class="no-highlight">5710</i>&nbsp;        BIN bin = (isBIN() ? (BIN)this : null);</b>
<i class="no-highlight">5711</i>&nbsp;
<b class="fc"><i class="no-highlight">5712</i>&nbsp;        boolean haveVLSNCache = (bin != null &amp;&amp; bin.isVLSNCachingEnabled());</b>
<i class="no-highlight">5713</i>&nbsp;
<b class="fc"><i class="no-highlight">5714</i>&nbsp;        int size = 0;</b>
<i class="no-highlight">5715</i>&nbsp;
<b class="fc"><i class="no-highlight">5716</i>&nbsp;        boolean haveExpiration = false;</b>
<i class="no-highlight">5717</i>&nbsp;
<b class="fc"><i class="no-highlight">5718</i>&nbsp;        if (bin != null) {</b>
<b class="fc"><i class="no-highlight">5719</i>&nbsp;            int base = bin.getExpirationBase();</b>
<b class="fc"><i class="no-highlight">5720</i>&nbsp;            haveExpiration = (base != -1);</b>
<b class="fc"><i class="no-highlight">5721</i>&nbsp;            size += LogUtils.getPackedIntLogSize(base);</b>
<i class="no-highlight">5722</i>&nbsp;        }
<i class="no-highlight">5723</i>&nbsp;
<b class="fc"><i class="no-highlight">5724</i>&nbsp;        size += LogUtils.getPackedLongLogSize(nodeId);</b>
<b class="fc"><i class="no-highlight">5725</i>&nbsp;        size += LogUtils.getByteArrayLogSize(identifierKey); // identifier key</b>
<i class="no-highlight">5726</i>&nbsp;
<b class="fc"><i class="no-highlight">5727</i>&nbsp;        if (keyPrefix != null) {</b>
<b class="nc"><i class="no-highlight">5728</i>&nbsp;            size += LogUtils.getByteArrayLogSize(keyPrefix);</b>
<i class="no-highlight">5729</i>&nbsp;        }
<i class="no-highlight">5730</i>&nbsp;
<b class="fc"><i class="no-highlight">5731</i>&nbsp;        size += 1; // one byte for boolean flags</b>
<i class="no-highlight">5732</i>&nbsp;
<b class="fc"><i class="no-highlight">5733</i>&nbsp;        final int nEntriesToWrite = getNEntriesToWrite(deltasOnly);</b>
<i class="no-highlight">5734</i>&nbsp;
<b class="fc"><i class="no-highlight">5735</i>&nbsp;        final int maxEntriesToWrite =</b>
<i class="no-highlight">5736</i>&nbsp;            (!deltasOnly ?
<b class="fc"><i class="no-highlight">5737</i>&nbsp;             getMaxEntries() :</b>
<b class="fc"><i class="no-highlight">5738</i>&nbsp;             bin.getDeltaCapacity(nEntriesToWrite));</b>
<i class="no-highlight">5739</i>&nbsp;
<b class="fc"><i class="no-highlight">5740</i>&nbsp;        size += LogUtils.getPackedIntLogSize(nEntriesToWrite);</b>
<b class="fc"><i class="no-highlight">5741</i>&nbsp;        size += LogUtils.getPackedIntLogSize(level);</b>
<b class="fc"><i class="no-highlight">5742</i>&nbsp;        size += LogUtils.getPackedIntLogSize(maxEntriesToWrite);</b>
<i class="no-highlight">5743</i>&nbsp;
<b class="fc"><i class="no-highlight">5744</i>&nbsp;        final boolean compactLsnsRep = (entryLsnLongArray == null);</b>
<b class="fc"><i class="no-highlight">5745</i>&nbsp;        size += LogUtils.getBooleanLogSize();   // compactLsnsRep</b>
<b class="fc"><i class="no-highlight">5746</i>&nbsp;        if (compactLsnsRep) {</b>
<b class="fc"><i class="no-highlight">5747</i>&nbsp;            size += LogUtils.INT_BYTES;         // baseFileNumber</b>
<i class="no-highlight">5748</i>&nbsp;        }
<i class="no-highlight">5749</i>&nbsp;
<b class="fc"><i class="no-highlight">5750</i>&nbsp;        for (int i = 0; i &lt; nEntries; i++) {    // entries</b>
<i class="no-highlight">5751</i>&nbsp;
<b class="fc"><i class="no-highlight">5752</i>&nbsp;            if (deltasOnly &amp;&amp; !isDirty(i)) {</b>
<b class="fc"><i class="no-highlight">5753</i>&nbsp;                continue;</b>
<i class="no-highlight">5754</i>&nbsp;            }
<i class="no-highlight">5755</i>&nbsp;
<b class="fc"><i class="no-highlight">5756</i>&nbsp;            size += LogUtils.getByteArrayLogSize(entryKeys.get(i)) + // key</b>
<i class="no-highlight">5757</i>&nbsp;                (compactLsnsRep ? LogUtils.INT_BYTES :
<b class="fc"><i class="no-highlight">5758</i>&nbsp;                 LogUtils.getLongLogSize()) +                       // LSN</b>
<i class="no-highlight">5759</i>&nbsp;                1;                                                  // state
<i class="no-highlight">5760</i>&nbsp;
<b class="fc"><i class="no-highlight">5761</i>&nbsp;            if (isLastLoggedSizeStored(i)) {</b>
<b class="fc"><i class="no-highlight">5762</i>&nbsp;                size += LogUtils.getPackedIntLogSize(getLastLoggedSize(i));</b>
<i class="no-highlight">5763</i>&nbsp;            }
<i class="no-highlight">5764</i>&nbsp;
<b class="fc"><i class="no-highlight">5765</i>&nbsp;            if (haveVLSNCache &amp;&amp; isEmbeddedLN(i)) {</b>
<b class="nc"><i class="no-highlight">5766</i>&nbsp;                size += LogUtils.getPackedLongLogSize(bin.getCachedVLSN(i));</b>
<i class="no-highlight">5767</i>&nbsp;            }
<i class="no-highlight">5768</i>&nbsp;
<b class="fc"><i class="no-highlight">5769</i>&nbsp;            if (haveExpiration) {</b>
<b class="nc"><i class="no-highlight">5770</i>&nbsp;                size +=</b>
<b class="nc"><i class="no-highlight">5771</i>&nbsp;                    LogUtils.getPackedIntLogSize(bin.getExpirationOffset(i));</b>
<i class="no-highlight">5772</i>&nbsp;            }
<i class="no-highlight">5773</i>&nbsp;        }
<i class="no-highlight">5774</i>&nbsp;
<b class="fc"><i class="no-highlight">5775</i>&nbsp;        if (deltasOnly) {</b>
<b class="fc"><i class="no-highlight">5776</i>&nbsp;            size += LogUtils.getPackedIntLogSize(bin.getFullBinNEntries());</b>
<b class="fc"><i class="no-highlight">5777</i>&nbsp;            size += LogUtils.getPackedIntLogSize(bin.getFullBinMaxEntries());</b>
<i class="no-highlight">5778</i>&nbsp;
<b class="fc"><i class="no-highlight">5779</i>&nbsp;            size += bin.getBloomFilterLogSize();</b>
<i class="no-highlight">5780</i>&nbsp;        }
<i class="no-highlight">5781</i>&nbsp;
<b class="fc"><i class="no-highlight">5782</i>&nbsp;        return size;</b>
<i class="no-highlight">5783</i>&nbsp;    }
<i class="no-highlight">5784</i>&nbsp;
<i class="no-highlight">5785</i>&nbsp;    /*
<i class="no-highlight">5786</i>&nbsp;     * Overridden by DIN and DBIN classes.
<i class="no-highlight">5787</i>&nbsp;     */
<i class="no-highlight">5788</i>&nbsp;    @Override
<i class="no-highlight">5789</i>&nbsp;    public void writeToLog(ByteBuffer logBuffer) {
<i class="no-highlight">5790</i>&nbsp;
<b class="nc"><i class="no-highlight">5791</i>&nbsp;        serialize(logBuffer, false /*deltasOnly*/, true /*clearDirtyBits*/);</b>
<b class="nc"><i class="no-highlight">5792</i>&nbsp;    }</b>
<i class="no-highlight">5793</i>&nbsp;
<i class="no-highlight">5794</i>&nbsp;    public void writeToLog(ByteBuffer logBuffer, boolean deltasOnly) {
<i class="no-highlight">5795</i>&nbsp;
<b class="fc"><i class="no-highlight">5796</i>&nbsp;        serialize(logBuffer, deltasOnly, !deltasOnly /*clearDirtyBits*/);</b>
<b class="fc"><i class="no-highlight">5797</i>&nbsp;    }</b>
<i class="no-highlight">5798</i>&nbsp;
<i class="no-highlight">5799</i>&nbsp;    /**
<i class="no-highlight">5800</i>&nbsp;     * WARNING: In the case of BINs this method is not only used for logging
<i class="no-highlight">5801</i>&nbsp;     * but also for off-heap caching. Therefore, this method should not have
<i class="no-highlight">5802</i>&nbsp;     * side effects unless the clearDirtyBits param is true.
<i class="no-highlight">5803</i>&nbsp;     */
<i class="no-highlight">5804</i>&nbsp;    public final void serialize(ByteBuffer logBuffer,
<i class="no-highlight">5805</i>&nbsp;                                boolean deltasOnly,
<i class="no-highlight">5806</i>&nbsp;                                boolean clearDirtyBits) {
<b class="fc"><i class="no-highlight">5807</i>&nbsp;        COUNT_SERIALIZE.incrementAndGet();</b>
<i class="no-highlight">5808</i>&nbsp;
<b class="fc"><i class="no-highlight">5809</i>&nbsp;        assert(!deltasOnly || isBIN());</b>
<i class="no-highlight">5810</i>&nbsp;
<b class="fc"><i class="no-highlight">5811</i>&nbsp;        BIN bin = (isBIN() ? (BIN)this : null);</b>
<i class="no-highlight">5812</i>&nbsp;
<b class="fc"><i class="no-highlight">5813</i>&nbsp;        byte[] bloomFilter = (deltasOnly ? bin.createBloomFilter() : null);</b>
<i class="no-highlight">5814</i>&nbsp;
<b class="fc"><i class="no-highlight">5815</i>&nbsp;        boolean haveExpiration = false;</b>
<i class="no-highlight">5816</i>&nbsp;
<b class="fc"><i class="no-highlight">5817</i>&nbsp;        if (bin != null) {</b>
<b class="fc"><i class="no-highlight">5818</i>&nbsp;            int base = bin.getExpirationBase();</b>
<b class="fc"><i class="no-highlight">5819</i>&nbsp;            haveExpiration = (base != -1);</b>
<b class="fc"><i class="no-highlight">5820</i>&nbsp;            LogUtils.writePackedInt(logBuffer, base);</b>
<i class="no-highlight">5821</i>&nbsp;        }
<i class="no-highlight">5822</i>&nbsp;
<b class="fc"><i class="no-highlight">5823</i>&nbsp;        LogUtils.writePackedLong(logBuffer, nodeId);</b>
<i class="no-highlight">5824</i>&nbsp;
<b class="fc"><i class="no-highlight">5825</i>&nbsp;        LogUtils.writeByteArray(logBuffer, identifierKey);</b>
<i class="no-highlight">5826</i>&nbsp;
<b class="fc"><i class="no-highlight">5827</i>&nbsp;        boolean hasKeyPrefix = (keyPrefix != null);</b>
<b class="fc"><i class="no-highlight">5828</i>&nbsp;        boolean mayHaveLastLoggedSize = mayHaveLastLoggedSizeStored();</b>
<b class="fc"><i class="no-highlight">5829</i>&nbsp;        boolean haveVLSNCache = (bin != null &amp;&amp; bin.isVLSNCachingEnabled());</b>
<i class="no-highlight">5830</i>&nbsp;
<b class="fc"><i class="no-highlight">5831</i>&nbsp;        byte booleans = (byte) (isRoot() ? 1 : 0);</b>
<b class="fc"><i class="no-highlight">5832</i>&nbsp;        booleans |= (hasKeyPrefix ? 2 : 0);</b>
<b class="fc"><i class="no-highlight">5833</i>&nbsp;        booleans |= (mayHaveLastLoggedSize ? 4 : 0);</b>
<b class="fc"><i class="no-highlight">5834</i>&nbsp;        booleans |= (bloomFilter != null ? 8 : 0);</b>
<b class="fc"><i class="no-highlight">5835</i>&nbsp;        booleans |= (haveVLSNCache ? 16 : 0);</b>
<b class="fc"><i class="no-highlight">5836</i>&nbsp;        booleans |= (isExpirationInHours() ? 32 : 0);</b>
<i class="no-highlight">5837</i>&nbsp;
<b class="fc"><i class="no-highlight">5838</i>&nbsp;        logBuffer.put(booleans);</b>
<i class="no-highlight">5839</i>&nbsp;
<b class="fc"><i class="no-highlight">5840</i>&nbsp;        if (hasKeyPrefix) {</b>
<b class="nc"><i class="no-highlight">5841</i>&nbsp;            LogUtils.writeByteArray(logBuffer, keyPrefix);</b>
<i class="no-highlight">5842</i>&nbsp;        }
<i class="no-highlight">5843</i>&nbsp;
<b class="fc"><i class="no-highlight">5844</i>&nbsp;        final int nEntriesToWrite = getNEntriesToWrite(deltasOnly);</b>
<i class="no-highlight">5845</i>&nbsp;
<b class="fc"><i class="no-highlight">5846</i>&nbsp;        final int maxEntriesToWrite =</b>
<i class="no-highlight">5847</i>&nbsp;            (!deltasOnly ?
<b class="fc"><i class="no-highlight">5848</i>&nbsp;             getMaxEntries() :</b>
<b class="fc"><i class="no-highlight">5849</i>&nbsp;             bin.getDeltaCapacity(nEntriesToWrite));</b>
<i class="no-highlight">5850</i>&nbsp;        /*
<i class="no-highlight">5851</i>&nbsp;        if (deltasOnly) {
<i class="no-highlight">5852</i>&nbsp;            BIN bin = (BIN)this;
<i class="no-highlight">5853</i>&nbsp;            System.out.println(
<i class="no-highlight">5854</i>&nbsp;                &quot;Logging BIN-delta: &quot; + getNodeId() +
<i class="no-highlight">5855</i>&nbsp;                &quot; is delta = &quot; + isBINDelta() +
<i class="no-highlight">5856</i>&nbsp;                &quot; nEntries = &quot; + nEntriesToWrite +
<i class="no-highlight">5857</i>&nbsp;                &quot; max entries = &quot; + maxEntriesToWrite +
<i class="no-highlight">5858</i>&nbsp;                &quot; full BIN entries = &quot; + bin.getFullBinNEntries() +
<i class="no-highlight">5859</i>&nbsp;                &quot; full BIN max entries = &quot; + bin.getFullBinMaxEntries());
<i class="no-highlight">5860</i>&nbsp;        }
<i class="no-highlight">5861</i>&nbsp;        */
<b class="fc"><i class="no-highlight">5862</i>&nbsp;        LogUtils.writePackedInt(logBuffer, nEntriesToWrite);</b>
<b class="fc"><i class="no-highlight">5863</i>&nbsp;        LogUtils.writePackedInt(logBuffer, level);</b>
<b class="fc"><i class="no-highlight">5864</i>&nbsp;        LogUtils.writePackedInt(logBuffer, maxEntriesToWrite);</b>
<i class="no-highlight">5865</i>&nbsp;
<i class="no-highlight">5866</i>&nbsp;        /* true if compact representation. */
<b class="fc"><i class="no-highlight">5867</i>&nbsp;        boolean compactLsnsRep = (entryLsnLongArray == null);</b>
<b class="fc"><i class="no-highlight">5868</i>&nbsp;        LogUtils.writeBoolean(logBuffer, compactLsnsRep);</b>
<b class="fc"><i class="no-highlight">5869</i>&nbsp;        if (compactLsnsRep) {</b>
<b class="fc"><i class="no-highlight">5870</i>&nbsp;            LogUtils.writeInt(logBuffer, (int) baseFileNumber);</b>
<i class="no-highlight">5871</i>&nbsp;        }
<i class="no-highlight">5872</i>&nbsp;
<b class="fc"><i class="no-highlight">5873</i>&nbsp;        for (int i = 0; i &lt; nEntries; i++) {</b>
<i class="no-highlight">5874</i>&nbsp;
<b class="fc"><i class="no-highlight">5875</i>&nbsp;            if (deltasOnly &amp;&amp; !isDirty(i)) {</b>
<b class="fc"><i class="no-highlight">5876</i>&nbsp;                continue;</b>
<i class="no-highlight">5877</i>&nbsp;            }
<i class="no-highlight">5878</i>&nbsp;
<b class="fc"><i class="no-highlight">5879</i>&nbsp;            LogUtils.writeByteArray(logBuffer, entryKeys.get(i));</b>
<i class="no-highlight">5880</i>&nbsp;
<i class="no-highlight">5881</i>&nbsp;            /*
<i class="no-highlight">5882</i>&nbsp;             * A NULL_LSN may be stored when an incomplete insertion occurs,
<i class="no-highlight">5883</i>&nbsp;             * but in that case the KnownDeleted flag must be set. See
<i class="no-highlight">5884</i>&nbsp;             * Tree.insert.  [#13126]
<i class="no-highlight">5885</i>&nbsp;             */
<b class="fc"><i class="no-highlight">5886</i>&nbsp;            assert checkForNullLSN(i) :</b>
<b class="nc"><i class="no-highlight">5887</i>&nbsp;                &quot;logging IN &quot; + getNodeId() + &quot; with null lsn child &quot; +</b>
<b class="nc"><i class="no-highlight">5888</i>&nbsp;                &quot; db=&quot; + databaseImpl.getDebugName() +</b>
<b class="nc"><i class="no-highlight">5889</i>&nbsp;                &quot; isDeferredWriteMode=&quot; + databaseImpl.isDeferredWriteMode() +</b>
<b class="nc"><i class="no-highlight">5890</i>&nbsp;                &quot; isTemporary=&quot; + databaseImpl.isTemporary();</b>
<i class="no-highlight">5891</i>&nbsp;
<b class="fc"><i class="no-highlight">5892</i>&nbsp;            if (compactLsnsRep) {</b>
<b class="fc"><i class="no-highlight">5893</i>&nbsp;                int offset = i &lt;&lt; 2;</b>
<b class="fc"><i class="no-highlight">5894</i>&nbsp;                int fileOffset = getFileOffset(offset);</b>
<b class="fc"><i class="no-highlight">5895</i>&nbsp;                logBuffer.put(getFileNumberOffset(offset));</b>
<b class="fc"><i class="no-highlight">5896</i>&nbsp;                logBuffer.put((byte) (fileOffset &amp; 0xff));</b>
<b class="fc"><i class="no-highlight">5897</i>&nbsp;                logBuffer.put((byte) ((fileOffset &gt;&gt;&gt; 8) &amp; 0xff));</b>
<b class="fc"><i class="no-highlight">5898</i>&nbsp;                logBuffer.put((byte) ((fileOffset &gt;&gt;&gt; 16) &amp; 0xff));</b>
<b class="fc"><i class="no-highlight">5899</i>&nbsp;            } else {</b>
<b class="fc"><i class="no-highlight">5900</i>&nbsp;                LogUtils.writeLong(logBuffer, entryLsnLongArray[i]);</b>
<i class="no-highlight">5901</i>&nbsp;            }
<i class="no-highlight">5902</i>&nbsp;
<b class="fc"><i class="no-highlight">5903</i>&nbsp;            logBuffer.put(</b>
<i class="no-highlight">5904</i>&nbsp;                (byte) (entryStates[i] &amp; EntryStates.CLEAR_TRANSIENT_BITS));
<i class="no-highlight">5905</i>&nbsp;
<b class="fc"><i class="no-highlight">5906</i>&nbsp;            if (clearDirtyBits) {</b>
<b class="fc"><i class="no-highlight">5907</i>&nbsp;                entryStates[i] &amp;= EntryStates.CLEAR_DIRTY_BIT;</b>
<i class="no-highlight">5908</i>&nbsp;            }
<i class="no-highlight">5909</i>&nbsp;
<b class="fc"><i class="no-highlight">5910</i>&nbsp;            if (isLastLoggedSizeStored(i)) {</b>
<b class="fc"><i class="no-highlight">5911</i>&nbsp;                LogUtils.writePackedInt(logBuffer, getLastLoggedSize(i));</b>
<i class="no-highlight">5912</i>&nbsp;            }
<i class="no-highlight">5913</i>&nbsp;
<b class="fc"><i class="no-highlight">5914</i>&nbsp;            if (haveVLSNCache &amp;&amp; isEmbeddedLN(i)) {</b>
<b class="nc"><i class="no-highlight">5915</i>&nbsp;                LogUtils.writePackedLong(logBuffer, bin.getCachedVLSN(i));</b>
<i class="no-highlight">5916</i>&nbsp;            }
<i class="no-highlight">5917</i>&nbsp;
<b class="fc"><i class="no-highlight">5918</i>&nbsp;            if (haveExpiration) {</b>
<b class="nc"><i class="no-highlight">5919</i>&nbsp;                LogUtils.writePackedInt(</b>
<b class="nc"><i class="no-highlight">5920</i>&nbsp;                    logBuffer, bin.getExpirationOffset(i));</b>
<i class="no-highlight">5921</i>&nbsp;            }
<i class="no-highlight">5922</i>&nbsp;        }
<i class="no-highlight">5923</i>&nbsp;
<b class="fc"><i class="no-highlight">5924</i>&nbsp;        if (deltasOnly) {</b>
<b class="fc"><i class="no-highlight">5925</i>&nbsp;            LogUtils.writePackedInt(logBuffer, bin.getFullBinNEntries());</b>
<b class="fc"><i class="no-highlight">5926</i>&nbsp;            LogUtils.writePackedInt(logBuffer, bin.getFullBinMaxEntries());</b>
<i class="no-highlight">5927</i>&nbsp;
<b class="fc"><i class="no-highlight">5928</i>&nbsp;            if (bloomFilter != null) {</b>
<b class="fc"><i class="no-highlight">5929</i>&nbsp;                BINDeltaBloomFilter.writeToLog(bloomFilter, logBuffer);</b>
<i class="no-highlight">5930</i>&nbsp;            }
<i class="no-highlight">5931</i>&nbsp;        }
<b class="fc"><i class="no-highlight">5932</i>&nbsp;    }</b>
<i class="no-highlight">5933</i>&nbsp;
<i class="no-highlight">5934</i>&nbsp;    /*
<i class="no-highlight">5935</i>&nbsp;     * Used for assertion to prevent writing a null lsn to the log.
<i class="no-highlight">5936</i>&nbsp;     */
<i class="no-highlight">5937</i>&nbsp;    private boolean checkForNullLSN(int index) {
<i class="no-highlight">5938</i>&nbsp;        boolean ok;
<b class="nc"><i class="no-highlight">5939</i>&nbsp;        if (isBIN()) {</b>
<b class="nc"><i class="no-highlight">5940</i>&nbsp;            ok = !(getLsn(index) == DbLsn.NULL_LSN &amp;&amp;</b>
<i class="no-highlight">5941</i>&nbsp;                   (entryStates[index] &amp; EntryStates.KNOWN_DELETED_BIT) == 0);
<i class="no-highlight">5942</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">5943</i>&nbsp;            ok = (getLsn(index) != DbLsn.NULL_LSN);</b>
<i class="no-highlight">5944</i>&nbsp;        }
<b class="nc"><i class="no-highlight">5945</i>&nbsp;        return ok;</b>
<i class="no-highlight">5946</i>&nbsp;    }
<i class="no-highlight">5947</i>&nbsp;
<i class="no-highlight">5948</i>&nbsp;    /**
<i class="no-highlight">5949</i>&nbsp;     * Returns whether the given serialized IN is a BIN that may have
<i class="no-highlight">5950</i>&nbsp;     * expiration values.
<i class="no-highlight">5951</i>&nbsp;     */
<i class="no-highlight">5952</i>&nbsp;    public boolean mayHaveExpirationValues(
<i class="no-highlight">5953</i>&nbsp;        ByteBuffer itemBuffer,
<i class="no-highlight">5954</i>&nbsp;        int entryVersion) {
<i class="no-highlight">5955</i>&nbsp;
<b class="nc"><i class="no-highlight">5956</i>&nbsp;        if (!isBIN() || entryVersion &lt; 12) {</b>
<b class="nc"><i class="no-highlight">5957</i>&nbsp;            return false;</b>
<i class="no-highlight">5958</i>&nbsp;        }
<i class="no-highlight">5959</i>&nbsp;
<b class="nc"><i class="no-highlight">5960</i>&nbsp;        itemBuffer.mark();</b>
<b class="nc"><i class="no-highlight">5961</i>&nbsp;        int expirationBase = LogUtils.readPackedInt(itemBuffer);</b>
<b class="nc"><i class="no-highlight">5962</i>&nbsp;        itemBuffer.reset();</b>
<i class="no-highlight">5963</i>&nbsp;
<b class="nc"><i class="no-highlight">5964</i>&nbsp;        return (expirationBase != -1);</b>
<i class="no-highlight">5965</i>&nbsp;    }
<i class="no-highlight">5966</i>&nbsp;
<i class="no-highlight">5967</i>&nbsp;    @Override
<i class="no-highlight">5968</i>&nbsp;    public void readFromLog(
<i class="no-highlight">5969</i>&nbsp;        ByteBuffer itemBuffer,
<i class="no-highlight">5970</i>&nbsp;        int entryVersion) {
<i class="no-highlight">5971</i>&nbsp;
<b class="fc"><i class="no-highlight">5972</i>&nbsp;        materialize(</b>
<i class="no-highlight">5973</i>&nbsp;            itemBuffer, entryVersion,
<i class="no-highlight">5974</i>&nbsp;            false /*deltasOnly*/, true /*clearDirtyBits*/);
<b class="fc"><i class="no-highlight">5975</i>&nbsp;    }</b>
<i class="no-highlight">5976</i>&nbsp;
<i class="no-highlight">5977</i>&nbsp;    public void readFromLog(
<i class="no-highlight">5978</i>&nbsp;        ByteBuffer itemBuffer,
<i class="no-highlight">5979</i>&nbsp;        int entryVersion,
<i class="no-highlight">5980</i>&nbsp;        boolean deltasOnly) {
<i class="no-highlight">5981</i>&nbsp;
<b class="fc"><i class="no-highlight">5982</i>&nbsp;        materialize(</b>
<i class="no-highlight">5983</i>&nbsp;            itemBuffer, entryVersion,
<i class="no-highlight">5984</i>&nbsp;            deltasOnly, !deltasOnly /*clearDirtyBits*/);
<b class="fc"><i class="no-highlight">5985</i>&nbsp;    }</b>
<i class="no-highlight">5986</i>&nbsp;
<i class="no-highlight">5987</i>&nbsp;    /**
<i class="no-highlight">5988</i>&nbsp;     * WARNING: In the case of BINs this method is used not only for logging
<i class="no-highlight">5989</i>&nbsp;     * but also for off-heap caching. Therefore, this method should not have
<i class="no-highlight">5990</i>&nbsp;     * side effects unless the clearDirtyBits param is true or an older log
<i class="no-highlight">5991</i>&nbsp;     * version is passed (off-heap caching uses the current version).
<i class="no-highlight">5992</i>&nbsp;     */
<i class="no-highlight">5993</i>&nbsp;    public final void materialize(
<i class="no-highlight">5994</i>&nbsp;        ByteBuffer itemBuffer,
<i class="no-highlight">5995</i>&nbsp;        int entryVersion,
<i class="no-highlight">5996</i>&nbsp;        boolean deltasOnly,
<i class="no-highlight">5997</i>&nbsp;        boolean clearDirtyBits) {
<i class="no-highlight">5998</i>&nbsp;
<b class="fc"><i class="no-highlight">5999</i>&nbsp;        assert(!deltasOnly || isBIN());</b>
<i class="no-highlight">6000</i>&nbsp;
<b class="fc"><i class="no-highlight">6001</i>&nbsp;        BIN bin = (isBIN() ? (BIN)this : null);</b>
<i class="no-highlight">6002</i>&nbsp;
<b class="fc"><i class="no-highlight">6003</i>&nbsp;        boolean unpacked = (entryVersion &lt; 6);</b>
<i class="no-highlight">6004</i>&nbsp;
<b class="fc"><i class="no-highlight">6005</i>&nbsp;        boolean haveExpiration = false;</b>
<i class="no-highlight">6006</i>&nbsp;
<b class="fc"><i class="no-highlight">6007</i>&nbsp;        if (bin != null &amp;&amp; entryVersion &gt;= 12) {</b>
<b class="fc"><i class="no-highlight">6008</i>&nbsp;            int base = LogUtils.readPackedInt(itemBuffer);</b>
<b class="fc"><i class="no-highlight">6009</i>&nbsp;            haveExpiration = (base != -1);</b>
<b class="fc"><i class="no-highlight">6010</i>&nbsp;            bin.setExpirationBase(base);</b>
<i class="no-highlight">6011</i>&nbsp;        }
<i class="no-highlight">6012</i>&nbsp;
<b class="fc"><i class="no-highlight">6013</i>&nbsp;        nodeId = LogUtils.readLong(itemBuffer, unpacked);</b>
<b class="fc"><i class="no-highlight">6014</i>&nbsp;        identifierKey = LogUtils.readByteArray(itemBuffer, unpacked);</b>
<i class="no-highlight">6015</i>&nbsp;
<b class="fc"><i class="no-highlight">6016</i>&nbsp;        byte booleans = itemBuffer.get();</b>
<i class="no-highlight">6017</i>&nbsp;
<b class="fc"><i class="no-highlight">6018</i>&nbsp;        setIsRootFlag((booleans &amp; 1) != 0);</b>
<i class="no-highlight">6019</i>&nbsp;
<b class="fc"><i class="no-highlight">6020</i>&nbsp;        if ((booleans &amp; 2) != 0) {</b>
<b class="nc"><i class="no-highlight">6021</i>&nbsp;            keyPrefix = LogUtils.readByteArray(itemBuffer, unpacked);</b>
<i class="no-highlight">6022</i>&nbsp;        }
<i class="no-highlight">6023</i>&nbsp;
<b class="fc"><i class="no-highlight">6024</i>&nbsp;        boolean mayHaveLastLoggedSize = ((booleans &amp; 4) != 0);</b>
<b class="fc"><i class="no-highlight">6025</i>&nbsp;        assert !(mayHaveLastLoggedSize &amp;&amp; (entryVersion &lt; 9));</b>
<i class="no-highlight">6026</i>&nbsp;
<b class="fc"><i class="no-highlight">6027</i>&nbsp;        boolean hasBloomFilter = ((booleans &amp; 8) != 0);</b>
<b class="fc"><i class="no-highlight">6028</i>&nbsp;        assert(!hasBloomFilter || (entryVersion &gt;= 10 &amp;&amp; deltasOnly));</b>
<i class="no-highlight">6029</i>&nbsp;
<b class="fc"><i class="no-highlight">6030</i>&nbsp;        boolean haveVLSNCache = ((booleans &amp; 16) != 0);</b>
<b class="fc"><i class="no-highlight">6031</i>&nbsp;        assert !(haveVLSNCache &amp;&amp; (entryVersion &lt; 11));</b>
<i class="no-highlight">6032</i>&nbsp;
<b class="fc"><i class="no-highlight">6033</i>&nbsp;        setExpirationInHours((booleans &amp; 32) != 0);</b>
<i class="no-highlight">6034</i>&nbsp;
<b class="fc"><i class="no-highlight">6035</i>&nbsp;        nEntries = LogUtils.readInt(itemBuffer, unpacked);</b>
<b class="fc"><i class="no-highlight">6036</i>&nbsp;        level = LogUtils.readInt(itemBuffer, unpacked);</b>
<b class="fc"><i class="no-highlight">6037</i>&nbsp;        int length = LogUtils.readInt(itemBuffer, unpacked);</b>
<i class="no-highlight">6038</i>&nbsp;
<b class="fc"><i class="no-highlight">6039</i>&nbsp;        entryTargets = INTargetRep.NONE;</b>
<b class="fc"><i class="no-highlight">6040</i>&nbsp;        entryKeys = new INKeyRep.Default(length);</b>
<b class="fc"><i class="no-highlight">6041</i>&nbsp;        baseFileNumber = -1;</b>
<b class="fc"><i class="no-highlight">6042</i>&nbsp;        long storedBaseFileNumber = -1;</b>
<b class="fc"><i class="no-highlight">6043</i>&nbsp;        if (disableCompactLsns) {</b>
<b class="nc"><i class="no-highlight">6044</i>&nbsp;            entryLsnByteArray = null;</b>
<b class="nc"><i class="no-highlight">6045</i>&nbsp;            entryLsnLongArray = new long[length];</b>
<i class="no-highlight">6046</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">6047</i>&nbsp;            entryLsnByteArray = new byte[length &lt;&lt; 2];</b>
<b class="fc"><i class="no-highlight">6048</i>&nbsp;            entryLsnLongArray = null;</b>
<i class="no-highlight">6049</i>&nbsp;        }
<b class="fc"><i class="no-highlight">6050</i>&nbsp;        entryStates = new byte[length];</b>
<b class="fc"><i class="no-highlight">6051</i>&nbsp;        boolean compactLsnsRep = false;</b>
<i class="no-highlight">6052</i>&nbsp;
<b class="fc"><i class="no-highlight">6053</i>&nbsp;        if (entryVersion &gt; 1) {</b>
<b class="fc"><i class="no-highlight">6054</i>&nbsp;            compactLsnsRep = LogUtils.readBoolean(itemBuffer);</b>
<b class="fc"><i class="no-highlight">6055</i>&nbsp;            if (compactLsnsRep) {</b>
<b class="fc"><i class="no-highlight">6056</i>&nbsp;                baseFileNumber = LogUtils.readInt(itemBuffer);</b>
<b class="fc"><i class="no-highlight">6057</i>&nbsp;                storedBaseFileNumber = baseFileNumber;</b>
<i class="no-highlight">6058</i>&nbsp;            }
<i class="no-highlight">6059</i>&nbsp;        }
<i class="no-highlight">6060</i>&nbsp;
<b class="fc"><i class="no-highlight">6061</i>&nbsp;        for (int i = 0; i &lt; nEntries; i++) {</b>
<i class="no-highlight">6062</i>&nbsp;
<b class="fc"><i class="no-highlight">6063</i>&nbsp;            entryKeys = entryKeys.set(</b>
<b class="fc"><i class="no-highlight">6064</i>&nbsp;                i, LogUtils.readByteArray(itemBuffer, unpacked), this);</b>
<i class="no-highlight">6065</i>&nbsp;
<i class="no-highlight">6066</i>&nbsp;            long lsn;
<b class="fc"><i class="no-highlight">6067</i>&nbsp;            if (compactLsnsRep) {</b>
<i class="no-highlight">6068</i>&nbsp;                /* LSNs in compact form. */
<b class="fc"><i class="no-highlight">6069</i>&nbsp;                byte fileNumberOffset = itemBuffer.get();</b>
<b class="fc"><i class="no-highlight">6070</i>&nbsp;                int fileOffset = (itemBuffer.get() &amp; 0xff);</b>
<b class="fc"><i class="no-highlight">6071</i>&nbsp;                fileOffset |= ((itemBuffer.get() &amp; 0xff) &lt;&lt; 8);</b>
<b class="fc"><i class="no-highlight">6072</i>&nbsp;                fileOffset |= ((itemBuffer.get() &amp; 0xff) &lt;&lt; 16);</b>
<b class="fc"><i class="no-highlight">6073</i>&nbsp;                if (fileOffset == THREE_BYTE_NEGATIVE_ONE) {</b>
<b class="nc"><i class="no-highlight">6074</i>&nbsp;                    lsn = DbLsn.NULL_LSN;</b>
<i class="no-highlight">6075</i>&nbsp;                } else {
<b class="fc"><i class="no-highlight">6076</i>&nbsp;                    lsn = DbLsn.makeLsn</b>
<b class="fc"><i class="no-highlight">6077</i>&nbsp;                        (storedBaseFileNumber + fileNumberOffset, fileOffset);</b>
<i class="no-highlight">6078</i>&nbsp;                }
<b class="fc"><i class="no-highlight">6079</i>&nbsp;            } else {</b>
<i class="no-highlight">6080</i>&nbsp;                /* LSNs in long form. */
<b class="fc"><i class="no-highlight">6081</i>&nbsp;                lsn = LogUtils.readLong(itemBuffer);              // LSN</b>
<i class="no-highlight">6082</i>&nbsp;            }
<i class="no-highlight">6083</i>&nbsp;
<b class="fc"><i class="no-highlight">6084</i>&nbsp;            setLsnInternal(i, lsn);</b>
<i class="no-highlight">6085</i>&nbsp;
<b class="fc"><i class="no-highlight">6086</i>&nbsp;            byte entryState = itemBuffer.get();                   // state</b>
<i class="no-highlight">6087</i>&nbsp;
<b class="fc"><i class="no-highlight">6088</i>&nbsp;            if (clearDirtyBits) {</b>
<b class="fc"><i class="no-highlight">6089</i>&nbsp;                entryState &amp;= EntryStates.CLEAR_DIRTY_BIT;</b>
<i class="no-highlight">6090</i>&nbsp;            }
<i class="no-highlight">6091</i>&nbsp;
<i class="no-highlight">6092</i>&nbsp;            /*
<i class="no-highlight">6093</i>&nbsp;             * The MIGRATE_BIT (now the transient OFFHEAP_DIRTY_BIT) was
<i class="no-highlight">6094</i>&nbsp;             * accidentally written in a pre-JE 6 log version.
<i class="no-highlight">6095</i>&nbsp;             */
<b class="fc"><i class="no-highlight">6096</i>&nbsp;            if (entryVersion &lt; 9) {</b>
<b class="nc"><i class="no-highlight">6097</i>&nbsp;                entryState &amp;= EntryStates.CLEAR_TRANSIENT_BITS;</b>
<i class="no-highlight">6098</i>&nbsp;            }
<i class="no-highlight">6099</i>&nbsp;
<i class="no-highlight">6100</i>&nbsp;            /*
<i class="no-highlight">6101</i>&nbsp;             * A NULL_LSN is the remnant of an incomplete insertion and the
<i class="no-highlight">6102</i>&nbsp;             * KnownDeleted flag should be set.  But because of bugs in prior
<i class="no-highlight">6103</i>&nbsp;             * releases, the KnownDeleted flag may not be set.  So set it here.
<i class="no-highlight">6104</i>&nbsp;             * See Tree.insert.  [#13126]
<i class="no-highlight">6105</i>&nbsp;             */
<b class="fc"><i class="no-highlight">6106</i>&nbsp;            if (entryVersion &lt; 9 &amp;&amp; lsn == DbLsn.NULL_LSN) {</b>
<b class="nc"><i class="no-highlight">6107</i>&nbsp;                entryState |= EntryStates.KNOWN_DELETED_BIT;</b>
<i class="no-highlight">6108</i>&nbsp;            }
<i class="no-highlight">6109</i>&nbsp;
<b class="fc"><i class="no-highlight">6110</i>&nbsp;            entryStates[i] = entryState;</b>
<i class="no-highlight">6111</i>&nbsp;
<b class="fc"><i class="no-highlight">6112</i>&nbsp;            if (mayHaveLastLoggedSize &amp;&amp; !isEmbeddedLN(i)) {</b>
<b class="fc"><i class="no-highlight">6113</i>&nbsp;                setLastLoggedSizeUnconditional(</b>
<b class="fc"><i class="no-highlight">6114</i>&nbsp;                    i, LogUtils.readPackedInt(itemBuffer));</b>
<i class="no-highlight">6115</i>&nbsp;            }
<i class="no-highlight">6116</i>&nbsp;
<b class="fc"><i class="no-highlight">6117</i>&nbsp;            if (haveVLSNCache &amp;&amp; isEmbeddedLN(i)) {</b>
<b class="nc"><i class="no-highlight">6118</i>&nbsp;                bin.setCachedVLSNUnconditional(</b>
<b class="nc"><i class="no-highlight">6119</i>&nbsp;                    i, LogUtils.readPackedLong(itemBuffer));</b>
<i class="no-highlight">6120</i>&nbsp;            }
<i class="no-highlight">6121</i>&nbsp;
<b class="fc"><i class="no-highlight">6122</i>&nbsp;            if (haveExpiration) {</b>
<b class="nc"><i class="no-highlight">6123</i>&nbsp;                bin.setExpirationOffset(i, LogUtils.readPackedInt(itemBuffer));</b>
<i class="no-highlight">6124</i>&nbsp;            }
<i class="no-highlight">6125</i>&nbsp;        }
<i class="no-highlight">6126</i>&nbsp;
<b class="fc"><i class="no-highlight">6127</i>&nbsp;        if (deltasOnly) {</b>
<b class="fc"><i class="no-highlight">6128</i>&nbsp;            setBINDelta(true);</b>
<i class="no-highlight">6129</i>&nbsp;
<b class="fc"><i class="no-highlight">6130</i>&nbsp;            if (entryVersion &gt;= 10) {</b>
<b class="fc"><i class="no-highlight">6131</i>&nbsp;                bin.setFullBinNEntries(LogUtils.readPackedInt(itemBuffer));</b>
<b class="fc"><i class="no-highlight">6132</i>&nbsp;                bin.setFullBinMaxEntries(LogUtils.readPackedInt(itemBuffer));</b>
<i class="no-highlight">6133</i>&nbsp;
<b class="fc"><i class="no-highlight">6134</i>&nbsp;                if (hasBloomFilter) {</b>
<b class="fc"><i class="no-highlight">6135</i>&nbsp;                    bin.bloomFilter = BINDeltaBloomFilter.readFromLog(</b>
<i class="no-highlight">6136</i>&nbsp;                        itemBuffer, entryVersion);
<i class="no-highlight">6137</i>&nbsp;                }
<i class="no-highlight">6138</i>&nbsp;            }
<i class="no-highlight">6139</i>&nbsp;        }
<i class="no-highlight">6140</i>&nbsp;
<i class="no-highlight">6141</i>&nbsp;        /* Dup conversion will be done by postFetchInit. */
<b class="fc"><i class="no-highlight">6142</i>&nbsp;        needDupKeyConversion = (entryVersion &lt; 8);</b>
<b class="fc"><i class="no-highlight">6143</i>&nbsp;    }</b>
<i class="no-highlight">6144</i>&nbsp;
<i class="no-highlight">6145</i>&nbsp;    /**
<i class="no-highlight">6146</i>&nbsp;     * @see Loggable#logicalEquals
<i class="no-highlight">6147</i>&nbsp;     * Always return false, this item should never be compared.
<i class="no-highlight">6148</i>&nbsp;     */
<i class="no-highlight">6149</i>&nbsp;    @Override
<i class="no-highlight">6150</i>&nbsp;    public final boolean logicalEquals(Loggable other) {
<b class="nc"><i class="no-highlight">6151</i>&nbsp;        return false;</b>
<i class="no-highlight">6152</i>&nbsp;    }
<i class="no-highlight">6153</i>&nbsp;
<i class="no-highlight">6154</i>&nbsp;    /**
<i class="no-highlight">6155</i>&nbsp;     * @see Loggable#dumpLog
<i class="no-highlight">6156</i>&nbsp;     */
<i class="no-highlight">6157</i>&nbsp;    @Override
<i class="no-highlight">6158</i>&nbsp;    public final void dumpLog(StringBuilder sb, boolean verbose) {
<b class="nc"><i class="no-highlight">6159</i>&nbsp;        sb.append(beginTag());</b>
<i class="no-highlight">6160</i>&nbsp;
<b class="nc"><i class="no-highlight">6161</i>&nbsp;        sb.append(&quot;&lt;nodeId val=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6162</i>&nbsp;        sb.append(nodeId);</b>
<b class="nc"><i class="no-highlight">6163</i>&nbsp;        sb.append(&quot;\&quot;/&gt;&quot;);</b>
<i class="no-highlight">6164</i>&nbsp;
<b class="nc"><i class="no-highlight">6165</i>&nbsp;        sb.append(Key.dumpString(identifierKey, &quot;idKey&quot;, 0));</b>
<i class="no-highlight">6166</i>&nbsp;
<i class="no-highlight">6167</i>&nbsp;        // isRoot
<b class="nc"><i class="no-highlight">6168</i>&nbsp;        sb.append(&quot;&lt;isRoot val=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6169</i>&nbsp;        sb.append(isRoot());</b>
<b class="nc"><i class="no-highlight">6170</i>&nbsp;        sb.append(&quot;\&quot;/&gt;&quot;);</b>
<i class="no-highlight">6171</i>&nbsp;
<i class="no-highlight">6172</i>&nbsp;        // level
<b class="nc"><i class="no-highlight">6173</i>&nbsp;        sb.append(&quot;&lt;level val=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6174</i>&nbsp;        sb.append(Integer.toHexString(level));</b>
<b class="nc"><i class="no-highlight">6175</i>&nbsp;        sb.append(&quot;\&quot;/&gt;&quot;);</b>
<i class="no-highlight">6176</i>&nbsp;
<b class="nc"><i class="no-highlight">6177</i>&nbsp;        if (keyPrefix != null) {</b>
<b class="nc"><i class="no-highlight">6178</i>&nbsp;            sb.append(Key.dumpString(keyPrefix, &quot;keyPrefix&quot;, 0));</b>
<i class="no-highlight">6179</i>&nbsp;        }
<i class="no-highlight">6180</i>&nbsp;
<i class="no-highlight">6181</i>&nbsp;        // nEntries, length of entries array
<b class="nc"><i class="no-highlight">6182</i>&nbsp;        sb.append(&quot;&lt;entries numEntries=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6183</i>&nbsp;        sb.append(nEntries);</b>
<i class="no-highlight">6184</i>&nbsp;
<b class="nc"><i class="no-highlight">6185</i>&nbsp;        sb.append(&quot;\&quot; length=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6186</i>&nbsp;        sb.append(getMaxEntries());</b>
<i class="no-highlight">6187</i>&nbsp;
<b class="nc"><i class="no-highlight">6188</i>&nbsp;        final BIN bin = isBIN() ? (BIN) this : null;</b>
<i class="no-highlight">6189</i>&nbsp;
<b class="nc"><i class="no-highlight">6190</i>&nbsp;        if (isBINDelta(false)) {</b>
<b class="nc"><i class="no-highlight">6191</i>&nbsp;            sb.append(&quot;\&quot; numFullBinEntries=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6192</i>&nbsp;            sb.append(bin.getFullBinNEntries());</b>
<b class="nc"><i class="no-highlight">6193</i>&nbsp;            sb.append(&quot;\&quot; maxFullBinEntries=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6194</i>&nbsp;            sb.append(bin.getFullBinMaxEntries());</b>
<i class="no-highlight">6195</i>&nbsp;        }
<i class="no-highlight">6196</i>&nbsp;
<b class="nc"><i class="no-highlight">6197</i>&nbsp;        boolean compactLsnsRep = (entryLsnLongArray == null);</b>
<b class="nc"><i class="no-highlight">6198</i>&nbsp;        if (compactLsnsRep) {</b>
<b class="nc"><i class="no-highlight">6199</i>&nbsp;            sb.append(&quot;\&quot; baseFileNumber=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6200</i>&nbsp;            sb.append(baseFileNumber);</b>
<i class="no-highlight">6201</i>&nbsp;        }
<b class="nc"><i class="no-highlight">6202</i>&nbsp;        sb.append(&quot;\&quot;&gt;&quot;);</b>
<i class="no-highlight">6203</i>&nbsp;
<b class="nc"><i class="no-highlight">6204</i>&nbsp;        if (verbose) {</b>
<b class="nc"><i class="no-highlight">6205</i>&nbsp;            for (int i = 0; i &lt; nEntries; i++) {</b>
<b class="nc"><i class="no-highlight">6206</i>&nbsp;                sb.append(&quot;&lt;ref&quot;);</b>
<b class="nc"><i class="no-highlight">6207</i>&nbsp;                dumpSlotState(sb, i, bin);</b>
<b class="nc"><i class="no-highlight">6208</i>&nbsp;                sb.append(&quot;&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6209</i>&nbsp;                sb.append(Key.dumpString(getKey(i), 0));</b>
<b class="nc"><i class="no-highlight">6210</i>&nbsp;                if (isEmbeddedLN(i)) {</b>
<b class="nc"><i class="no-highlight">6211</i>&nbsp;                    sb.append(Key.dumpString(getData(i), &quot;data&quot;, 0));</b>
<i class="no-highlight">6212</i>&nbsp;                }
<b class="nc"><i class="no-highlight">6213</i>&nbsp;                sb.append(DbLsn.toString(getLsn(i)));</b>
<b class="nc"><i class="no-highlight">6214</i>&nbsp;                sb.append(&quot;&lt;/ref&gt;&quot;);</b>
<i class="no-highlight">6215</i>&nbsp;            }
<i class="no-highlight">6216</i>&nbsp;        }
<i class="no-highlight">6217</i>&nbsp;
<b class="nc"><i class="no-highlight">6218</i>&nbsp;        sb.append(&quot;&lt;/entries&gt;&quot;);</b>
<i class="no-highlight">6219</i>&nbsp;
<b class="nc"><i class="no-highlight">6220</i>&nbsp;        if (isBINDelta(false)) {</b>
<b class="nc"><i class="no-highlight">6221</i>&nbsp;            if (bin.bloomFilter != null) {</b>
<b class="nc"><i class="no-highlight">6222</i>&nbsp;                BINDeltaBloomFilter.dumpLog(bin.bloomFilter, sb, verbose);</b>
<i class="no-highlight">6223</i>&nbsp;            }
<i class="no-highlight">6224</i>&nbsp;        }
<i class="no-highlight">6225</i>&nbsp;
<i class="no-highlight">6226</i>&nbsp;        /* Add on any additional items from subclasses before the end tag. */
<b class="nc"><i class="no-highlight">6227</i>&nbsp;        dumpLogAdditional(sb);</b>
<i class="no-highlight">6228</i>&nbsp;
<b class="nc"><i class="no-highlight">6229</i>&nbsp;        sb.append(endTag());</b>
<b class="nc"><i class="no-highlight">6230</i>&nbsp;    }</b>
<i class="no-highlight">6231</i>&nbsp;
<i class="no-highlight">6232</i>&nbsp;    /**
<i class="no-highlight">6233</i>&nbsp;     * Allows subclasses to add additional fields before the end tag. If they
<i class="no-highlight">6234</i>&nbsp;     * just overload dumpLog, the xml isn&#39;t nested.
<i class="no-highlight">6235</i>&nbsp;     */
<i class="no-highlight">6236</i>&nbsp;    protected void dumpLogAdditional(StringBuilder sb) {
<b class="nc"><i class="no-highlight">6237</i>&nbsp;    }</b>
<i class="no-highlight">6238</i>&nbsp;
<i class="no-highlight">6239</i>&nbsp;    public String beginTag() {
<b class="nc"><i class="no-highlight">6240</i>&nbsp;        return BEGIN_TAG;</b>
<i class="no-highlight">6241</i>&nbsp;    }
<i class="no-highlight">6242</i>&nbsp;
<i class="no-highlight">6243</i>&nbsp;    public String endTag() {
<b class="nc"><i class="no-highlight">6244</i>&nbsp;        return END_TAG;</b>
<i class="no-highlight">6245</i>&nbsp;    }
<i class="no-highlight">6246</i>&nbsp;
<i class="no-highlight">6247</i>&nbsp;    /**
<i class="no-highlight">6248</i>&nbsp;     * For unit test support:
<i class="no-highlight">6249</i>&nbsp;     * @return a string that dumps information about this IN, without
<i class="no-highlight">6250</i>&nbsp;     */
<i class="no-highlight">6251</i>&nbsp;    @Override
<i class="no-highlight">6252</i>&nbsp;    public String dumpString(int nSpaces, boolean dumpTags) {
<b class="nc"><i class="no-highlight">6253</i>&nbsp;        StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i class="no-highlight">6254</i>&nbsp;        if (dumpTags) {</b>
<b class="nc"><i class="no-highlight">6255</i>&nbsp;            sb.append(TreeUtils.indent(nSpaces));</b>
<b class="nc"><i class="no-highlight">6256</i>&nbsp;            sb.append(beginTag());</b>
<b class="nc"><i class="no-highlight">6257</i>&nbsp;            sb.append(&#39;\n&#39;);</b>
<i class="no-highlight">6258</i>&nbsp;        }
<i class="no-highlight">6259</i>&nbsp;
<b class="nc"><i class="no-highlight">6260</i>&nbsp;        if (dumpTags) {</b>
<b class="nc"><i class="no-highlight">6261</i>&nbsp;            sb.append(TreeUtils.indent(nSpaces));</b>
<b class="nc"><i class="no-highlight">6262</i>&nbsp;            sb.append(&quot;&lt;nodeId val=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6263</i>&nbsp;            sb.append(nodeId);</b>
<b class="nc"><i class="no-highlight">6264</i>&nbsp;            sb.append(&quot;\&quot;/&gt;&quot;);</b>
<i class="no-highlight">6265</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">6266</i>&nbsp;            sb.append(nodeId);</b>
<i class="no-highlight">6267</i>&nbsp;        }
<b class="nc"><i class="no-highlight">6268</i>&nbsp;        sb.append(&#39;\n&#39;);</b>
<i class="no-highlight">6269</i>&nbsp;
<b class="nc"><i class="no-highlight">6270</i>&nbsp;        BIN bin = null;</b>
<b class="nc"><i class="no-highlight">6271</i>&nbsp;        if (isBIN()) {</b>
<b class="nc"><i class="no-highlight">6272</i>&nbsp;            bin = (BIN) this;</b>
<i class="no-highlight">6273</i>&nbsp;        }
<i class="no-highlight">6274</i>&nbsp;
<b class="nc"><i class="no-highlight">6275</i>&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6276</i>&nbsp;        sb.append(&quot;&lt;idkey&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6277</i>&nbsp;        sb.append(identifierKey == null ?</b>
<i class="no-highlight">6278</i>&nbsp;                  &quot;&quot; :
<b class="nc"><i class="no-highlight">6279</i>&nbsp;                  Key.dumpString(identifierKey, 0));</b>
<b class="nc"><i class="no-highlight">6280</i>&nbsp;        sb.append(&quot;&lt;/idkey&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6281</i>&nbsp;        sb.append(&#39;\n&#39;);</b>
<b class="nc"><i class="no-highlight">6282</i>&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6283</i>&nbsp;        sb.append(&quot;&lt;prefix&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6284</i>&nbsp;        sb.append(keyPrefix == null ? &quot;&quot; : Key.dumpString(keyPrefix, 0));</b>
<b class="nc"><i class="no-highlight">6285</i>&nbsp;        sb.append(&quot;&lt;/prefix&gt;\n&quot;);</b>
<b class="nc"><i class="no-highlight">6286</i>&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6287</i>&nbsp;        sb.append(&quot;&lt;dirty val=\&quot;&quot;).append(getDirty()).append(&quot;\&quot;/&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6288</i>&nbsp;        sb.append(&#39;\n&#39;);</b>
<b class="nc"><i class="no-highlight">6289</i>&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6290</i>&nbsp;        sb.append(&quot;&lt;level val=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6291</i>&nbsp;        sb.append(Integer.toHexString(level)).append(&quot;\&quot;/&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6292</i>&nbsp;        sb.append(&#39;\n&#39;);</b>
<b class="nc"><i class="no-highlight">6293</i>&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6294</i>&nbsp;        sb.append(&quot;&lt;isRoot val=\&quot;&quot;).append(isRoot()).append(&quot;\&quot;/&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6295</i>&nbsp;        sb.append(&#39;\n&#39;);</b>
<b class="nc"><i class="no-highlight">6296</i>&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6297</i>&nbsp;        sb.append(&quot;&lt;isBINDelta val=\&quot;&quot;).append(isBINDelta(false)).append(&quot;\&quot;/&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6298</i>&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6299</i>&nbsp;        sb.append(</b>
<i class="no-highlight">6300</i>&nbsp;            &quot;&lt;prohibitNextDelta val=\&quot;&quot;).
<b class="nc"><i class="no-highlight">6301</i>&nbsp;            append(getProhibitNextDelta()).append(&quot;\&quot;/&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6302</i>&nbsp;        if (bin != null) {</b>
<b class="nc"><i class="no-highlight">6303</i>&nbsp;            sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6304</i>&nbsp;            sb.append(&quot;&lt;cursors val=\&quot;&quot;).append(bin.nCursors()).append(&quot;\&quot;/&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6305</i>&nbsp;            sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6306</i>&nbsp;            sb.append(&quot;&lt;deltas val=\&quot;&quot;).append(bin.getNDeltas()).append(&quot;\&quot;/&gt;&quot;);</b>
<i class="no-highlight">6307</i>&nbsp;        }
<b class="nc"><i class="no-highlight">6308</i>&nbsp;        sb.append(&#39;\n&#39;);</b>
<i class="no-highlight">6309</i>&nbsp;
<b class="nc"><i class="no-highlight">6310</i>&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6311</i>&nbsp;        sb.append(&quot;&lt;entries nEntries=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6312</i>&nbsp;        sb.append(nEntries);</b>
<b class="nc"><i class="no-highlight">6313</i>&nbsp;        sb.append(&quot;\&quot;&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6314</i>&nbsp;        sb.append(&#39;\n&#39;);</b>
<i class="no-highlight">6315</i>&nbsp;
<b class="nc"><i class="no-highlight">6316</i>&nbsp;        for (int i = 0; i &lt; nEntries; i++) {</b>
<b class="nc"><i class="no-highlight">6317</i>&nbsp;            sb.append(TreeUtils.indent(nSpaces + 4));</b>
<b class="nc"><i class="no-highlight">6318</i>&nbsp;            sb.append(&quot;&lt;entry id=\&quot;&quot;).append(i).append(&quot;\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6319</i>&nbsp;            dumpSlotState(sb, i, bin);</b>
<b class="nc"><i class="no-highlight">6320</i>&nbsp;            sb.append(&quot;&gt;\n&quot;);</b>
<b class="nc"><i class="no-highlight">6321</i>&nbsp;            if (getLsn(i) == DbLsn.NULL_LSN) {</b>
<b class="nc"><i class="no-highlight">6322</i>&nbsp;                sb.append(TreeUtils.indent(nSpaces + 6));</b>
<b class="nc"><i class="no-highlight">6323</i>&nbsp;                sb.append(&quot;&lt;lsn/&gt;&quot;);</b>
<i class="no-highlight">6324</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">6325</i>&nbsp;                sb.append(DbLsn.dumpString(getLsn(i), nSpaces + 6));</b>
<i class="no-highlight">6326</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6327</i>&nbsp;            sb.append(&#39;\n&#39;);</b>
<b class="nc"><i class="no-highlight">6328</i>&nbsp;            if (entryKeys.get(i) == null) {</b>
<b class="nc"><i class="no-highlight">6329</i>&nbsp;                sb.append(TreeUtils.indent(nSpaces + 6));</b>
<b class="nc"><i class="no-highlight">6330</i>&nbsp;                sb.append(&quot;&lt;key/&gt;&quot;);</b>
<i class="no-highlight">6331</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">6332</i>&nbsp;                sb.append(Key.dumpString(entryKeys.get(i), (nSpaces + 6)));</b>
<i class="no-highlight">6333</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6334</i>&nbsp;            sb.append(&#39;\n&#39;);</b>
<b class="nc"><i class="no-highlight">6335</i>&nbsp;            if (getOffHeapBINId(i) &gt;= 0) {</b>
<b class="nc"><i class="no-highlight">6336</i>&nbsp;                sb.append(&quot;&lt;ohBIN id=\&quot;&quot;).append(i).append(&quot;\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6337</i>&nbsp;                sb.append(getOffHeapBINId(i)).append(&quot;&gt;\n&quot;);</b>
<i class="no-highlight">6338</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6339</i>&nbsp;            if (bin != null &amp;&amp; bin.getOffHeapLNId(i) != 0) {</b>
<b class="nc"><i class="no-highlight">6340</i>&nbsp;                sb.append(&quot;&lt;ohLN id=\&quot;&quot;).append(i).append(&quot;\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6341</i>&nbsp;                sb.append(bin.getOffHeapLNId(i)).append(&quot;&gt;\n&quot;);</b>
<i class="no-highlight">6342</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6343</i>&nbsp;            if (entryTargets.get(i) == null) {</b>
<b class="nc"><i class="no-highlight">6344</i>&nbsp;                sb.append(TreeUtils.indent(nSpaces + 6));</b>
<b class="nc"><i class="no-highlight">6345</i>&nbsp;                sb.append(&quot;&lt;target/&gt;&quot;);</b>
<i class="no-highlight">6346</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">6347</i>&nbsp;                sb.append(entryTargets.get(i).dumpString(nSpaces + 6, true));</b>
<i class="no-highlight">6348</i>&nbsp;            }
<b class="nc"><i class="no-highlight">6349</i>&nbsp;            sb.append(&#39;\n&#39;);</b>
<b class="nc"><i class="no-highlight">6350</i>&nbsp;            sb.append(TreeUtils.indent(nSpaces + 4));</b>
<b class="nc"><i class="no-highlight">6351</i>&nbsp;            sb.append(&quot;&lt;/entry&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6352</i>&nbsp;            sb.append(&#39;\n&#39;);</b>
<i class="no-highlight">6353</i>&nbsp;        }
<i class="no-highlight">6354</i>&nbsp;
<b class="nc"><i class="no-highlight">6355</i>&nbsp;        sb.append(TreeUtils.indent(nSpaces + 2));</b>
<b class="nc"><i class="no-highlight">6356</i>&nbsp;        sb.append(&quot;&lt;/entries&gt;&quot;);</b>
<b class="nc"><i class="no-highlight">6357</i>&nbsp;        sb.append(&#39;\n&#39;);</b>
<b class="nc"><i class="no-highlight">6358</i>&nbsp;        if (dumpTags) {</b>
<b class="nc"><i class="no-highlight">6359</i>&nbsp;            sb.append(TreeUtils.indent(nSpaces));</b>
<b class="nc"><i class="no-highlight">6360</i>&nbsp;            sb.append(endTag());</b>
<i class="no-highlight">6361</i>&nbsp;        }
<b class="nc"><i class="no-highlight">6362</i>&nbsp;        return sb.toString();</b>
<i class="no-highlight">6363</i>&nbsp;    }
<i class="no-highlight">6364</i>&nbsp;
<i class="no-highlight">6365</i>&nbsp;    private void dumpSlotState(StringBuilder sb, int i, BIN bin) {
<b class="nc"><i class="no-highlight">6366</i>&nbsp;        sb.append(&quot; kd=\&quot;&quot;).append(isEntryKnownDeleted(i));</b>
<b class="nc"><i class="no-highlight">6367</i>&nbsp;        sb.append(&quot;\&quot; pd=\&quot;&quot;).append(isEntryPendingDeleted(i));</b>
<b class="nc"><i class="no-highlight">6368</i>&nbsp;        sb.append(&quot;\&quot; dirty=\&quot;&quot;).append(isDirty(i));</b>
<b class="nc"><i class="no-highlight">6369</i>&nbsp;        sb.append(&quot;\&quot; embedded=\&quot;&quot;).append(isEmbeddedLN(i));</b>
<b class="nc"><i class="no-highlight">6370</i>&nbsp;        sb.append(&quot;\&quot; noData=\&quot;&quot;).append(isNoDataLN(i));</b>
<b class="nc"><i class="no-highlight">6371</i>&nbsp;        if (bin != null) {</b>
<b class="nc"><i class="no-highlight">6372</i>&nbsp;            sb.append(&quot;\&quot; logSize=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6373</i>&nbsp;            sb.append(bin.getLastLoggedSizeUnconditional(i));</b>
<b class="nc"><i class="no-highlight">6374</i>&nbsp;            long vlsn = bin.getCachedVLSN(i);</b>
<b class="nc"><i class="no-highlight">6375</i>&nbsp;            if (!VLSN.isNull(vlsn)) {</b>
<b class="nc"><i class="no-highlight">6376</i>&nbsp;                sb.append(&quot;\&quot; vlsn=\&quot;&quot;).append(vlsn);</b>
<i class="no-highlight">6377</i>&nbsp;            }
<i class="no-highlight">6378</i>&nbsp;        }
<b class="nc"><i class="no-highlight">6379</i>&nbsp;        if (bin != null &amp;&amp; bin.getExpiration(i) != 0) {</b>
<b class="nc"><i class="no-highlight">6380</i>&nbsp;            sb.append(&quot;\&quot; expires=\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6381</i>&nbsp;            sb.append(TTL.formatExpiration(</b>
<b class="nc"><i class="no-highlight">6382</i>&nbsp;                bin.getExpiration(i), bin.isExpirationInHours()));</b>
<i class="no-highlight">6383</i>&nbsp;        }
<b class="nc"><i class="no-highlight">6384</i>&nbsp;        sb.append(&quot;\&quot;&quot;);</b>
<b class="nc"><i class="no-highlight">6385</i>&nbsp;    }</b>
<i class="no-highlight">6386</i>&nbsp;
<i class="no-highlight">6387</i>&nbsp;    /**
<i class="no-highlight">6388</i>&nbsp;     * Converts to an identifying string that is safe to output in a log.
<i class="no-highlight">6389</i>&nbsp;     * Keys are not included for security/privacy reasons.
<i class="no-highlight">6390</i>&nbsp;     */
<i class="no-highlight">6391</i>&nbsp;    public String toSafeString(final int... slotIndexes) {
<i class="no-highlight">6392</i>&nbsp;
<b class="nc"><i class="no-highlight">6393</i>&nbsp;        final BIN bin = isBIN() ? (BIN) this : null;</b>
<b class="nc"><i class="no-highlight">6394</i>&nbsp;        final StringBuilder sb = new StringBuilder();</b>
<i class="no-highlight">6395</i>&nbsp;
<b class="nc"><i class="no-highlight">6396</i>&nbsp;        sb.append(&quot;IN nodeId=&quot;).append(getNodeId());</b>
<b class="nc"><i class="no-highlight">6397</i>&nbsp;        sb.append(&quot; lastLoggedLSN=&quot;);</b>
<b class="nc"><i class="no-highlight">6398</i>&nbsp;        sb.append(DbLsn.getNoFormatString(getLastLoggedLsn()));</b>
<b class="nc"><i class="no-highlight">6399</i>&nbsp;        sb.append(&quot; lastFulLSN=&quot;);</b>
<b class="nc"><i class="no-highlight">6400</i>&nbsp;        sb.append(DbLsn.getNoFormatString(getLastFullLsn()));</b>
<b class="nc"><i class="no-highlight">6401</i>&nbsp;        sb.append(&quot; level=&quot;).append(Integer.toHexString(getLevel()));</b>
<b class="nc"><i class="no-highlight">6402</i>&nbsp;        sb.append(&quot; flags=&quot;).append(Integer.toHexString(flags));</b>
<b class="nc"><i class="no-highlight">6403</i>&nbsp;        sb.append(&quot; isBINDelta=&quot;).append(isBINDelta());</b>
<b class="nc"><i class="no-highlight">6404</i>&nbsp;        sb.append(&quot; nSlots=&quot;).append(getNEntries());</b>
<i class="no-highlight">6405</i>&nbsp;
<b class="nc"><i class="no-highlight">6406</i>&nbsp;        if (slotIndexes != null) {</b>
<b class="nc"><i class="no-highlight">6407</i>&nbsp;            for (final int i : slotIndexes) {</b>
<b class="nc"><i class="no-highlight">6408</i>&nbsp;                sb.append(&quot; slot-&quot;).append(i).append(&quot;:[&quot;);</b>
<b class="nc"><i class="no-highlight">6409</i>&nbsp;                sb.append(&quot;lsn=&quot;);</b>
<b class="nc"><i class="no-highlight">6410</i>&nbsp;                sb.append(DbLsn.getNoFormatString(getLsn(i)));</b>
<b class="nc"><i class="no-highlight">6411</i>&nbsp;                sb.append(&quot; offset=&quot;);</b>
<b class="nc"><i class="no-highlight">6412</i>&nbsp;                sb.append(DbLsn.getFileOffset(getLsn(i)));</b>
<b class="nc"><i class="no-highlight">6413</i>&nbsp;                if (bin != null) {</b>
<b class="nc"><i class="no-highlight">6414</i>&nbsp;                    sb.append(&quot; offset+logSize=&quot;);</b>
<b class="nc"><i class="no-highlight">6415</i>&nbsp;                    sb.append(DbLsn.getFileOffset(getLsn(i)) +</b>
<b class="nc"><i class="no-highlight">6416</i>&nbsp;                        bin.getLastLoggedSizeUnconditional(i));</b>
<i class="no-highlight">6417</i>&nbsp;                }
<b class="nc"><i class="no-highlight">6418</i>&nbsp;                dumpSlotState(sb, i, bin);</b>
<b class="nc"><i class="no-highlight">6419</i>&nbsp;                sb.append(&quot;]&quot;);</b>
<i class="no-highlight">6420</i>&nbsp;            }
<i class="no-highlight">6421</i>&nbsp;        }
<i class="no-highlight">6422</i>&nbsp;
<b class="nc"><i class="no-highlight">6423</i>&nbsp;        return sb.toString();</b>
<i class="no-highlight">6424</i>&nbsp;    }
<i class="no-highlight">6425</i>&nbsp;
<i class="no-highlight">6426</i>&nbsp;    @Override
<i class="no-highlight">6427</i>&nbsp;    public String toString() {
<b class="nc"><i class="no-highlight">6428</i>&nbsp;        return dumpString(0, true);</b>
<i class="no-highlight">6429</i>&nbsp;    }
<i class="no-highlight">6430</i>&nbsp;
<i class="no-highlight">6431</i>&nbsp;    public String shortClassName() {
<b class="nc"><i class="no-highlight">6432</i>&nbsp;        return &quot;IN&quot;;</b>
<i class="no-highlight">6433</i>&nbsp;    }
<i class="no-highlight">6434</i>&nbsp;
<i class="no-highlight">6435</i>&nbsp;    /**
<i class="no-highlight">6436</i>&nbsp;     * Send trace messages to the java.util.logger. Don&#39;t rely on the logger
<i class="no-highlight">6437</i>&nbsp;     * alone to conditionalize whether we send this message, we don&#39;t even want
<i class="no-highlight">6438</i>&nbsp;     * to construct the message if the level is not enabled.
<i class="no-highlight">6439</i>&nbsp;     */
<i class="no-highlight">6440</i>&nbsp;    private void traceSplit(Level level,
<i class="no-highlight">6441</i>&nbsp;                            IN parent,
<i class="no-highlight">6442</i>&nbsp;                            IN newSibling,
<i class="no-highlight">6443</i>&nbsp;                            long parentLsn,
<i class="no-highlight">6444</i>&nbsp;                            long myNewLsn,
<i class="no-highlight">6445</i>&nbsp;                            long newSiblingLsn,
<i class="no-highlight">6446</i>&nbsp;                            int splitIndex,
<i class="no-highlight">6447</i>&nbsp;                            int idKeyIndex,
<i class="no-highlight">6448</i>&nbsp;                            int childIndex) {
<b class="fc"><i class="no-highlight">6449</i>&nbsp;        Logger logger = getEnv().getLogger();</b>
<b class="fc"><i class="no-highlight">6450</i>&nbsp;        if (logger.isLoggable(level)) {</b>
<b class="nc"><i class="no-highlight">6451</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i class="no-highlight">6452</i>&nbsp;            sb.append(TRACE_SPLIT);</b>
<b class="nc"><i class="no-highlight">6453</i>&nbsp;            sb.append(&quot; parent=&quot;);</b>
<b class="nc"><i class="no-highlight">6454</i>&nbsp;            sb.append(parent.getNodeId());</b>
<b class="nc"><i class="no-highlight">6455</i>&nbsp;            sb.append(&quot; child=&quot;);</b>
<b class="nc"><i class="no-highlight">6456</i>&nbsp;            sb.append(getNodeId());</b>
<b class="nc"><i class="no-highlight">6457</i>&nbsp;            sb.append(&quot; newSibling=&quot;);</b>
<b class="nc"><i class="no-highlight">6458</i>&nbsp;            sb.append(newSibling.getNodeId());</b>
<b class="nc"><i class="no-highlight">6459</i>&nbsp;            sb.append(&quot; parentLsn = &quot;);</b>
<b class="nc"><i class="no-highlight">6460</i>&nbsp;            sb.append(DbLsn.getNoFormatString(parentLsn));</b>
<b class="nc"><i class="no-highlight">6461</i>&nbsp;            sb.append(&quot; childLsn = &quot;);</b>
<b class="nc"><i class="no-highlight">6462</i>&nbsp;            sb.append(DbLsn.getNoFormatString(myNewLsn));</b>
<b class="nc"><i class="no-highlight">6463</i>&nbsp;            sb.append(&quot; newSiblingLsn = &quot;);</b>
<b class="nc"><i class="no-highlight">6464</i>&nbsp;            sb.append(DbLsn.getNoFormatString(newSiblingLsn));</b>
<b class="nc"><i class="no-highlight">6465</i>&nbsp;            sb.append(&quot; splitIdx=&quot;);</b>
<b class="nc"><i class="no-highlight">6466</i>&nbsp;            sb.append(splitIndex);</b>
<b class="nc"><i class="no-highlight">6467</i>&nbsp;            sb.append(&quot; idKeyIdx=&quot;);</b>
<b class="nc"><i class="no-highlight">6468</i>&nbsp;            sb.append(idKeyIndex);</b>
<b class="nc"><i class="no-highlight">6469</i>&nbsp;            sb.append(&quot; childIdx=&quot;);</b>
<b class="nc"><i class="no-highlight">6470</i>&nbsp;            sb.append(childIndex);</b>
<b class="nc"><i class="no-highlight">6471</i>&nbsp;            LoggerUtils.logMsg(logger,</b>
<b class="nc"><i class="no-highlight">6472</i>&nbsp;                               databaseImpl.getEnv(),</b>
<i class="no-highlight">6473</i>&nbsp;                               level,
<b class="nc"><i class="no-highlight">6474</i>&nbsp;                               sb.toString());</b>
<i class="no-highlight">6475</i>&nbsp;        }
<b class="fc"><i class="no-highlight">6476</i>&nbsp;    }</b>
<i class="no-highlight">6477</i>&nbsp;
<i class="no-highlight">6478</i>&nbsp;    /**
<i class="no-highlight">6479</i>&nbsp;     * Send trace messages to the java.util.logger. Don&#39;t rely on the logger
<i class="no-highlight">6480</i>&nbsp;     * alone to conditionalize whether we send this message, we don&#39;t even want
<i class="no-highlight">6481</i>&nbsp;     * to construct the message if the level is not enabled.
<i class="no-highlight">6482</i>&nbsp;     */
<i class="no-highlight">6483</i>&nbsp;    private void traceDelete(Level level, int index) {
<b class="nc"><i class="no-highlight">6484</i>&nbsp;        Logger logger = databaseImpl.getEnv().getLogger();</b>
<b class="nc"><i class="no-highlight">6485</i>&nbsp;        if (logger.isLoggable(level)) {</b>
<b class="nc"><i class="no-highlight">6486</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i class="no-highlight">6487</i>&nbsp;            sb.append(TRACE_DELETE);</b>
<b class="nc"><i class="no-highlight">6488</i>&nbsp;            sb.append(&quot; in=&quot;).append(getNodeId());</b>
<b class="nc"><i class="no-highlight">6489</i>&nbsp;            sb.append(&quot; index=&quot;);</b>
<b class="nc"><i class="no-highlight">6490</i>&nbsp;            sb.append(index);</b>
<b class="nc"><i class="no-highlight">6491</i>&nbsp;            LoggerUtils.logMsg(logger,</b>
<b class="nc"><i class="no-highlight">6492</i>&nbsp;                               databaseImpl.getEnv(),</b>
<i class="no-highlight">6493</i>&nbsp;                               level,
<b class="nc"><i class="no-highlight">6494</i>&nbsp;                               sb.toString());</b>
<i class="no-highlight">6495</i>&nbsp;        }
<b class="nc"><i class="no-highlight">6496</i>&nbsp;    }</b>
<i class="no-highlight">6497</i>&nbsp;
<i class="no-highlight">6498</i>&nbsp;    public final void setFetchINHook(TestHook hook) {
<b class="nc"><i class="no-highlight">6499</i>&nbsp;        fetchINHook = hook;</b>
<b class="nc"><i class="no-highlight">6500</i>&nbsp;    }</b>
<i class="no-highlight">6501</i>&nbsp;}
</div>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
        var codeBlock = document.getElementById('sourceCode');

        if (codeBlock) {
            hljs.highlightBlock(codeBlock);
        }
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2021-04-19 13:44</div>
</div>
</body>
</html>
