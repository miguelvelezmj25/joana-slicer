


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > FileManager</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
    @import "../../.css/highlight-idea.css";
  </style>
  <script type="text/javascript" src="../../.js/highlight.pack.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.sleepycat.je.log</a>
</div>

<h1>Coverage Summary for Class: FileManager (com.sleepycat.je.log)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FileManager</td>
<td class="coverageStat">
  <span class="percent">
    48.4%
  </span>
  <span class="absValue">
    (44/91)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    39.6%
  </span>
  <span class="absValue">
    (346/874)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FileManager$1</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileManager$2</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileManager$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileManager$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileManager$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileManager$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileManager$DefaultRandomAccessFile</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileManager$FileCache</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    47.1%
  </span>
  <span class="absValue">
    (24/51)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileManager$FileFactory</td>
  </tr>
  <tr>
    <td class="name">FileManager$FileMode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FileManager$LogEndFileDescriptor</td>
<td class="coverageStat">
  <span class="percent">
    54.5%
  </span>
  <span class="absValue">
    (6/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.1%
  </span>
  <span class="absValue">
    (69/153)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    51.9%
  </span>
  <span class="absValue">
    (68/131)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.1%
  </span>
  <span class="absValue">
    (460/1118)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<div class="sourceCode" id="sourceCode"><i class="no-highlight">1</i>&nbsp;/*-
<i class="no-highlight">2</i>&nbsp; * Copyright (C) 2002, 2017, Oracle and/or its affiliates. All rights reserved.
<i class="no-highlight">3</i>&nbsp; *
<i class="no-highlight">4</i>&nbsp; * This file was distributed by Oracle as part of a version of Oracle Berkeley
<i class="no-highlight">5</i>&nbsp; * DB Java Edition made available at:
<i class="no-highlight">6</i>&nbsp; *
<i class="no-highlight">7</i>&nbsp; * http://www.oracle.com/technetwork/database/database-technologies/berkeleydb/downloads/index.html
<i class="no-highlight">8</i>&nbsp; *
<i class="no-highlight">9</i>&nbsp; * Please see the LICENSE file included in the top-level directory of the
<i class="no-highlight">10</i>&nbsp; * appropriate version of Oracle Berkeley DB Java Edition for a copy of the
<i class="no-highlight">11</i>&nbsp; * license and additional information.
<i class="no-highlight">12</i>&nbsp; */
<i class="no-highlight">13</i>&nbsp;
<i class="no-highlight">14</i>&nbsp;package com.sleepycat.je.log;
<i class="no-highlight">15</i>&nbsp;
<i class="no-highlight">16</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_BYTES_READ_FROM_WRITEQUEUE;
<i class="no-highlight">17</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_BYTES_WRITTEN_FROM_WRITEQUEUE;
<i class="no-highlight">18</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_FILE_OPENS;
<i class="no-highlight">19</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_LOG_FSYNCS;
<i class="no-highlight">20</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_OPEN_FILES;
<i class="no-highlight">21</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_RANDOM_READS;
<i class="no-highlight">22</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_RANDOM_READ_BYTES;
<i class="no-highlight">23</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_RANDOM_WRITES;
<i class="no-highlight">24</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_RANDOM_WRITE_BYTES;
<i class="no-highlight">25</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_READS_FROM_WRITEQUEUE;
<i class="no-highlight">26</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_SEQUENTIAL_READS;
<i class="no-highlight">27</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_SEQUENTIAL_READ_BYTES;
<i class="no-highlight">28</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_SEQUENTIAL_WRITES;
<i class="no-highlight">29</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_SEQUENTIAL_WRITE_BYTES;
<i class="no-highlight">30</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_WRITEQUEUE_OVERFLOW;
<i class="no-highlight">31</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_WRITEQUEUE_OVERFLOW_FAILURES;
<i class="no-highlight">32</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.FILEMGR_WRITES_FROM_WRITEQUEUE;
<i class="no-highlight">33</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.GRPCMGR_FSYNC_MAX_TIME;
<i class="no-highlight">34</i>&nbsp;import static com.sleepycat.je.log.LogStatDefinition.GRPCMGR_FSYNC_TIME;
<i class="no-highlight">35</i>&nbsp;
<i class="no-highlight">36</i>&nbsp;import java.io.File;
<i class="no-highlight">37</i>&nbsp;import java.io.FileNotFoundException;
<i class="no-highlight">38</i>&nbsp;import java.io.FilenameFilter;
<i class="no-highlight">39</i>&nbsp;import java.io.IOException;
<i class="no-highlight">40</i>&nbsp;import java.io.RandomAccessFile;
<i class="no-highlight">41</i>&nbsp;import java.nio.ByteBuffer;
<i class="no-highlight">42</i>&nbsp;import java.nio.channels.ClosedChannelException;
<i class="no-highlight">43</i>&nbsp;import java.nio.channels.FileChannel;
<i class="no-highlight">44</i>&nbsp;import java.nio.channels.FileLock;
<i class="no-highlight">45</i>&nbsp;import java.nio.channels.OverlappingFileLockException;
<i class="no-highlight">46</i>&nbsp;import java.util.ArrayList;
<i class="no-highlight">47</i>&nbsp;import java.util.Arrays;
<i class="no-highlight">48</i>&nbsp;import java.util.Collections;
<i class="no-highlight">49</i>&nbsp;import java.util.Comparator;
<i class="no-highlight">50</i>&nbsp;import java.util.HashMap;
<i class="no-highlight">51</i>&nbsp;import java.util.Hashtable;
<i class="no-highlight">52</i>&nbsp;import java.util.Iterator;
<i class="no-highlight">53</i>&nbsp;import java.util.LinkedList;
<i class="no-highlight">54</i>&nbsp;import java.util.List;
<i class="no-highlight">55</i>&nbsp;import java.util.Map;
<i class="no-highlight">56</i>&nbsp;import java.util.Random;
<i class="no-highlight">57</i>&nbsp;import java.util.Set;
<i class="no-highlight">58</i>&nbsp;import java.util.concurrent.atomic.AtomicLong;
<i class="no-highlight">59</i>&nbsp;import java.util.concurrent.locks.ReentrantLock;
<i class="no-highlight">60</i>&nbsp;
<i class="no-highlight">61</i>&nbsp;import com.sleepycat.je.DatabaseException;
<i class="no-highlight">62</i>&nbsp;import com.sleepycat.je.EnvironmentFailureException;
<i class="no-highlight">63</i>&nbsp;import com.sleepycat.je.EnvironmentLockedException;
<i class="no-highlight">64</i>&nbsp;import com.sleepycat.je.LogWriteException;
<i class="no-highlight">65</i>&nbsp;import com.sleepycat.je.StatsConfig;
<i class="no-highlight">66</i>&nbsp;import com.sleepycat.je.ThreadInterruptedException;
<i class="no-highlight">67</i>&nbsp;import com.sleepycat.je.config.EnvironmentParams;
<i class="no-highlight">68</i>&nbsp;import com.sleepycat.je.dbi.DbConfigManager;
<i class="no-highlight">69</i>&nbsp;import com.sleepycat.je.dbi.EnvironmentFailureReason;
<i class="no-highlight">70</i>&nbsp;import com.sleepycat.je.dbi.EnvironmentImpl;
<i class="no-highlight">71</i>&nbsp;import com.sleepycat.je.log.entry.FileHeaderEntry;
<i class="no-highlight">72</i>&nbsp;import com.sleepycat.je.log.entry.LogEntry;
<i class="no-highlight">73</i>&nbsp;import com.sleepycat.je.utilint.DbLsn;
<i class="no-highlight">74</i>&nbsp;import com.sleepycat.je.utilint.HexFormatter;
<i class="no-highlight">75</i>&nbsp;import com.sleepycat.je.utilint.IntStat;
<i class="no-highlight">76</i>&nbsp;import com.sleepycat.je.utilint.LoggerUtils;
<i class="no-highlight">77</i>&nbsp;import com.sleepycat.je.utilint.LongMaxZeroStat;
<i class="no-highlight">78</i>&nbsp;import com.sleepycat.je.utilint.LongStat;
<i class="no-highlight">79</i>&nbsp;import com.sleepycat.je.utilint.RelatchRequiredException;
<i class="no-highlight">80</i>&nbsp;import com.sleepycat.je.utilint.StatGroup;
<i class="no-highlight">81</i>&nbsp;
<i class="no-highlight">82</i>&nbsp;/**
<i class="no-highlight">83</i>&nbsp; * The FileManager presents the abstraction of one contiguous file.  It doles
<i class="no-highlight">84</i>&nbsp; * out LSNs.
<i class="no-highlight">85</i>&nbsp; */
<b class="fc"><i class="no-highlight">86</i>&nbsp;public class FileManager {</b>
<b class="fc"><i class="no-highlight">87</i>&nbsp;    public static AtomicLong COUNT_READ = new AtomicLong(0);</b>
<b class="fc"><i class="no-highlight">88</i>&nbsp;    public static AtomicLong COUNT_WRITE = new AtomicLong(0);</b>
<b class="fc"><i class="no-highlight">89</i>&nbsp;    public static AtomicLong COUNT_FORCE = new AtomicLong(0);</b>
<i class="no-highlight">90</i>&nbsp;
<b class="fc"><i class="no-highlight">91</i>&nbsp;    public enum FileMode {</b>
<b class="fc"><i class="no-highlight">92</i>&nbsp;        READ_MODE(&quot;r&quot;, false),</b>
<b class="fc"><i class="no-highlight">93</i>&nbsp;        READWRITE_MODE(&quot;rw&quot;, true),</b>
<b class="fc"><i class="no-highlight">94</i>&nbsp;        READWRITE_ODSYNC_MODE(&quot;rwd&quot;, true),</b>
<b class="fc"><i class="no-highlight">95</i>&nbsp;        READWRITE_OSYNC_MODE(&quot;rws&quot;, true);</b>
<i class="no-highlight">96</i>&nbsp;
<i class="no-highlight">97</i>&nbsp;        private String fileModeValue;
<i class="no-highlight">98</i>&nbsp;        private boolean isWritable;
<i class="no-highlight">99</i>&nbsp;
<b class="fc"><i class="no-highlight">100</i>&nbsp;        private FileMode(String fileModeValue, boolean isWritable) {</b>
<b class="fc"><i class="no-highlight">101</i>&nbsp;            this.fileModeValue = fileModeValue;</b>
<b class="fc"><i class="no-highlight">102</i>&nbsp;            this.isWritable = isWritable;</b>
<b class="fc"><i class="no-highlight">103</i>&nbsp;        }</b>
<i class="no-highlight">104</i>&nbsp;
<i class="no-highlight">105</i>&nbsp;        public String getModeValue() {
<b class="fc"><i class="no-highlight">106</i>&nbsp;            return fileModeValue;</b>
<i class="no-highlight">107</i>&nbsp;        }
<i class="no-highlight">108</i>&nbsp;
<i class="no-highlight">109</i>&nbsp;        public boolean isWritable() {
<b class="fc"><i class="no-highlight">110</i>&nbsp;            return isWritable;</b>
<i class="no-highlight">111</i>&nbsp;        }
<i class="no-highlight">112</i>&nbsp;    }
<i class="no-highlight">113</i>&nbsp;
<i class="no-highlight">114</i>&nbsp;    private static final boolean DEBUG = false;
<i class="no-highlight">115</i>&nbsp;
<i class="no-highlight">116</i>&nbsp;    /*
<i class="no-highlight">117</i>&nbsp;     * The number of writes that have been performed.
<i class="no-highlight">118</i>&nbsp;     *
<i class="no-highlight">119</i>&nbsp;     * public so that unit tests can diddle them.
<i class="no-highlight">120</i>&nbsp;     */
<b class="fc"><i class="no-highlight">121</i>&nbsp;    public static long WRITE_COUNT = 0;</b>
<i class="no-highlight">122</i>&nbsp;
<i class="no-highlight">123</i>&nbsp;    /*
<i class="no-highlight">124</i>&nbsp;     * The write count value where we should stop or throw.
<i class="no-highlight">125</i>&nbsp;     */
<b class="fc"><i class="no-highlight">126</i>&nbsp;    public static long STOP_ON_WRITE_COUNT = Long.MAX_VALUE;</b>
<i class="no-highlight">127</i>&nbsp;
<i class="no-highlight">128</i>&nbsp;    /*
<i class="no-highlight">129</i>&nbsp;     * If we&#39;re throwing, then throw on write #&#39;s WRITE_COUNT through
<i class="no-highlight">130</i>&nbsp;     * WRITE_COUNT + N_BAD_WRITES - 1 (inclusive).
<i class="no-highlight">131</i>&nbsp;     */
<b class="fc"><i class="no-highlight">132</i>&nbsp;    public static long N_BAD_WRITES = Long.MAX_VALUE;</b>
<i class="no-highlight">133</i>&nbsp;
<i class="no-highlight">134</i>&nbsp;    /*
<i class="no-highlight">135</i>&nbsp;     * If true, then throw an IOException on write #&#39;s WRITE_COUNT through
<i class="no-highlight">136</i>&nbsp;     * WRITE_COUNT + N_BAD_WRITES - 1 (inclusive).
<i class="no-highlight">137</i>&nbsp;     */
<b class="fc"><i class="no-highlight">138</i>&nbsp;    public static boolean THROW_ON_WRITE = false;</b>
<i class="no-highlight">139</i>&nbsp;
<i class="no-highlight">140</i>&nbsp;    public static final String JE_SUFFIX = &quot;.jdb&quot;;  // regular log files
<i class="no-highlight">141</i>&nbsp;    public static final String DEL_SUFFIX = &quot;.del&quot;;  // cleaned files
<i class="no-highlight">142</i>&nbsp;    public static final String BAD_SUFFIX = &quot;.bad&quot;;  // corrupt files
<i class="no-highlight">143</i>&nbsp;    private static final String LOCK_FILE = &quot;je.lck&quot;;// lock file
<b class="fc"><i class="no-highlight">144</i>&nbsp;    static final String[] DEL_SUFFIXES = { DEL_SUFFIX };</b>
<b class="fc"><i class="no-highlight">145</i>&nbsp;    static final String[] JE_SUFFIXES = { JE_SUFFIX };</b>
<b class="fc"><i class="no-highlight">146</i>&nbsp;    private static final String[] JE_AND_DEL_SUFFIXES =</b>
<i class="no-highlight">147</i>&nbsp;    { JE_SUFFIX, DEL_SUFFIX };
<i class="no-highlight">148</i>&nbsp;
<i class="no-highlight">149</i>&nbsp;    /*
<i class="no-highlight">150</i>&nbsp;     * The suffix used to denote a file that is in the process of being
<i class="no-highlight">151</i>&nbsp;     * transferred during a network backup. The file may not have been
<i class="no-highlight">152</i>&nbsp;     * completely transferred, or its digest verified.
<i class="no-highlight">153</i>&nbsp;     */
<i class="no-highlight">154</i>&nbsp;    public static final String TMP_SUFFIX = &quot;.tmp&quot;;
<i class="no-highlight">155</i>&nbsp;
<i class="no-highlight">156</i>&nbsp;    /*
<i class="no-highlight">157</i>&nbsp;     * The suffix used to rename files out of the way, if they are being
<i class="no-highlight">158</i>&nbsp;     * retained during a backup. Note that the suffix is used in conjunction
<i class="no-highlight">159</i>&nbsp;     * with a backup number as described in &lt;code&gt;NetworkBackup&lt;/code&gt;
<i class="no-highlight">160</i>&nbsp;     */
<i class="no-highlight">161</i>&nbsp;    public static final String BUP_SUFFIX = &quot;.bup&quot;;
<i class="no-highlight">162</i>&nbsp;
<i class="no-highlight">163</i>&nbsp;    /* May be set to false to speed unit tests. */
<b class="fc"><i class="no-highlight">164</i>&nbsp;    private boolean syncAtFileEnd = true;</b>
<i class="no-highlight">165</i>&nbsp;
<i class="no-highlight">166</i>&nbsp;    private final EnvironmentImpl envImpl;
<i class="no-highlight">167</i>&nbsp;    private final long maxFileSize;
<i class="no-highlight">168</i>&nbsp;    private final File dbEnvHome;
<i class="no-highlight">169</i>&nbsp;    private final File[] dbEnvDataDirs;
<i class="no-highlight">170</i>&nbsp;
<i class="no-highlight">171</i>&nbsp;    /* True if .del files should be included in the list of log files. */
<b class="fc"><i class="no-highlight">172</i>&nbsp;    private boolean includeDeletedFiles = false;</b>
<i class="no-highlight">173</i>&nbsp;
<i class="no-highlight">174</i>&nbsp;    /* File cache */
<i class="no-highlight">175</i>&nbsp;    private final FileCache fileCache;
<i class="no-highlight">176</i>&nbsp;
<i class="no-highlight">177</i>&nbsp;    private FileCacheWarmer fileCacheWarmer;
<i class="no-highlight">178</i>&nbsp;
<i class="no-highlight">179</i>&nbsp;    /* The channel and lock for the je.lck file. */
<i class="no-highlight">180</i>&nbsp;    private RandomAccessFile lockFile;
<i class="no-highlight">181</i>&nbsp;    private FileChannel channel;
<i class="no-highlight">182</i>&nbsp;    private FileLock envLock;
<i class="no-highlight">183</i>&nbsp;    private FileLock exclLock;
<i class="no-highlight">184</i>&nbsp;
<i class="no-highlight">185</i>&nbsp;    /* True if all files should be opened readonly. */
<i class="no-highlight">186</i>&nbsp;    private final boolean readOnly;
<i class="no-highlight">187</i>&nbsp;
<i class="no-highlight">188</i>&nbsp;    /* Handles onto log position */
<i class="no-highlight">189</i>&nbsp;    private volatile long currentFileNum;     // number of the current file
<i class="no-highlight">190</i>&nbsp;    private volatile long nextAvailableLsn;   // the next LSN available
<i class="no-highlight">191</i>&nbsp;    private volatile long lastUsedLsn;    // last LSN used in the current file
<i class="no-highlight">192</i>&nbsp;    private boolean forceNewFile;    // Force new file on next write
<i class="no-highlight">193</i>&nbsp;
<i class="no-highlight">194</i>&nbsp;    /* endOfLog is used for writes and fsyncs to the end of the log. */
<i class="no-highlight">195</i>&nbsp;    private final LogEndFileDescriptor endOfLog;
<i class="no-highlight">196</i>&nbsp;
<i class="no-highlight">197</i>&nbsp;    /*
<i class="no-highlight">198</i>&nbsp;     * When we bump the LSNs over to a new file, we must remember the last LSN
<i class="no-highlight">199</i>&nbsp;     * of the previous file so we can set the prevOffset field of the file
<i class="no-highlight">200</i>&nbsp;     * header appropriately. We have to save it in a map because there&#39;s a time
<i class="no-highlight">201</i>&nbsp;     * lag between when we know what the last LSN is and when we actually do
<i class="no-highlight">202</i>&nbsp;     * the file write, because LSN bumping is done before we get a write
<i class="no-highlight">203</i>&nbsp;     * buffer.  This map is keyed by file num-&gt;last LSN.
<i class="no-highlight">204</i>&nbsp;     */
<i class="no-highlight">205</i>&nbsp;    private final Map&lt;Long, Long&gt; perFileLastUsedLsn;
<i class="no-highlight">206</i>&nbsp;
<i class="no-highlight">207</i>&nbsp;    /*
<i class="no-highlight">208</i>&nbsp;     * True if we should use the Write Queue.  This queue is enabled by default
<i class="no-highlight">209</i>&nbsp;     * and contains any write() operations which were attempted but would have
<i class="no-highlight">210</i>&nbsp;     * blocked because an fsync() or another write() was in progress at the
<i class="no-highlight">211</i>&nbsp;     * time.  The operations on the Write Queue are later executed by the next
<i class="no-highlight">212</i>&nbsp;     * operation that is able to grab the fsync latch.  File systems like ext3
<i class="no-highlight">213</i>&nbsp;     * need this queue in order to achieve reasonable throughput since it
<i class="no-highlight">214</i>&nbsp;     * acquires an exclusive mutex on the inode during any IO operation
<i class="no-highlight">215</i>&nbsp;     * (seek/read/write/fsync).  OS&#39;s like Windows and Solaris do not since
<i class="no-highlight">216</i>&nbsp;     * they are able to handle concurrent IO operations on a single file.
<i class="no-highlight">217</i>&nbsp;     */
<i class="no-highlight">218</i>&nbsp;    private final boolean useWriteQueue;
<i class="no-highlight">219</i>&nbsp;
<i class="no-highlight">220</i>&nbsp;    /* The starting size of the Write Queue. */
<i class="no-highlight">221</i>&nbsp;    private final int writeQueueSize;
<i class="no-highlight">222</i>&nbsp;
<i class="no-highlight">223</i>&nbsp;    /*
<i class="no-highlight">224</i>&nbsp;     * Use O_DSYNC to open JE log files.
<i class="no-highlight">225</i>&nbsp;     */
<i class="no-highlight">226</i>&nbsp;    private final boolean useODSYNC;
<i class="no-highlight">227</i>&nbsp;
<i class="no-highlight">228</i>&nbsp;    /* public for unit tests. */
<b class="fc"><i class="no-highlight">229</i>&nbsp;    public boolean VERIFY_CHECKSUMS = false;</b>
<i class="no-highlight">230</i>&nbsp;
<i class="no-highlight">231</i>&nbsp;    /** {@link EnvironmentParams#LOG_FSYNC_TIME_LIMIT}. */
<i class="no-highlight">232</i>&nbsp;    private final int fSyncTimeLimit;
<i class="no-highlight">233</i>&nbsp;
<i class="no-highlight">234</i>&nbsp;    /*
<i class="no-highlight">235</i>&nbsp;     * Non-0 means to use envHome/data001 through envHome/data00N for the
<i class="no-highlight">236</i>&nbsp;     * environment directories, where N is nDataDirs.  Distribute *.jdb files
<i class="no-highlight">237</i>&nbsp;     * through dataNNN directories round-robin.
<i class="no-highlight">238</i>&nbsp;     */
<i class="no-highlight">239</i>&nbsp;    private final int nDataDirs;
<i class="no-highlight">240</i>&nbsp;
<i class="no-highlight">241</i>&nbsp;    /*
<i class="no-highlight">242</i>&nbsp;     * Last file to which any IO was done.
<i class="no-highlight">243</i>&nbsp;     */
<b class="fc"><i class="no-highlight">244</i>&nbsp;    long lastFileNumberTouched = -1;</b>
<i class="no-highlight">245</i>&nbsp;
<i class="no-highlight">246</i>&nbsp;    /*
<i class="no-highlight">247</i>&nbsp;     * Current file offset of lastFile.
<i class="no-highlight">248</i>&nbsp;     */
<b class="fc"><i class="no-highlight">249</i>&nbsp;    long lastFileTouchedOffset = 0;</b>
<i class="no-highlight">250</i>&nbsp;
<i class="no-highlight">251</i>&nbsp;    /*
<i class="no-highlight">252</i>&nbsp;     * For IO stats, this is a measure of what is &quot;close enough&quot; to constitute
<i class="no-highlight">253</i>&nbsp;     * a sequential IO vs a random IO. 1MB for now.  Generally a seek within a
<i class="no-highlight">254</i>&nbsp;     * few tracks of the current disk track is &quot;fast&quot; and only requires a
<i class="no-highlight">255</i>&nbsp;     * single rotational latency.
<i class="no-highlight">256</i>&nbsp;     */
<i class="no-highlight">257</i>&nbsp;    private static final long ADJACENT_TRACK_SEEK_DELTA = 1 &lt;&lt; 20;
<i class="no-highlight">258</i>&nbsp;
<i class="no-highlight">259</i>&nbsp;    /*
<i class="no-highlight">260</i>&nbsp;     * Used to detect unexpected file deletion.
<i class="no-highlight">261</i>&nbsp;     */
<i class="no-highlight">262</i>&nbsp;    private final FileDeletionDetector fdd;
<i class="no-highlight">263</i>&nbsp;
<i class="no-highlight">264</i>&nbsp;    /*
<i class="no-highlight">265</i>&nbsp;     * Stats
<i class="no-highlight">266</i>&nbsp;     */
<i class="no-highlight">267</i>&nbsp;    final StatGroup stats;
<i class="no-highlight">268</i>&nbsp;    final LongStat nRandomReads;
<i class="no-highlight">269</i>&nbsp;    final LongStat nRandomWrites;
<i class="no-highlight">270</i>&nbsp;    final LongStat nSequentialReads;
<i class="no-highlight">271</i>&nbsp;    final LongStat nSequentialWrites;
<i class="no-highlight">272</i>&nbsp;    final LongStat nRandomReadBytes;
<i class="no-highlight">273</i>&nbsp;    final LongStat nRandomWriteBytes;
<i class="no-highlight">274</i>&nbsp;    final LongStat nSequentialReadBytes;
<i class="no-highlight">275</i>&nbsp;    final LongStat nSequentialWriteBytes;
<i class="no-highlight">276</i>&nbsp;    final IntStat nFileOpens;
<i class="no-highlight">277</i>&nbsp;    final IntStat nOpenFiles;
<i class="no-highlight">278</i>&nbsp;    final LongStat nBytesReadFromWriteQueue;
<i class="no-highlight">279</i>&nbsp;    final LongStat nBytesWrittenFromWriteQueue;
<i class="no-highlight">280</i>&nbsp;    final LongStat nReadsFromWriteQueue;
<i class="no-highlight">281</i>&nbsp;    final LongStat nWritesFromWriteQueue;
<i class="no-highlight">282</i>&nbsp;    final LongStat nWriteQueueOverflow;
<i class="no-highlight">283</i>&nbsp;    final LongStat nWriteQueueOverflowFailures;
<i class="no-highlight">284</i>&nbsp;    /* all fsyncs, includes those issued for group commit */
<i class="no-highlight">285</i>&nbsp;    final LongStat nLogFSyncs;
<i class="no-highlight">286</i>&nbsp;    final LongStat nFSyncTime;
<i class="no-highlight">287</i>&nbsp;    final LongMaxZeroStat nFSyncMaxTime;
<i class="no-highlight">288</i>&nbsp;
<i class="no-highlight">289</i>&nbsp;    /**
<i class="no-highlight">290</i>&nbsp;     * Set up the file cache and initialize the file manager to point to the
<i class="no-highlight">291</i>&nbsp;     * beginning of the log.
<i class="no-highlight">292</i>&nbsp;     *
<i class="no-highlight">293</i>&nbsp;     * @param dbEnvHome environment home directory
<i class="no-highlight">294</i>&nbsp;     *
<i class="no-highlight">295</i>&nbsp;     * @throws IllegalArgumentException via Environment ctor
<i class="no-highlight">296</i>&nbsp;     *
<i class="no-highlight">297</i>&nbsp;     * @throws EnvironmentLockedException via Environment ctor
<i class="no-highlight">298</i>&nbsp;     */
<i class="no-highlight">299</i>&nbsp;    public FileManager(EnvironmentImpl envImpl,
<i class="no-highlight">300</i>&nbsp;                       File dbEnvHome,
<i class="no-highlight">301</i>&nbsp;                       boolean readOnly)
<b class="fc"><i class="no-highlight">302</i>&nbsp;        throws EnvironmentLockedException {</b>
<i class="no-highlight">303</i>&nbsp;
<b class="fc"><i class="no-highlight">304</i>&nbsp;        this.envImpl = envImpl;</b>
<b class="fc"><i class="no-highlight">305</i>&nbsp;        this.dbEnvHome = dbEnvHome;</b>
<b class="fc"><i class="no-highlight">306</i>&nbsp;        this.readOnly = readOnly;</b>
<i class="no-highlight">307</i>&nbsp;
<b class="fc"><i class="no-highlight">308</i>&nbsp;        boolean success = false;</b>
<i class="no-highlight">309</i>&nbsp;
<b class="fc"><i class="no-highlight">310</i>&nbsp;        stats = new StatGroup(LogStatDefinition.FILEMGR_GROUP_NAME,</b>
<i class="no-highlight">311</i>&nbsp;                              LogStatDefinition.FILEMGR_GROUP_DESC);
<b class="fc"><i class="no-highlight">312</i>&nbsp;        nRandomReads = new LongStat(stats, FILEMGR_RANDOM_READS);</b>
<b class="fc"><i class="no-highlight">313</i>&nbsp;        nRandomWrites = new LongStat(stats, FILEMGR_RANDOM_WRITES);</b>
<b class="fc"><i class="no-highlight">314</i>&nbsp;        nSequentialReads = new LongStat(stats, FILEMGR_SEQUENTIAL_READS);</b>
<b class="fc"><i class="no-highlight">315</i>&nbsp;        nSequentialWrites = new LongStat(stats, FILEMGR_SEQUENTIAL_WRITES);</b>
<b class="fc"><i class="no-highlight">316</i>&nbsp;        nRandomReadBytes = new LongStat(stats, FILEMGR_RANDOM_READ_BYTES);</b>
<b class="fc"><i class="no-highlight">317</i>&nbsp;        nRandomWriteBytes = new LongStat(stats, FILEMGR_RANDOM_WRITE_BYTES);</b>
<b class="fc"><i class="no-highlight">318</i>&nbsp;        nSequentialReadBytes =</b>
<i class="no-highlight">319</i>&nbsp;            new LongStat(stats, FILEMGR_SEQUENTIAL_READ_BYTES);
<b class="fc"><i class="no-highlight">320</i>&nbsp;        nSequentialWriteBytes =</b>
<i class="no-highlight">321</i>&nbsp;            new LongStat(stats, FILEMGR_SEQUENTIAL_WRITE_BYTES);
<b class="fc"><i class="no-highlight">322</i>&nbsp;        nFileOpens = new IntStat(stats, FILEMGR_FILE_OPENS);</b>
<b class="fc"><i class="no-highlight">323</i>&nbsp;        nOpenFiles = new IntStat(stats, FILEMGR_OPEN_FILES);</b>
<b class="fc"><i class="no-highlight">324</i>&nbsp;        nBytesReadFromWriteQueue =</b>
<i class="no-highlight">325</i>&nbsp;            new LongStat(stats, FILEMGR_BYTES_READ_FROM_WRITEQUEUE);
<b class="fc"><i class="no-highlight">326</i>&nbsp;        nBytesWrittenFromWriteQueue =</b>
<i class="no-highlight">327</i>&nbsp;            new LongStat(stats, FILEMGR_BYTES_WRITTEN_FROM_WRITEQUEUE);
<b class="fc"><i class="no-highlight">328</i>&nbsp;        nReadsFromWriteQueue =</b>
<i class="no-highlight">329</i>&nbsp;            new LongStat(stats, FILEMGR_READS_FROM_WRITEQUEUE);
<b class="fc"><i class="no-highlight">330</i>&nbsp;        nWritesFromWriteQueue =</b>
<i class="no-highlight">331</i>&nbsp;            new LongStat(stats, FILEMGR_WRITES_FROM_WRITEQUEUE);
<b class="fc"><i class="no-highlight">332</i>&nbsp;        nWriteQueueOverflow = new LongStat(stats, FILEMGR_WRITEQUEUE_OVERFLOW);</b>
<b class="fc"><i class="no-highlight">333</i>&nbsp;        nWriteQueueOverflowFailures =</b>
<i class="no-highlight">334</i>&nbsp;            new LongStat(stats, FILEMGR_WRITEQUEUE_OVERFLOW_FAILURES);
<b class="fc"><i class="no-highlight">335</i>&nbsp;        nLogFSyncs = new LongStat(stats, FILEMGR_LOG_FSYNCS);</b>
<b class="fc"><i class="no-highlight">336</i>&nbsp;        nFSyncTime = new LongStat(stats, GRPCMGR_FSYNC_TIME);</b>
<b class="fc"><i class="no-highlight">337</i>&nbsp;        nFSyncMaxTime = new LongMaxZeroStat(stats, GRPCMGR_FSYNC_MAX_TIME);</b>
<i class="no-highlight">338</i>&nbsp;
<i class="no-highlight">339</i>&nbsp;        try {
<i class="no-highlight">340</i>&nbsp;            /* Read configurations. */
<b class="fc"><i class="no-highlight">341</i>&nbsp;            DbConfigManager configManager = envImpl.getConfigManager();</b>
<b class="fc"><i class="no-highlight">342</i>&nbsp;            maxFileSize =</b>
<b class="fc"><i class="no-highlight">343</i>&nbsp;                configManager.getLong(EnvironmentParams.LOG_FILE_MAX);</b>
<i class="no-highlight">344</i>&nbsp;
<b class="fc"><i class="no-highlight">345</i>&nbsp;            useWriteQueue = configManager.getBoolean(</b>
<i class="no-highlight">346</i>&nbsp;                EnvironmentParams.LOG_USE_WRITE_QUEUE);
<i class="no-highlight">347</i>&nbsp;
<b class="fc"><i class="no-highlight">348</i>&nbsp;            writeQueueSize = configManager.getInt(</b>
<i class="no-highlight">349</i>&nbsp;                EnvironmentParams.LOG_WRITE_QUEUE_SIZE);
<i class="no-highlight">350</i>&nbsp;
<b class="fc"><i class="no-highlight">351</i>&nbsp;            useODSYNC = configManager.getBoolean(</b>
<i class="no-highlight">352</i>&nbsp;                EnvironmentParams.LOG_USE_ODSYNC);
<i class="no-highlight">353</i>&nbsp;
<b class="fc"><i class="no-highlight">354</i>&nbsp;            VERIFY_CHECKSUMS = configManager.getBoolean(</b>
<i class="no-highlight">355</i>&nbsp;                EnvironmentParams.LOG_VERIFY_CHECKSUMS);
<i class="no-highlight">356</i>&nbsp;
<b class="fc"><i class="no-highlight">357</i>&nbsp;            fSyncTimeLimit = configManager.getDuration(</b>
<i class="no-highlight">358</i>&nbsp;                EnvironmentParams.LOG_FSYNC_TIME_LIMIT);
<i class="no-highlight">359</i>&nbsp;
<b class="fc"><i class="no-highlight">360</i>&nbsp;            nDataDirs = configManager.getInt(</b>
<i class="no-highlight">361</i>&nbsp;                EnvironmentParams.LOG_N_DATA_DIRECTORIES);
<i class="no-highlight">362</i>&nbsp;
<b class="fc"><i class="no-highlight">363</i>&nbsp;            if (nDataDirs != 0) {</b>
<b class="nc"><i class="no-highlight">364</i>&nbsp;                dbEnvDataDirs = gatherDataDirs();</b>
<i class="no-highlight">365</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">366</i>&nbsp;                checkNoDataDirs();</b>
<b class="fc"><i class="no-highlight">367</i>&nbsp;                dbEnvDataDirs = null;</b>
<i class="no-highlight">368</i>&nbsp;            }
<i class="no-highlight">369</i>&nbsp;
<b class="fc"><i class="no-highlight">370</i>&nbsp;            if (!envImpl.isMemOnly()) {</b>
<b class="fc"><i class="no-highlight">371</i>&nbsp;                if (!dbEnvHome.exists()) {</b>
<b class="nc"><i class="no-highlight">372</i>&nbsp;                    throw new IllegalArgumentException</b>
<i class="no-highlight">373</i>&nbsp;                        (&quot;Environment home &quot; + dbEnvHome + &quot; doesn&#39;t exist&quot;);
<i class="no-highlight">374</i>&nbsp;                }
<i class="no-highlight">375</i>&nbsp;
<i class="no-highlight">376</i>&nbsp;                /*
<i class="no-highlight">377</i>&nbsp;                 * If this is an arbiter take an exclusive lock.
<i class="no-highlight">378</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">379</i>&nbsp;                boolean isReadOnly = envImpl.isArbiter() ? false : readOnly;</b>
<b class="fc"><i class="no-highlight">380</i>&nbsp;                if (!lockEnvironment(isReadOnly, false)) {</b>
<b class="nc"><i class="no-highlight">381</i>&nbsp;                    throw new EnvironmentLockedException</b>
<i class="no-highlight">382</i>&nbsp;                        (envImpl,
<i class="no-highlight">383</i>&nbsp;                         &quot;The environment cannot be locked for &quot; +
<i class="no-highlight">384</i>&nbsp;                         (isReadOnly ? &quot;shared&quot; : &quot;single writer&quot;) +
<i class="no-highlight">385</i>&nbsp;                         &quot; access.&quot;);
<i class="no-highlight">386</i>&nbsp;                }
<i class="no-highlight">387</i>&nbsp;            }
<i class="no-highlight">388</i>&nbsp;
<i class="no-highlight">389</i>&nbsp;            /* Cache of files. */
<b class="fc"><i class="no-highlight">390</i>&nbsp;            fileCache = new FileCache(configManager);</b>
<i class="no-highlight">391</i>&nbsp;
<i class="no-highlight">392</i>&nbsp;            /* Start out as if no log existed. */
<b class="fc"><i class="no-highlight">393</i>&nbsp;            currentFileNum = 0L;</b>
<b class="fc"><i class="no-highlight">394</i>&nbsp;            nextAvailableLsn =</b>
<b class="fc"><i class="no-highlight">395</i>&nbsp;                DbLsn.makeLsn(currentFileNum, firstLogEntryOffset());</b>
<b class="fc"><i class="no-highlight">396</i>&nbsp;            lastUsedLsn = DbLsn.NULL_LSN;</b>
<b class="fc"><i class="no-highlight">397</i>&nbsp;            perFileLastUsedLsn =</b>
<b class="fc"><i class="no-highlight">398</i>&nbsp;                Collections.synchronizedMap(new HashMap&lt;Long, Long&gt;());</b>
<b class="fc"><i class="no-highlight">399</i>&nbsp;            endOfLog = new LogEndFileDescriptor();</b>
<b class="fc"><i class="no-highlight">400</i>&nbsp;            forceNewFile = false;</b>
<i class="no-highlight">401</i>&nbsp;
<b class="fc"><i class="no-highlight">402</i>&nbsp;            final String stopOnWriteCountName = &quot;je.debug.stopOnWriteCount&quot;;</b>
<b class="fc"><i class="no-highlight">403</i>&nbsp;            final String stopOnWriteCountProp =</b>
<b class="fc"><i class="no-highlight">404</i>&nbsp;                System.getProperty(stopOnWriteCountName);</b>
<b class="fc"><i class="no-highlight">405</i>&nbsp;            if (stopOnWriteCountProp != null) {</b>
<i class="no-highlight">406</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">407</i>&nbsp;                    STOP_ON_WRITE_COUNT = Long.parseLong(stopOnWriteCountProp);</b>
<b class="nc"><i class="no-highlight">408</i>&nbsp;                } catch (NumberFormatException e) {</b>
<b class="nc"><i class="no-highlight">409</i>&nbsp;                    throw new IllegalArgumentException</b>
<i class="no-highlight">410</i>&nbsp;                        (&quot;Could not parse: &quot; + stopOnWriteCountName, e);
<b class="nc"><i class="no-highlight">411</i>&nbsp;                }</b>
<i class="no-highlight">412</i>&nbsp;            }
<i class="no-highlight">413</i>&nbsp;
<b class="fc"><i class="no-highlight">414</i>&nbsp;            final String stopOnWriteActionName = &quot;je.debug.stopOnWriteAction&quot;;</b>
<b class="fc"><i class="no-highlight">415</i>&nbsp;            final String stopOnWriteActionProp =</b>
<b class="fc"><i class="no-highlight">416</i>&nbsp;                System.getProperty(stopOnWriteActionName);</b>
<b class="fc"><i class="no-highlight">417</i>&nbsp;            if (stopOnWriteActionProp != null) {</b>
<b class="nc"><i class="no-highlight">418</i>&nbsp;                if (stopOnWriteActionProp.compareToIgnoreCase(&quot;throw&quot;) == 0) {</b>
<b class="nc"><i class="no-highlight">419</i>&nbsp;                    THROW_ON_WRITE = true;</b>
<b class="nc"><i class="no-highlight">420</i>&nbsp;                } else if (stopOnWriteActionProp.</b>
<b class="nc"><i class="no-highlight">421</i>&nbsp;                           compareToIgnoreCase(&quot;stop&quot;) == 0) {</b>
<b class="nc"><i class="no-highlight">422</i>&nbsp;                    THROW_ON_WRITE = false;</b>
<i class="no-highlight">423</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">424</i>&nbsp;                    throw new IllegalArgumentException</b>
<i class="no-highlight">425</i>&nbsp;                        (&quot;Unknown value for: &quot; + stopOnWriteActionName  +
<i class="no-highlight">426</i>&nbsp;                         stopOnWriteActionProp);
<i class="no-highlight">427</i>&nbsp;                }
<i class="no-highlight">428</i>&nbsp;            }
<i class="no-highlight">429</i>&nbsp;
<b class="fc"><i class="no-highlight">430</i>&nbsp;            final Boolean logFileDeleteDetect = configManager.getBoolean(</b>
<i class="no-highlight">431</i>&nbsp;                EnvironmentParams.LOG_DETECT_FILE_DELETE);
<b class="fc"><i class="no-highlight">432</i>&nbsp;            if (!envImpl.isMemOnly() &amp;&amp; logFileDeleteDetect) {</b>
<b class="fc"><i class="no-highlight">433</i>&nbsp;                fdd = new FileDeletionDetector(</b>
<i class="no-highlight">434</i>&nbsp;                    dbEnvHome, dbEnvDataDirs, envImpl);
<i class="no-highlight">435</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">436</i>&nbsp;                fdd = null;</b>
<i class="no-highlight">437</i>&nbsp;            }
<i class="no-highlight">438</i>&nbsp;
<b class="fc"><i class="no-highlight">439</i>&nbsp;            success = true;</b>
<i class="no-highlight">440</i>&nbsp;        } finally {
<b class="fc"><i class="no-highlight">441</i>&nbsp;            if (!success) {</b>
<i class="no-highlight">442</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">443</i>&nbsp;                    close();</b>
<b class="nc"><i class="no-highlight">444</i>&nbsp;                } catch (IOException e) {</b>
<i class="no-highlight">445</i>&nbsp;                    /*
<i class="no-highlight">446</i>&nbsp;                     * Klockwork - ok
<i class="no-highlight">447</i>&nbsp;                     * Eat it, we want to throw the original exception.
<i class="no-highlight">448</i>&nbsp;                     */
<b class="nc"><i class="no-highlight">449</i>&nbsp;                }</b>
<i class="no-highlight">450</i>&nbsp;            }
<b class="nc"><i class="no-highlight">451</i>&nbsp;        }</b>
<b class="fc"><i class="no-highlight">452</i>&nbsp;    }</b>
<i class="no-highlight">453</i>&nbsp;
<i class="no-highlight">454</i>&nbsp;    /**
<i class="no-highlight">455</i>&nbsp;     * Set the file manager&#39;s &quot;end of log&quot;.
<i class="no-highlight">456</i>&nbsp;     *
<i class="no-highlight">457</i>&nbsp;     * @param nextAvailableLsn LSN to be used for the next log entry
<i class="no-highlight">458</i>&nbsp;     * @param lastUsedLsn last LSN to have a valid entry, may be null
<i class="no-highlight">459</i>&nbsp;     * @param prevOffset value to use for the prevOffset of the next entry.
<i class="no-highlight">460</i>&nbsp;     *  If the beginning of the file, this is 0.
<i class="no-highlight">461</i>&nbsp;     */
<i class="no-highlight">462</i>&nbsp;    public void setLastPosition(long nextAvailableLsn,
<i class="no-highlight">463</i>&nbsp;                                long lastUsedLsn,
<i class="no-highlight">464</i>&nbsp;                                long prevOffset) {
<b class="nc"><i class="no-highlight">465</i>&nbsp;        this.lastUsedLsn = lastUsedLsn;</b>
<b class="nc"><i class="no-highlight">466</i>&nbsp;        perFileLastUsedLsn.put(DbLsn.getFileNumber(lastUsedLsn), lastUsedLsn);</b>
<b class="nc"><i class="no-highlight">467</i>&nbsp;        this.nextAvailableLsn = nextAvailableLsn;</b>
<b class="nc"><i class="no-highlight">468</i>&nbsp;        currentFileNum = DbLsn.getFileNumber(this.nextAvailableLsn);</b>
<b class="nc"><i class="no-highlight">469</i>&nbsp;    }</b>
<i class="no-highlight">470</i>&nbsp;
<i class="no-highlight">471</i>&nbsp;    /**
<i class="no-highlight">472</i>&nbsp;     * May be used to disable sync at file end to speed unit tests.
<i class="no-highlight">473</i>&nbsp;     * Must only be used for unit testing, since log corruption may result.
<i class="no-highlight">474</i>&nbsp;     */
<i class="no-highlight">475</i>&nbsp;    public void setSyncAtFileEnd(boolean sync) {
<b class="nc"><i class="no-highlight">476</i>&nbsp;        syncAtFileEnd = sync;</b>
<b class="nc"><i class="no-highlight">477</i>&nbsp;    }</b>
<i class="no-highlight">478</i>&nbsp;
<i class="no-highlight">479</i>&nbsp;    /*
<i class="no-highlight">480</i>&nbsp;     * File management
<i class="no-highlight">481</i>&nbsp;     */
<i class="no-highlight">482</i>&nbsp;
<i class="no-highlight">483</i>&nbsp;    /**
<i class="no-highlight">484</i>&nbsp;     * public for cleaner.
<i class="no-highlight">485</i>&nbsp;     *
<i class="no-highlight">486</i>&nbsp;     * @return the number of the first file in this environment.
<i class="no-highlight">487</i>&nbsp;     */
<i class="no-highlight">488</i>&nbsp;    public Long getFirstFileNum() {
<b class="nc"><i class="no-highlight">489</i>&nbsp;        return getFileNum(true);</b>
<i class="no-highlight">490</i>&nbsp;    }
<i class="no-highlight">491</i>&nbsp;
<i class="no-highlight">492</i>&nbsp;    public boolean getReadOnly() {
<b class="nc"><i class="no-highlight">493</i>&nbsp;        return readOnly;</b>
<i class="no-highlight">494</i>&nbsp;    }
<i class="no-highlight">495</i>&nbsp;
<i class="no-highlight">496</i>&nbsp;    /**
<i class="no-highlight">497</i>&nbsp;     * @return the number of the last file in this environment.
<i class="no-highlight">498</i>&nbsp;     */
<i class="no-highlight">499</i>&nbsp;    public Long getLastFileNum() {
<b class="nc"><i class="no-highlight">500</i>&nbsp;        return getFileNum(false);</b>
<i class="no-highlight">501</i>&nbsp;    }
<i class="no-highlight">502</i>&nbsp;
<i class="no-highlight">503</i>&nbsp;    /**
<i class="no-highlight">504</i>&nbsp;     * Returns the highest (current) file number. Note that this is
<i class="no-highlight">505</i>&nbsp;     * unsynchronized, so if it is called outside the log write latch it is
<i class="no-highlight">506</i>&nbsp;     * only valid as an approximation.
<i class="no-highlight">507</i>&nbsp;     */
<i class="no-highlight">508</i>&nbsp;    public long getCurrentFileNum() {
<b class="fc"><i class="no-highlight">509</i>&nbsp;        return currentFileNum;</b>
<i class="no-highlight">510</i>&nbsp;    }
<i class="no-highlight">511</i>&nbsp;
<i class="no-highlight">512</i>&nbsp;    /**
<i class="no-highlight">513</i>&nbsp;     * For unit tests.
<i class="no-highlight">514</i>&nbsp;     */
<i class="no-highlight">515</i>&nbsp;    boolean getUseWriteQueue() {
<b class="nc"><i class="no-highlight">516</i>&nbsp;        return useWriteQueue;</b>
<i class="no-highlight">517</i>&nbsp;    }
<i class="no-highlight">518</i>&nbsp;
<i class="no-highlight">519</i>&nbsp;    /**
<i class="no-highlight">520</i>&nbsp;     * For assertions that check whether a file is valid or has been deleted
<i class="no-highlight">521</i>&nbsp;     * via log cleaning.
<i class="no-highlight">522</i>&nbsp;     */
<i class="no-highlight">523</i>&nbsp;    public boolean isFileValid(long fileNum) {
<i class="no-highlight">524</i>&nbsp;
<i class="no-highlight">525</i>&nbsp;        /*
<i class="no-highlight">526</i>&nbsp;         * If the file is the current file, it may be buffered and not yet
<i class="no-highlight">527</i>&nbsp;         * created.  If the env is memory-only, we will never create or delete
<i class="no-highlight">528</i>&nbsp;         * log files.
<i class="no-highlight">529</i>&nbsp;         */
<b class="nc"><i class="no-highlight">530</i>&nbsp;        if (fileNum == currentFileNum || envImpl.isMemOnly()) {</b>
<b class="nc"><i class="no-highlight">531</i>&nbsp;            return true;</b>
<i class="no-highlight">532</i>&nbsp;        }
<i class="no-highlight">533</i>&nbsp;
<i class="no-highlight">534</i>&nbsp;        /* Check for file existence. */
<b class="nc"><i class="no-highlight">535</i>&nbsp;        String fileName = getFullFileName(fileNum, FileManager.JE_SUFFIX);</b>
<b class="nc"><i class="no-highlight">536</i>&nbsp;        File file = new File(fileName);</b>
<b class="nc"><i class="no-highlight">537</i>&nbsp;        return file.exists();</b>
<i class="no-highlight">538</i>&nbsp;    }
<i class="no-highlight">539</i>&nbsp;
<i class="no-highlight">540</i>&nbsp;    public void setIncludeDeletedFiles(boolean includeDeletedFiles) {
<b class="nc"><i class="no-highlight">541</i>&nbsp;        this.includeDeletedFiles = includeDeletedFiles;</b>
<b class="nc"><i class="no-highlight">542</i>&nbsp;    }</b>
<i class="no-highlight">543</i>&nbsp;
<i class="no-highlight">544</i>&nbsp;    /**
<i class="no-highlight">545</i>&nbsp;     * Get all JE file numbers.
<i class="no-highlight">546</i>&nbsp;     * @return an array of all JE file numbers.
<i class="no-highlight">547</i>&nbsp;     */
<i class="no-highlight">548</i>&nbsp;    public Long[] getAllFileNumbers() {
<i class="no-highlight">549</i>&nbsp;        /* Get all the names in sorted order. */
<b class="fc"><i class="no-highlight">550</i>&nbsp;        String[] names = listFileNames(JE_SUFFIXES);</b>
<b class="fc"><i class="no-highlight">551</i>&nbsp;        Long[] nums = new Long[names.length];</b>
<b class="fc"><i class="no-highlight">552</i>&nbsp;        for (int i = 0; i &lt; nums.length; i += 1) {</b>
<b class="fc"><i class="no-highlight">553</i>&nbsp;            String name = names[i];</b>
<b class="fc"><i class="no-highlight">554</i>&nbsp;            long num = nums[i] = getNumFromName(name);</b>
<b class="fc"><i class="no-highlight">555</i>&nbsp;            if (nDataDirs != 0) {</b>
<b class="nc"><i class="no-highlight">556</i>&nbsp;                int dbEnvDataDirsIdx = getDataDirIndexFromName(name) - 1;</b>
<b class="nc"><i class="no-highlight">557</i>&nbsp;                if (dbEnvDataDirsIdx != (num % nDataDirs)) {</b>
<b class="nc"><i class="no-highlight">558</i>&nbsp;                    throw EnvironmentFailureException.unexpectedState</b>
<b class="nc"><i class="no-highlight">559</i>&nbsp;                        (&quot;Found file &quot; + name + &quot; but it should have been in &quot; +</b>
<i class="no-highlight">560</i>&nbsp;                         &quot;data directory &quot; + (dbEnvDataDirsIdx + 1) +
<i class="no-highlight">561</i>&nbsp;                         &quot;. Perhaps it was moved or restored incorrectly?&quot;);
<i class="no-highlight">562</i>&nbsp;                }
<i class="no-highlight">563</i>&nbsp;            }
<i class="no-highlight">564</i>&nbsp;        }
<b class="fc"><i class="no-highlight">565</i>&nbsp;        return nums;</b>
<i class="no-highlight">566</i>&nbsp;    }
<i class="no-highlight">567</i>&nbsp;
<i class="no-highlight">568</i>&nbsp;    /**
<i class="no-highlight">569</i>&nbsp;     * Get the next file number before/after currentFileNum.
<i class="no-highlight">570</i>&nbsp;     * @param curFile the file we&#39;re at right now. Note that
<i class="no-highlight">571</i>&nbsp;     * it may not exist, if it&#39;s been cleaned and renamed.
<i class="no-highlight">572</i>&nbsp;     * @param forward if true, we want the next larger file, if false
<i class="no-highlight">573</i>&nbsp;     * we want the previous file
<i class="no-highlight">574</i>&nbsp;     * @return null if there is no following file, or if filenum doesn&#39;t exist
<i class="no-highlight">575</i>&nbsp;     */
<i class="no-highlight">576</i>&nbsp;    public Long getFollowingFileNum(long curFile, boolean forward) {
<i class="no-highlight">577</i>&nbsp;
<i class="no-highlight">578</i>&nbsp;        /*
<i class="no-highlight">579</i>&nbsp;         * First try the next/prev file number without listing all files. This
<i class="no-highlight">580</i>&nbsp;         * efficiently supports an important use case: reading files during
<i class="no-highlight">581</i>&nbsp;         * recovery, where there are no gaps due to log cleaning. If there is a
<i class="no-highlight">582</i>&nbsp;         * gap due to log cleaning, fall through and get a list of all files.
<i class="no-highlight">583</i>&nbsp;         */
<i class="no-highlight">584</i>&nbsp;        final long tryFile;
<b class="nc"><i class="no-highlight">585</i>&nbsp;        if (forward) {</b>
<b class="nc"><i class="no-highlight">586</i>&nbsp;            if (curFile == Long.MAX_VALUE) {</b>
<b class="nc"><i class="no-highlight">587</i>&nbsp;                return null;</b>
<i class="no-highlight">588</i>&nbsp;            }
<b class="nc"><i class="no-highlight">589</i>&nbsp;            tryFile = curFile + 1;</b>
<i class="no-highlight">590</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">591</i>&nbsp;            if (curFile &lt;= 0) {</b>
<b class="nc"><i class="no-highlight">592</i>&nbsp;                return null;</b>
<i class="no-highlight">593</i>&nbsp;            }
<b class="nc"><i class="no-highlight">594</i>&nbsp;            tryFile = curFile - 1;</b>
<i class="no-highlight">595</i>&nbsp;        }
<i class="no-highlight">596</i>&nbsp;
<b class="nc"><i class="no-highlight">597</i>&nbsp;        String tryName = getFullFileName(tryFile, JE_SUFFIX);</b>
<b class="nc"><i class="no-highlight">598</i>&nbsp;        if ((new File(tryName)).isFile()) {</b>
<b class="nc"><i class="no-highlight">599</i>&nbsp;            return tryFile;</b>
<i class="no-highlight">600</i>&nbsp;        }
<i class="no-highlight">601</i>&nbsp;
<i class="no-highlight">602</i>&nbsp;        /* Get all the names in sorted order. */
<b class="nc"><i class="no-highlight">603</i>&nbsp;        String[] names = listFileNames(JE_SUFFIXES);</b>
<i class="no-highlight">604</i>&nbsp;
<i class="no-highlight">605</i>&nbsp;        /* Search for the current file. */
<b class="nc"><i class="no-highlight">606</i>&nbsp;        String searchName = getFileName(curFile, JE_SUFFIX);</b>
<b class="nc"><i class="no-highlight">607</i>&nbsp;        int foundIdx = Arrays.binarySearch(names, searchName, stringComparator);</b>
<i class="no-highlight">608</i>&nbsp;
<b class="nc"><i class="no-highlight">609</i>&nbsp;        boolean foundTarget = false;</b>
<b class="nc"><i class="no-highlight">610</i>&nbsp;        if (foundIdx &gt;= 0) {</b>
<b class="nc"><i class="no-highlight">611</i>&nbsp;            if (forward) {</b>
<b class="nc"><i class="no-highlight">612</i>&nbsp;                foundIdx++;</b>
<i class="no-highlight">613</i>&nbsp;            } else {
<b class="nc"><i class="no-highlight">614</i>&nbsp;                foundIdx--;</b>
<i class="no-highlight">615</i>&nbsp;            }
<i class="no-highlight">616</i>&nbsp;        } else {
<i class="no-highlight">617</i>&nbsp;
<i class="no-highlight">618</i>&nbsp;            /*
<i class="no-highlight">619</i>&nbsp;             * currentFileNum not found (might have been cleaned). FoundIdx
<i class="no-highlight">620</i>&nbsp;             * will be (-insertionPoint - 1).
<i class="no-highlight">621</i>&nbsp;             */
<b class="nc"><i class="no-highlight">622</i>&nbsp;            foundIdx = Math.abs(foundIdx + 1);</b>
<b class="nc"><i class="no-highlight">623</i>&nbsp;            if (!forward) {</b>
<b class="nc"><i class="no-highlight">624</i>&nbsp;                foundIdx--;</b>
<i class="no-highlight">625</i>&nbsp;            }
<i class="no-highlight">626</i>&nbsp;        }
<i class="no-highlight">627</i>&nbsp;
<i class="no-highlight">628</i>&nbsp;        /* The current fileNum is found, return the next or prev file. */
<b class="nc"><i class="no-highlight">629</i>&nbsp;        if (forward &amp;&amp; (foundIdx &lt; names.length)) {</b>
<b class="nc"><i class="no-highlight">630</i>&nbsp;            foundTarget = true;</b>
<b class="nc"><i class="no-highlight">631</i>&nbsp;        } else if (!forward &amp;&amp; (foundIdx &gt; -1)) {</b>
<b class="nc"><i class="no-highlight">632</i>&nbsp;            foundTarget = true;</b>
<i class="no-highlight">633</i>&nbsp;        }
<i class="no-highlight">634</i>&nbsp;
<b class="nc"><i class="no-highlight">635</i>&nbsp;        if (foundTarget) {</b>
<b class="nc"><i class="no-highlight">636</i>&nbsp;            return getNumFromName(names[foundIdx]);</b>
<i class="no-highlight">637</i>&nbsp;        }
<b class="nc"><i class="no-highlight">638</i>&nbsp;        return null;</b>
<i class="no-highlight">639</i>&nbsp;    }
<i class="no-highlight">640</i>&nbsp;
<i class="no-highlight">641</i>&nbsp;    /**
<i class="no-highlight">642</i>&nbsp;     * @return true if there are any files at all.
<i class="no-highlight">643</i>&nbsp;     */
<i class="no-highlight">644</i>&nbsp;    public boolean filesExist() {
<b class="fc"><i class="no-highlight">645</i>&nbsp;        String[] names = listFileNames(JE_SUFFIXES);</b>
<b class="fc"><i class="no-highlight">646</i>&nbsp;        return (names.length != 0);</b>
<i class="no-highlight">647</i>&nbsp;    }
<i class="no-highlight">648</i>&nbsp;
<i class="no-highlight">649</i>&nbsp;    /**
<i class="no-highlight">650</i>&nbsp;     * Get the first or last file number in the set of JE files.
<i class="no-highlight">651</i>&nbsp;     *
<i class="no-highlight">652</i>&nbsp;     * @param first if true, get the first file, else get the last file
<i class="no-highlight">653</i>&nbsp;     * @return the file number or null if no files exist
<i class="no-highlight">654</i>&nbsp;     */
<i class="no-highlight">655</i>&nbsp;    private Long getFileNum(boolean first) {
<b class="nc"><i class="no-highlight">656</i>&nbsp;        String[] names = listFileNames(JE_SUFFIXES);</b>
<b class="nc"><i class="no-highlight">657</i>&nbsp;        if (names.length == 0) {</b>
<b class="nc"><i class="no-highlight">658</i>&nbsp;            return null;</b>
<i class="no-highlight">659</i>&nbsp;        }
<b class="nc"><i class="no-highlight">660</i>&nbsp;        int index = 0;</b>
<b class="nc"><i class="no-highlight">661</i>&nbsp;        if (!first) {</b>
<b class="nc"><i class="no-highlight">662</i>&nbsp;            index = names.length - 1;</b>
<i class="no-highlight">663</i>&nbsp;        }
<b class="nc"><i class="no-highlight">664</i>&nbsp;        return getNumFromName(names[index]);</b>
<i class="no-highlight">665</i>&nbsp;    }
<i class="no-highlight">666</i>&nbsp;
<i class="no-highlight">667</i>&nbsp;    /**
<i class="no-highlight">668</i>&nbsp;     * Get the data dir index from a file name.
<i class="no-highlight">669</i>&nbsp;     *
<i class="no-highlight">670</i>&nbsp;     * @return index into dbEnvDataDirs of this fileName&#39;s data directory.
<i class="no-highlight">671</i>&nbsp;     * -1 if multiple data directories are not being used.
<i class="no-highlight">672</i>&nbsp;     */
<i class="no-highlight">673</i>&nbsp;    private int getDataDirIndexFromName(String fileName) {
<b class="nc"><i class="no-highlight">674</i>&nbsp;        if (nDataDirs == 0) {</b>
<b class="nc"><i class="no-highlight">675</i>&nbsp;            return -1;</b>
<i class="no-highlight">676</i>&nbsp;        }
<i class="no-highlight">677</i>&nbsp;
<b class="nc"><i class="no-highlight">678</i>&nbsp;        int dataDirEnd = fileName.lastIndexOf(File.separator);</b>
<b class="nc"><i class="no-highlight">679</i>&nbsp;        String dataDir = fileName.substring(0, dataDirEnd);</b>
<b class="nc"><i class="no-highlight">680</i>&nbsp;        return Integer.valueOf</b>
<b class="nc"><i class="no-highlight">681</i>&nbsp;            (Integer.parseInt(dataDir.substring(&quot;data&quot;.length())));</b>
<i class="no-highlight">682</i>&nbsp;    }
<i class="no-highlight">683</i>&nbsp;
<i class="no-highlight">684</i>&nbsp;    /**
<i class="no-highlight">685</i>&nbsp;     * Get the file number from a file name.
<i class="no-highlight">686</i>&nbsp;     *
<i class="no-highlight">687</i>&nbsp;     * @param fileName the file name
<i class="no-highlight">688</i>&nbsp;     * @return the file number
<i class="no-highlight">689</i>&nbsp;     */
<i class="no-highlight">690</i>&nbsp;    public Long getNumFromName(String fileName) {
<b class="fc"><i class="no-highlight">691</i>&nbsp;        String name = fileName;</b>
<b class="fc"><i class="no-highlight">692</i>&nbsp;        if (nDataDirs != 0) {</b>
<b class="nc"><i class="no-highlight">693</i>&nbsp;            name = name.substring(name.lastIndexOf(File.separator) + 1);</b>
<i class="no-highlight">694</i>&nbsp;        }
<b class="fc"><i class="no-highlight">695</i>&nbsp;        String fileNumber = name.substring(0, name.indexOf(&quot;.&quot;));</b>
<b class="fc"><i class="no-highlight">696</i>&nbsp;        return Long.valueOf(Long.parseLong(fileNumber, 16));</b>
<i class="no-highlight">697</i>&nbsp;    }
<i class="no-highlight">698</i>&nbsp;
<i class="no-highlight">699</i>&nbsp;    /**
<i class="no-highlight">700</i>&nbsp;     * Find JE files. Return names sorted in ascending fashion.
<i class="no-highlight">701</i>&nbsp;     * @param suffixes which type of file we&#39;re looking for
<i class="no-highlight">702</i>&nbsp;     * @return array of file names
<i class="no-highlight">703</i>&nbsp;     *
<i class="no-highlight">704</i>&nbsp;     * Used by unit tests so package protection.
<i class="no-highlight">705</i>&nbsp;     */
<i class="no-highlight">706</i>&nbsp;    String[] listFileNames(String[] suffixes) {
<b class="fc"><i class="no-highlight">707</i>&nbsp;        JEFileFilter fileFilter = new JEFileFilter(suffixes);</b>
<b class="fc"><i class="no-highlight">708</i>&nbsp;        return listFileNamesInternal(fileFilter);</b>
<i class="no-highlight">709</i>&nbsp;    }
<i class="no-highlight">710</i>&nbsp;
<i class="no-highlight">711</i>&nbsp;    /**
<i class="no-highlight">712</i>&nbsp;     * Find .jdb files which are &gt;= the minimimum file number and
<i class="no-highlight">713</i>&nbsp;     * &lt;= the maximum file number.
<i class="no-highlight">714</i>&nbsp;     * Return names sorted in ascending fashion.
<i class="no-highlight">715</i>&nbsp;     *
<i class="no-highlight">716</i>&nbsp;     * @return array of file names
<i class="no-highlight">717</i>&nbsp;     */
<i class="no-highlight">718</i>&nbsp;    public String[] listFileNames(long minFileNumber, long maxFileNumber) {
<b class="nc"><i class="no-highlight">719</i>&nbsp;        JEFileFilter fileFilter =</b>
<i class="no-highlight">720</i>&nbsp;            new JEFileFilter(JE_SUFFIXES, minFileNumber, maxFileNumber);
<b class="nc"><i class="no-highlight">721</i>&nbsp;        return listFileNamesInternal(fileFilter);</b>
<i class="no-highlight">722</i>&nbsp;    }
<i class="no-highlight">723</i>&nbsp;
<b class="fc"><i class="no-highlight">724</i>&nbsp;    private static Comparator&lt;File&gt; fileComparator =</b>
<b class="fc"><i class="no-highlight">725</i>&nbsp;        new Comparator&lt;File&gt;() {</b>
<i class="no-highlight">726</i>&nbsp;
<i class="no-highlight">727</i>&nbsp;        private String getFileNum(File file) {
<b class="nc"><i class="no-highlight">728</i>&nbsp;            String fname = file.toString();</b>
<b class="nc"><i class="no-highlight">729</i>&nbsp;            return fname.substring(fname.indexOf(File.separator) + 1);</b>
<i class="no-highlight">730</i>&nbsp;        }
<i class="no-highlight">731</i>&nbsp;
<i class="no-highlight">732</i>&nbsp;        public int compare(File o1, File o2) {
<b class="nc"><i class="no-highlight">733</i>&nbsp;            String fnum1 = getFileNum(o1);</b>
<b class="nc"><i class="no-highlight">734</i>&nbsp;            String fnum2 = getFileNum(o2);</b>
<b class="nc"><i class="no-highlight">735</i>&nbsp;            return o1.compareTo(o2);</b>
<i class="no-highlight">736</i>&nbsp;        }
<i class="no-highlight">737</i>&nbsp;    };
<i class="no-highlight">738</i>&nbsp;
<b class="fc"><i class="no-highlight">739</i>&nbsp;    private static Comparator&lt;String&gt; stringComparator =</b>
<b class="fc"><i class="no-highlight">740</i>&nbsp;        new Comparator&lt;String&gt;() {</b>
<i class="no-highlight">741</i>&nbsp;
<i class="no-highlight">742</i>&nbsp;        private String getFileNum(String fname) {
<b class="nc"><i class="no-highlight">743</i>&nbsp;            return fname.substring(fname.indexOf(File.separator) + 1);</b>
<i class="no-highlight">744</i>&nbsp;        }
<i class="no-highlight">745</i>&nbsp;
<i class="no-highlight">746</i>&nbsp;        public int compare(String o1, String o2) {
<b class="nc"><i class="no-highlight">747</i>&nbsp;            String fnum1 = getFileNum(o1);</b>
<b class="nc"><i class="no-highlight">748</i>&nbsp;            String fnum2 = getFileNum(o2);</b>
<b class="nc"><i class="no-highlight">749</i>&nbsp;            return fnum1.compareTo(fnum2);</b>
<i class="no-highlight">750</i>&nbsp;        }
<i class="no-highlight">751</i>&nbsp;    };
<i class="no-highlight">752</i>&nbsp;
<i class="no-highlight">753</i>&nbsp;    /**
<i class="no-highlight">754</i>&nbsp;     * Find JE files, flavor for unit test support.
<i class="no-highlight">755</i>&nbsp;     *
<i class="no-highlight">756</i>&nbsp;     * @param suffixes which type of file we&#39;re looking for
<i class="no-highlight">757</i>&nbsp;     * @return array of file names
<i class="no-highlight">758</i>&nbsp;     */
<i class="no-highlight">759</i>&nbsp;    public static String[] listFiles(File envDirFile,
<i class="no-highlight">760</i>&nbsp;                                     String[] suffixes,
<i class="no-highlight">761</i>&nbsp;                                     boolean envMultiSubDir) {
<b class="nc"><i class="no-highlight">762</i>&nbsp;        String[] names = envDirFile.list(new JEFileFilter(suffixes));</b>
<i class="no-highlight">763</i>&nbsp;
<b class="nc"><i class="no-highlight">764</i>&nbsp;        ArrayList&lt;String&gt; subFileNames = new ArrayList&lt;String&gt;();</b>
<b class="nc"><i class="no-highlight">765</i>&nbsp;        if (envMultiSubDir) {</b>
<b class="nc"><i class="no-highlight">766</i>&nbsp;            for (File file : envDirFile.listFiles()) {</b>
<b class="nc"><i class="no-highlight">767</i>&nbsp;                if (file.isDirectory() &amp;&amp; file.getName().startsWith(&quot;data&quot;)) {</b>
<b class="nc"><i class="no-highlight">768</i>&nbsp;                    File[] subFiles =</b>
<b class="nc"><i class="no-highlight">769</i>&nbsp;                        file.listFiles(new JEFileFilter(suffixes));</b>
<b class="nc"><i class="no-highlight">770</i>&nbsp;                    for (File subFile : subFiles) {</b>
<b class="nc"><i class="no-highlight">771</i>&nbsp;                        subFileNames.add(file.getName() +</b>
<b class="nc"><i class="no-highlight">772</i>&nbsp;                                         File.separator + subFile.getName());</b>
<i class="no-highlight">773</i>&nbsp;                    }
<i class="no-highlight">774</i>&nbsp;                }
<i class="no-highlight">775</i>&nbsp;            }
<i class="no-highlight">776</i>&nbsp;
<b class="nc"><i class="no-highlight">777</i>&nbsp;            String[] totalFileNames =</b>
<b class="nc"><i class="no-highlight">778</i>&nbsp;                new String[names.length + subFileNames.size()];</b>
<b class="nc"><i class="no-highlight">779</i>&nbsp;            for (int i = 0; i &lt; totalFileNames.length; i++) {</b>
<b class="nc"><i class="no-highlight">780</i>&nbsp;                if (i &lt; names.length) {</b>
<b class="nc"><i class="no-highlight">781</i>&nbsp;                    totalFileNames[i] = names[i];</b>
<i class="no-highlight">782</i>&nbsp;                } else {
<b class="nc"><i class="no-highlight">783</i>&nbsp;                    totalFileNames[i] = subFileNames.get(i - names.length);</b>
<i class="no-highlight">784</i>&nbsp;                }
<i class="no-highlight">785</i>&nbsp;            }
<b class="nc"><i class="no-highlight">786</i>&nbsp;            names = totalFileNames;</b>
<i class="no-highlight">787</i>&nbsp;        }
<i class="no-highlight">788</i>&nbsp;
<b class="nc"><i class="no-highlight">789</i>&nbsp;        if (names != null) {</b>
<b class="nc"><i class="no-highlight">790</i>&nbsp;            Arrays.sort(names, stringComparator);</b>
<i class="no-highlight">791</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">792</i>&nbsp;            names = new String[0];</b>
<i class="no-highlight">793</i>&nbsp;        }
<i class="no-highlight">794</i>&nbsp;
<b class="nc"><i class="no-highlight">795</i>&nbsp;        return names;</b>
<i class="no-highlight">796</i>&nbsp;    }
<i class="no-highlight">797</i>&nbsp;
<i class="no-highlight">798</i>&nbsp;    public File[] listJDBFiles() {
<b class="nc"><i class="no-highlight">799</i>&nbsp;        if (nDataDirs == 0) {</b>
<b class="nc"><i class="no-highlight">800</i>&nbsp;            return listJDBFilesInternalSingleDir(new JEFileFilter(JE_SUFFIXES));</b>
<i class="no-highlight">801</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">802</i>&nbsp;            return listJDBFilesInternalMultiDir(new JEFileFilter(JE_SUFFIXES));</b>
<i class="no-highlight">803</i>&nbsp;        }
<i class="no-highlight">804</i>&nbsp;    }
<i class="no-highlight">805</i>&nbsp;
<i class="no-highlight">806</i>&nbsp;    public File[] listJDBFilesInternalSingleDir(JEFileFilter fileFilter) {
<b class="nc"><i class="no-highlight">807</i>&nbsp;        File[] files = dbEnvHome.listFiles(fileFilter);</b>
<b class="nc"><i class="no-highlight">808</i>&nbsp;        if (files != null) {</b>
<b class="nc"><i class="no-highlight">809</i>&nbsp;            Arrays.sort(files);</b>
<i class="no-highlight">810</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">811</i>&nbsp;            files = new File[0];</b>
<i class="no-highlight">812</i>&nbsp;        }
<i class="no-highlight">813</i>&nbsp;
<b class="nc"><i class="no-highlight">814</i>&nbsp;        return files;</b>
<i class="no-highlight">815</i>&nbsp;    }
<i class="no-highlight">816</i>&nbsp;
<i class="no-highlight">817</i>&nbsp;    public File[] listJDBFilesInternalMultiDir(JEFileFilter fileFilter) {
<b class="nc"><i class="no-highlight">818</i>&nbsp;        File[][] files = new File[nDataDirs][];</b>
<b class="nc"><i class="no-highlight">819</i>&nbsp;        int nTotalFiles = 0;</b>
<b class="nc"><i class="no-highlight">820</i>&nbsp;        int i = 0;</b>
<b class="nc"><i class="no-highlight">821</i>&nbsp;        for (File envDir : dbEnvDataDirs) {</b>
<b class="nc"><i class="no-highlight">822</i>&nbsp;            files[i] = envDir.listFiles(fileFilter);</b>
<b class="nc"><i class="no-highlight">823</i>&nbsp;            nTotalFiles += files[i].length;</b>
<b class="nc"><i class="no-highlight">824</i>&nbsp;            i++;</b>
<i class="no-highlight">825</i>&nbsp;        }
<i class="no-highlight">826</i>&nbsp;
<b class="nc"><i class="no-highlight">827</i>&nbsp;        if (nTotalFiles == 0) {</b>
<b class="nc"><i class="no-highlight">828</i>&nbsp;            return new File[0];</b>
<i class="no-highlight">829</i>&nbsp;        }
<i class="no-highlight">830</i>&nbsp;
<b class="nc"><i class="no-highlight">831</i>&nbsp;        File[] ret = new File[nTotalFiles];</b>
<b class="nc"><i class="no-highlight">832</i>&nbsp;        i = 0;</b>
<b class="nc"><i class="no-highlight">833</i>&nbsp;        for (File[] envFiles : files) {</b>
<b class="nc"><i class="no-highlight">834</i>&nbsp;            for (File envFile : envFiles) {</b>
<b class="nc"><i class="no-highlight">835</i>&nbsp;                ret[i++] = envFile;</b>
<i class="no-highlight">836</i>&nbsp;            }
<i class="no-highlight">837</i>&nbsp;        }
<i class="no-highlight">838</i>&nbsp;
<b class="nc"><i class="no-highlight">839</i>&nbsp;        Arrays.sort(ret, fileComparator);</b>
<b class="nc"><i class="no-highlight">840</i>&nbsp;        return ret;</b>
<i class="no-highlight">841</i>&nbsp;    }
<i class="no-highlight">842</i>&nbsp;
<i class="no-highlight">843</i>&nbsp;    private String[] listFileNamesInternal(JEFileFilter fileFilter) {
<b class="fc"><i class="no-highlight">844</i>&nbsp;        if (nDataDirs == 0) {</b>
<b class="fc"><i class="no-highlight">845</i>&nbsp;            return listFileNamesInternalSingleDir(fileFilter);</b>
<i class="no-highlight">846</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">847</i>&nbsp;            return listFileNamesInternalMultiDirs(fileFilter);</b>
<i class="no-highlight">848</i>&nbsp;        }
<i class="no-highlight">849</i>&nbsp;    }
<i class="no-highlight">850</i>&nbsp;
<i class="no-highlight">851</i>&nbsp;    private String[] listFileNamesInternalSingleDir(JEFileFilter fileFilter) {
<b class="fc"><i class="no-highlight">852</i>&nbsp;        String[] fileNames = dbEnvHome.list(fileFilter);</b>
<b class="fc"><i class="no-highlight">853</i>&nbsp;        if (fileNames != null) {</b>
<b class="fc"><i class="no-highlight">854</i>&nbsp;            Arrays.sort(fileNames);</b>
<i class="no-highlight">855</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">856</i>&nbsp;            fileNames = new String[0];</b>
<i class="no-highlight">857</i>&nbsp;        }
<b class="fc"><i class="no-highlight">858</i>&nbsp;        return fileNames;</b>
<i class="no-highlight">859</i>&nbsp;    }
<i class="no-highlight">860</i>&nbsp;
<i class="no-highlight">861</i>&nbsp;    private String[] listFileNamesInternalMultiDirs(JEFileFilter filter) {
<b class="nc"><i class="no-highlight">862</i>&nbsp;        String[][] files = new String[nDataDirs][];</b>
<b class="nc"><i class="no-highlight">863</i>&nbsp;        int nTotalFiles = 0;</b>
<b class="nc"><i class="no-highlight">864</i>&nbsp;        int i = 0;</b>
<b class="nc"><i class="no-highlight">865</i>&nbsp;        for (File envDir : dbEnvDataDirs) {</b>
<b class="nc"><i class="no-highlight">866</i>&nbsp;            files[i] = envDir.list(filter);</b>
<i class="no-highlight">867</i>&nbsp;
<b class="nc"><i class="no-highlight">868</i>&nbsp;            String envDirName = envDir.toString();</b>
<b class="nc"><i class="no-highlight">869</i>&nbsp;            String dataDirName = envDirName.</b>
<b class="nc"><i class="no-highlight">870</i>&nbsp;                substring(envDirName.lastIndexOf(File.separator) + 1);</b>
<i class="no-highlight">871</i>&nbsp;
<b class="nc"><i class="no-highlight">872</i>&nbsp;            for (int j = 0; j &lt; files[i].length; j += 1) {</b>
<b class="nc"><i class="no-highlight">873</i>&nbsp;                files[i][j] = dataDirName + File.separator + files[i][j];</b>
<i class="no-highlight">874</i>&nbsp;            }
<i class="no-highlight">875</i>&nbsp;
<b class="nc"><i class="no-highlight">876</i>&nbsp;            nTotalFiles += files[i].length;</b>
<b class="nc"><i class="no-highlight">877</i>&nbsp;            i++;</b>
<i class="no-highlight">878</i>&nbsp;        }
<i class="no-highlight">879</i>&nbsp;
<b class="nc"><i class="no-highlight">880</i>&nbsp;        if (nTotalFiles == 0) {</b>
<b class="nc"><i class="no-highlight">881</i>&nbsp;            return new String[0];</b>
<i class="no-highlight">882</i>&nbsp;        }
<i class="no-highlight">883</i>&nbsp;
<b class="nc"><i class="no-highlight">884</i>&nbsp;        String[] ret = new String[nTotalFiles];</b>
<b class="nc"><i class="no-highlight">885</i>&nbsp;        i = 0;</b>
<b class="nc"><i class="no-highlight">886</i>&nbsp;        for (String[] envFiles : files) {</b>
<b class="nc"><i class="no-highlight">887</i>&nbsp;            for (String envFile : envFiles) {</b>
<b class="nc"><i class="no-highlight">888</i>&nbsp;                ret[i++] = envFile;</b>
<i class="no-highlight">889</i>&nbsp;            }
<i class="no-highlight">890</i>&nbsp;        }
<i class="no-highlight">891</i>&nbsp;
<b class="nc"><i class="no-highlight">892</i>&nbsp;        Arrays.sort(ret, stringComparator);</b>
<b class="nc"><i class="no-highlight">893</i>&nbsp;        return ret;</b>
<i class="no-highlight">894</i>&nbsp;    }
<i class="no-highlight">895</i>&nbsp;
<i class="no-highlight">896</i>&nbsp;    private void checkNoDataDirs() {
<b class="fc"><i class="no-highlight">897</i>&nbsp;        String[] dataDirNames =</b>
<b class="fc"><i class="no-highlight">898</i>&nbsp;            dbEnvHome.list(new FilenameFilter() {</b>
<i class="no-highlight">899</i>&nbsp;                    public boolean accept(File dir, String name) {
<i class="no-highlight">900</i>&nbsp;                        /* We&#39;ll validate the subdirNum later. */
<b class="fc"><i class="no-highlight">901</i>&nbsp;                        return name != null &amp;&amp;</b>
<b class="fc"><i class="no-highlight">902</i>&nbsp;                            name.length() == &quot;dataNNN&quot;.length() &amp;&amp;</b>
<b class="nc"><i class="no-highlight">903</i>&nbsp;                            name.startsWith(&quot;data&quot;);</b>
<i class="no-highlight">904</i>&nbsp;                    }
<i class="no-highlight">905</i>&nbsp;                }
<i class="no-highlight">906</i>&nbsp;                );
<b class="fc"><i class="no-highlight">907</i>&nbsp;        if (dataDirNames != null &amp;&amp; dataDirNames.length != 0) {</b>
<b class="nc"><i class="no-highlight">908</i>&nbsp;            throw EnvironmentFailureException.unexpectedState</b>
<b class="nc"><i class="no-highlight">909</i>&nbsp;                (EnvironmentParams.LOG_N_DATA_DIRECTORIES.getName() +</b>
<i class="no-highlight">910</i>&nbsp;                 &quot; was not set and expected to find no&quot; +
<i class="no-highlight">911</i>&nbsp;                 &quot; data directories, but found &quot; +
<i class="no-highlight">912</i>&nbsp;                 dataDirNames.length + &quot; data directories instead.&quot;);
<i class="no-highlight">913</i>&nbsp;        }
<b class="fc"><i class="no-highlight">914</i>&nbsp;    }</b>
<i class="no-highlight">915</i>&nbsp;
<i class="no-highlight">916</i>&nbsp;    public File[] gatherDataDirs() {
<b class="nc"><i class="no-highlight">917</i>&nbsp;        String[] dataDirNames =</b>
<b class="nc"><i class="no-highlight">918</i>&nbsp;            dbEnvHome.list(new FilenameFilter() {</b>
<i class="no-highlight">919</i>&nbsp;                    public boolean accept(File dir, String name) {
<i class="no-highlight">920</i>&nbsp;                        /* We&#39;ll validate the subdirNum later. */
<b class="nc"><i class="no-highlight">921</i>&nbsp;                        return name != null &amp;&amp;</b>
<b class="nc"><i class="no-highlight">922</i>&nbsp;                            name.length() == &quot;dataNNN&quot;.length() &amp;&amp;</b>
<b class="nc"><i class="no-highlight">923</i>&nbsp;                            name.startsWith(&quot;data&quot;);</b>
<i class="no-highlight">924</i>&nbsp;                    }
<i class="no-highlight">925</i>&nbsp;                }
<i class="no-highlight">926</i>&nbsp;                );
<b class="nc"><i class="no-highlight">927</i>&nbsp;        if (dataDirNames != null) {</b>
<b class="nc"><i class="no-highlight">928</i>&nbsp;            Arrays.sort(dataDirNames);</b>
<i class="no-highlight">929</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">930</i>&nbsp;            dataDirNames = new String[0];</b>
<i class="no-highlight">931</i>&nbsp;        }
<i class="no-highlight">932</i>&nbsp;
<b class="nc"><i class="no-highlight">933</i>&nbsp;        if (dataDirNames.length != nDataDirs) {</b>
<b class="nc"><i class="no-highlight">934</i>&nbsp;            throw EnvironmentFailureException.unexpectedState</b>
<b class="nc"><i class="no-highlight">935</i>&nbsp;                (EnvironmentParams.LOG_N_DATA_DIRECTORIES.getName() +</b>
<i class="no-highlight">936</i>&nbsp;                 &quot; was set and expected to find &quot; + nDataDirs +
<i class="no-highlight">937</i>&nbsp;                 &quot; data directories, but found &quot; +
<i class="no-highlight">938</i>&nbsp;                 dataDirNames.length + &quot; instead.&quot;);
<i class="no-highlight">939</i>&nbsp;        }
<i class="no-highlight">940</i>&nbsp;
<b class="nc"><i class="no-highlight">941</i>&nbsp;        int ddNum = 1;</b>
<b class="nc"><i class="no-highlight">942</i>&nbsp;        File[] dataDirs = new File[nDataDirs];</b>
<b class="nc"><i class="no-highlight">943</i>&nbsp;        for (String fn : dataDirNames) {</b>
<b class="nc"><i class="no-highlight">944</i>&nbsp;            String subdirNumStr = fn.substring(4);</b>
<i class="no-highlight">945</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">946</i>&nbsp;                int subdirNum = Integer.parseInt(subdirNumStr);</b>
<b class="nc"><i class="no-highlight">947</i>&nbsp;                if (subdirNum != ddNum) {</b>
<b class="nc"><i class="no-highlight">948</i>&nbsp;                    throw EnvironmentFailureException.unexpectedState</b>
<b class="nc"><i class="no-highlight">949</i>&nbsp;                        (&quot;Expected to find data subdir: data&quot; +</b>
<b class="nc"><i class="no-highlight">950</i>&nbsp;                         paddedDirNum(ddNum) +</b>
<i class="no-highlight">951</i>&nbsp;                         &quot; but found data&quot; +
<i class="no-highlight">952</i>&nbsp;                         subdirNumStr + &quot; instead.&quot;);
<i class="no-highlight">953</i>&nbsp;
<i class="no-highlight">954</i>&nbsp;                }
<i class="no-highlight">955</i>&nbsp;
<b class="nc"><i class="no-highlight">956</i>&nbsp;                File dataDir = new File(dbEnvHome, fn);</b>
<b class="nc"><i class="no-highlight">957</i>&nbsp;                if (!dataDir.exists()) {</b>
<b class="nc"><i class="no-highlight">958</i>&nbsp;                    throw EnvironmentFailureException.unexpectedState</b>
<b class="nc"><i class="no-highlight">959</i>&nbsp;                        (&quot;Data dir: &quot; + dataDir + &quot; doesn&#39;t exist.&quot;);</b>
<i class="no-highlight">960</i>&nbsp;                }
<b class="nc"><i class="no-highlight">961</i>&nbsp;                if (!dataDir.isDirectory()) {</b>
<b class="nc"><i class="no-highlight">962</i>&nbsp;                    throw EnvironmentFailureException.unexpectedState</b>
<b class="nc"><i class="no-highlight">963</i>&nbsp;                        (&quot;Data dir: &quot; + dataDir + &quot; is not a directory.&quot;);</b>
<i class="no-highlight">964</i>&nbsp;                }
<b class="nc"><i class="no-highlight">965</i>&nbsp;                dataDirs[ddNum - 1] = dataDir;</b>
<b class="nc"><i class="no-highlight">966</i>&nbsp;            } catch (NumberFormatException E) {</b>
<b class="nc"><i class="no-highlight">967</i>&nbsp;                    throw EnvironmentFailureException.unexpectedState</b>
<b class="nc"><i class="no-highlight">968</i>&nbsp;                        (&quot;Illegal data subdir: data&quot; + subdirNumStr);</b>
<b class="nc"><i class="no-highlight">969</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">970</i>&nbsp;            ddNum++;</b>
<i class="no-highlight">971</i>&nbsp;        }
<b class="nc"><i class="no-highlight">972</i>&nbsp;        return dataDirs;</b>
<i class="no-highlight">973</i>&nbsp;    }
<i class="no-highlight">974</i>&nbsp;
<i class="no-highlight">975</i>&nbsp;    private String paddedDirNum(int dirNum) {
<b class="nc"><i class="no-highlight">976</i>&nbsp;        String paddedStr = &quot;000&quot; + dirNum;</b>
<b class="nc"><i class="no-highlight">977</i>&nbsp;        int len = paddedStr.length();</b>
<b class="nc"><i class="no-highlight">978</i>&nbsp;        return paddedStr.substring(len - 3);</b>
<i class="no-highlight">979</i>&nbsp;    }
<i class="no-highlight">980</i>&nbsp;
<i class="no-highlight">981</i>&nbsp;    /**
<i class="no-highlight">982</i>&nbsp;     * @return the full file name and path for the nth JE file.
<i class="no-highlight">983</i>&nbsp;     */
<i class="no-highlight">984</i>&nbsp;    String[] getFullFileNames(long fileNum) {
<b class="fc"><i class="no-highlight">985</i>&nbsp;        if (includeDeletedFiles) {</b>
<b class="nc"><i class="no-highlight">986</i>&nbsp;            int nSuffixes = JE_AND_DEL_SUFFIXES.length;</b>
<b class="nc"><i class="no-highlight">987</i>&nbsp;            String[] ret = new String[nSuffixes];</b>
<b class="nc"><i class="no-highlight">988</i>&nbsp;            for (int i = 0; i &lt; nSuffixes; i++) {</b>
<b class="nc"><i class="no-highlight">989</i>&nbsp;                ret[i] = getFullFileName(fileNum, JE_AND_DEL_SUFFIXES[i]);</b>
<i class="no-highlight">990</i>&nbsp;            }
<b class="nc"><i class="no-highlight">991</i>&nbsp;            return ret;</b>
<i class="no-highlight">992</i>&nbsp;        }
<b class="fc"><i class="no-highlight">993</i>&nbsp;        return new String[] { getFullFileName(fileNum, JE_SUFFIX) };</b>
<i class="no-highlight">994</i>&nbsp;    }
<i class="no-highlight">995</i>&nbsp;
<i class="no-highlight">996</i>&nbsp;    private File getDataDir(long fileNum) {
<b class="fc"><i class="no-highlight">997</i>&nbsp;        return (nDataDirs == 0) ?</b>
<i class="no-highlight">998</i>&nbsp;            dbEnvHome :
<i class="no-highlight">999</i>&nbsp;            dbEnvDataDirs[((int) (fileNum % nDataDirs))];
<i class="no-highlight">1000</i>&nbsp;    }
<i class="no-highlight">1001</i>&nbsp;
<i class="no-highlight">1002</i>&nbsp;    public String getFullFileName(long fileNum) {
<b class="fc"><i class="no-highlight">1003</i>&nbsp;        return getFullFileName(fileNum, JE_SUFFIX);</b>
<i class="no-highlight">1004</i>&nbsp;    }
<i class="no-highlight">1005</i>&nbsp;
<i class="no-highlight">1006</i>&nbsp;    /**
<i class="no-highlight">1007</i>&nbsp;     * @return the full file name and path for this file name.
<i class="no-highlight">1008</i>&nbsp;     */
<i class="no-highlight">1009</i>&nbsp;    public String getFullFileName(long fileNum, String suffix) {
<b class="fc"><i class="no-highlight">1010</i>&nbsp;        File dbEnvDataDir = getDataDir(fileNum);</b>
<b class="fc"><i class="no-highlight">1011</i>&nbsp;        return dbEnvDataDir + File.separator + getFileName(fileNum, suffix);</b>
<i class="no-highlight">1012</i>&nbsp;    }
<i class="no-highlight">1013</i>&nbsp;
<i class="no-highlight">1014</i>&nbsp;    /**
<i class="no-highlight">1015</i>&nbsp;     * @return the file name relative to the env home directory.
<i class="no-highlight">1016</i>&nbsp;     */
<i class="no-highlight">1017</i>&nbsp;    public String getPartialFileName(long fileNum) {
<b class="nc"><i class="no-highlight">1018</i>&nbsp;        String name = getFileName(fileNum, JE_SUFFIX);</b>
<b class="nc"><i class="no-highlight">1019</i>&nbsp;        if (nDataDirs == 0) {</b>
<b class="nc"><i class="no-highlight">1020</i>&nbsp;            return name;</b>
<i class="no-highlight">1021</i>&nbsp;        }
<b class="nc"><i class="no-highlight">1022</i>&nbsp;        File dataDir = getDataDir(fileNum);</b>
<b class="nc"><i class="no-highlight">1023</i>&nbsp;        return dataDir.getName() + File.separator + name;</b>
<i class="no-highlight">1024</i>&nbsp;    }
<i class="no-highlight">1025</i>&nbsp;
<i class="no-highlight">1026</i>&nbsp;    /*
<i class="no-highlight">1027</i>&nbsp;     * Return the full file name of a specified log file name, including the
<i class="no-highlight">1028</i>&nbsp;     * sub directories names if needed.
<i class="no-highlight">1029</i>&nbsp;     */
<i class="no-highlight">1030</i>&nbsp;    public String getFullFileName(String fileName) {
<b class="nc"><i class="no-highlight">1031</i>&nbsp;        final int suffixStartPos = fileName.indexOf(&quot;.&quot;);</b>
<b class="nc"><i class="no-highlight">1032</i>&nbsp;        String suffix = fileName.substring(suffixStartPos, fileName.length());</b>
<b class="nc"><i class="no-highlight">1033</i>&nbsp;        assert suffix != null;</b>
<b class="nc"><i class="no-highlight">1034</i>&nbsp;        String fileNum = fileName.substring(0, suffixStartPos);</b>
<i class="no-highlight">1035</i>&nbsp;
<b class="nc"><i class="no-highlight">1036</i>&nbsp;        return getFullFileName</b>
<b class="nc"><i class="no-highlight">1037</i>&nbsp;            (Long.valueOf(Long.parseLong(fileNum, 16)), suffix);</b>
<i class="no-highlight">1038</i>&nbsp;    }
<i class="no-highlight">1039</i>&nbsp;
<i class="no-highlight">1040</i>&nbsp;    /**
<i class="no-highlight">1041</i>&nbsp;     * @return the file name for the nth file.
<i class="no-highlight">1042</i>&nbsp;     */
<i class="no-highlight">1043</i>&nbsp;    public static String getFileName(long fileNum, String suffix) {
<b class="fc"><i class="no-highlight">1044</i>&nbsp;        return (getFileNumberString(fileNum) + suffix);</b>
<i class="no-highlight">1045</i>&nbsp;    }
<i class="no-highlight">1046</i>&nbsp;
<i class="no-highlight">1047</i>&nbsp;    /** @return the file name for the nth log (*.jdb) file. */
<i class="no-highlight">1048</i>&nbsp;    public static String getFileName(long fileNum) {
<b class="nc"><i class="no-highlight">1049</i>&nbsp;        return getFileName(fileNum, JE_SUFFIX);</b>
<i class="no-highlight">1050</i>&nbsp;    }
<i class="no-highlight">1051</i>&nbsp;
<i class="no-highlight">1052</i>&nbsp;    /**
<i class="no-highlight">1053</i>&nbsp;     * HexFormatter generates a 0 padded string starting with 0x.  We want
<i class="no-highlight">1054</i>&nbsp;     * the right most 8 digits, so start at 10.
<i class="no-highlight">1055</i>&nbsp;     */
<i class="no-highlight">1056</i>&nbsp;    private static String getFileNumberString(long fileNum) {
<b class="fc"><i class="no-highlight">1057</i>&nbsp;        return HexFormatter.formatLong(fileNum).substring(10);</b>
<i class="no-highlight">1058</i>&nbsp;    }
<i class="no-highlight">1059</i>&nbsp;
<i class="no-highlight">1060</i>&nbsp;    /**
<i class="no-highlight">1061</i>&nbsp;     * @return true if successful, false if File.renameTo returns false, which
<i class="no-highlight">1062</i>&nbsp;     * can occur on Windows if the file was recently closed.
<i class="no-highlight">1063</i>&nbsp;     */
<i class="no-highlight">1064</i>&nbsp;    public boolean renameFile(final long fileNum, final String newSuffix)
<i class="no-highlight">1065</i>&nbsp;        throws IOException, DatabaseException {
<i class="no-highlight">1066</i>&nbsp;
<b class="nc"><i class="no-highlight">1067</i>&nbsp;        return renameFile(fileNum, newSuffix, null) != null;</b>
<i class="no-highlight">1068</i>&nbsp;    }
<i class="no-highlight">1069</i>&nbsp;
<i class="no-highlight">1070</i>&nbsp;    /**
<i class="no-highlight">1071</i>&nbsp;     * Rename this file to NNNNNNNN.suffix. If that file already exists, try
<i class="no-highlight">1072</i>&nbsp;     * NNNNNNNN.suffix.1, etc. Used for deleting files or moving corrupt files
<i class="no-highlight">1073</i>&nbsp;     * aside.
<i class="no-highlight">1074</i>&nbsp;     *
<i class="no-highlight">1075</i>&nbsp;     * @param fileNum the file we want to move
<i class="no-highlight">1076</i>&nbsp;     *
<i class="no-highlight">1077</i>&nbsp;     * @param newSuffix the new file suffix
<i class="no-highlight">1078</i>&nbsp;     *
<i class="no-highlight">1079</i>&nbsp;     * @param subDir the data directory sub-directory to rename the file into.
<i class="no-highlight">1080</i>&nbsp;     * The subDir must already exist. May be null to leave the file in its
<i class="no-highlight">1081</i>&nbsp;     * current data directory.
<i class="no-highlight">1082</i>&nbsp;     *
<i class="no-highlight">1083</i>&nbsp;     * @return renamed File if successful, or null if File.renameTo returns
<i class="no-highlight">1084</i>&nbsp;     * false, which can occur on Windows if the file was recently closed.
<i class="no-highlight">1085</i>&nbsp;     */
<i class="no-highlight">1086</i>&nbsp;    public File renameFile(final long fileNum,
<i class="no-highlight">1087</i>&nbsp;                           final String newSuffix,
<i class="no-highlight">1088</i>&nbsp;                           final String subDir)
<i class="no-highlight">1089</i>&nbsp;        throws IOException {
<i class="no-highlight">1090</i>&nbsp;
<b class="nc"><i class="no-highlight">1091</i>&nbsp;        final File oldDir = getDataDir(fileNum);</b>
<b class="nc"><i class="no-highlight">1092</i>&nbsp;        final String oldName = getFileName(fileNum);</b>
<b class="nc"><i class="no-highlight">1093</i>&nbsp;        final File oldFile = new File(oldDir, oldName);</b>
<i class="no-highlight">1094</i>&nbsp;
<b class="nc"><i class="no-highlight">1095</i>&nbsp;        final File newDir =</b>
<i class="no-highlight">1096</i>&nbsp;            (subDir != null) ? (new File(oldDir, subDir)) : oldDir;
<i class="no-highlight">1097</i>&nbsp;
<b class="nc"><i class="no-highlight">1098</i>&nbsp;        final String newName = getFileName(fileNum, newSuffix);</b>
<i class="no-highlight">1099</i>&nbsp;
<b class="nc"><i class="no-highlight">1100</i>&nbsp;        String generation = &quot;&quot;;</b>
<b class="nc"><i class="no-highlight">1101</i>&nbsp;        int repeatNum = 0;</b>
<i class="no-highlight">1102</i>&nbsp;
<i class="no-highlight">1103</i>&nbsp;        while (true) {
<b class="nc"><i class="no-highlight">1104</i>&nbsp;            final File newFile = new File(newDir, newName + generation);</b>
<i class="no-highlight">1105</i>&nbsp;
<b class="nc"><i class="no-highlight">1106</i>&nbsp;            if (newFile.exists()) {</b>
<b class="nc"><i class="no-highlight">1107</i>&nbsp;                repeatNum++;</b>
<b class="nc"><i class="no-highlight">1108</i>&nbsp;                generation = &quot;.&quot; + repeatNum;</b>
<b class="nc"><i class="no-highlight">1109</i>&nbsp;                continue;</b>
<i class="no-highlight">1110</i>&nbsp;            }
<i class="no-highlight">1111</i>&nbsp;
<i class="no-highlight">1112</i>&nbsp;            /*
<i class="no-highlight">1113</i>&nbsp;             * If CLEANER_EXPUNGE is false, then the cleaner will rename
<i class="no-highlight">1114</i>&nbsp;             * the .jdb file. The rename action will first delete the
<i class="no-highlight">1115</i>&nbsp;             * old file and then create the new file. So we should also
<i class="no-highlight">1116</i>&nbsp;             * record the file rename action here.
<i class="no-highlight">1117</i>&nbsp;             */
<b class="nc"><i class="no-highlight">1118</i>&nbsp;            if (fdd != null) {</b>
<b class="nc"><i class="no-highlight">1119</i>&nbsp;                if (oldName.endsWith(FileManager.JE_SUFFIX)) {</b>
<b class="nc"><i class="no-highlight">1120</i>&nbsp;                    fdd.addDeletedFile(oldName);</b>
<i class="no-highlight">1121</i>&nbsp;                }
<i class="no-highlight">1122</i>&nbsp;            }
<i class="no-highlight">1123</i>&nbsp;
<b class="nc"><i class="no-highlight">1124</i>&nbsp;            clearFileCache(fileNum);</b>
<i class="no-highlight">1125</i>&nbsp;
<b class="nc"><i class="no-highlight">1126</i>&nbsp;            final boolean success = oldFile.renameTo(newFile);</b>
<b class="nc"><i class="no-highlight">1127</i>&nbsp;            return success ? newFile : null;</b>
<i class="no-highlight">1128</i>&nbsp;        }
<i class="no-highlight">1129</i>&nbsp;    }
<i class="no-highlight">1130</i>&nbsp;
<i class="no-highlight">1131</i>&nbsp;    /**
<i class="no-highlight">1132</i>&nbsp;     * Delete log file NNNNNNNN.
<i class="no-highlight">1133</i>&nbsp;     *
<i class="no-highlight">1134</i>&nbsp;     * @param fileNum the file we want to move
<i class="no-highlight">1135</i>&nbsp;     *
<i class="no-highlight">1136</i>&nbsp;     * @return true if successful, false if File.delete returns false, which
<i class="no-highlight">1137</i>&nbsp;     * can occur on Windows if the file was recently closed.
<i class="no-highlight">1138</i>&nbsp;     */
<i class="no-highlight">1139</i>&nbsp;    public boolean deleteFile(final long fileNum)
<i class="no-highlight">1140</i>&nbsp;        throws IOException, DatabaseException {
<i class="no-highlight">1141</i>&nbsp;
<b class="nc"><i class="no-highlight">1142</i>&nbsp;        final String fileName = getFullFileNames(fileNum)[0];</b>
<i class="no-highlight">1143</i>&nbsp;
<i class="no-highlight">1144</i>&nbsp;        /*
<i class="no-highlight">1145</i>&nbsp;         * Add files deleted by JE to filesDeletedByJE in fdd, which aims to
<i class="no-highlight">1146</i>&nbsp;         * check whether a deleted file is deleted by JE or by users wrongly.
<i class="no-highlight">1147</i>&nbsp;         *
<i class="no-highlight">1148</i>&nbsp;         * The file name gotten from WatchKey is the relative file name,
<i class="no-highlight">1149</i>&nbsp;         * so we should also get the relative file name here.
<i class="no-highlight">1150</i>&nbsp;         */
<b class="nc"><i class="no-highlight">1151</i>&nbsp;        if (fdd != null) {</b>
<b class="nc"><i class="no-highlight">1152</i>&nbsp;            if (fileName.endsWith(FileManager.JE_SUFFIX)) {</b>
<b class="nc"><i class="no-highlight">1153</i>&nbsp;                final int index = fileName.lastIndexOf(File.separator) + 1;</b>
<b class="nc"><i class="no-highlight">1154</i>&nbsp;                final String relativeFileName = fileName.substring(index);</b>
<b class="nc"><i class="no-highlight">1155</i>&nbsp;                fdd.addDeletedFile(relativeFileName);</b>
<i class="no-highlight">1156</i>&nbsp;            }
<i class="no-highlight">1157</i>&nbsp;        }
<i class="no-highlight">1158</i>&nbsp;
<b class="nc"><i class="no-highlight">1159</i>&nbsp;        clearFileCache(fileNum);</b>
<b class="nc"><i class="no-highlight">1160</i>&nbsp;        final File file = new File(fileName);</b>
<b class="nc"><i class="no-highlight">1161</i>&nbsp;        return file.delete();</b>
<i class="no-highlight">1162</i>&nbsp;    }
<i class="no-highlight">1163</i>&nbsp;
<i class="no-highlight">1164</i>&nbsp;    /**
<i class="no-highlight">1165</i>&nbsp;     * Returns the log version for the given file.
<i class="no-highlight">1166</i>&nbsp;     */
<i class="no-highlight">1167</i>&nbsp;    public int getFileLogVersion(long fileNum)
<i class="no-highlight">1168</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">1169</i>&nbsp;
<i class="no-highlight">1170</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">1171</i>&nbsp;            FileHandle handle = getFileHandle(fileNum);</b>
<b class="nc"><i class="no-highlight">1172</i>&nbsp;            int logVersion = handle.getLogVersion();</b>
<b class="nc"><i class="no-highlight">1173</i>&nbsp;            handle.release();</b>
<b class="nc"><i class="no-highlight">1174</i>&nbsp;            return logVersion;</b>
<b class="nc"><i class="no-highlight">1175</i>&nbsp;        } catch (FileNotFoundException e) {</b>
<b class="nc"><i class="no-highlight">1176</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">1177</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_FILE_NOT_FOUND, e);
<b class="nc"><i class="no-highlight">1178</i>&nbsp;        } catch (ChecksumException e) {</b>
<b class="nc"><i class="no-highlight">1179</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">1180</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_CHECKSUM, e);
<i class="no-highlight">1181</i>&nbsp;        }
<i class="no-highlight">1182</i>&nbsp;    }
<i class="no-highlight">1183</i>&nbsp;
<i class="no-highlight">1184</i>&nbsp;    /**
<i class="no-highlight">1185</i>&nbsp;     * Return a read only file handle that corresponds to this file number.
<i class="no-highlight">1186</i>&nbsp;     * Retrieve it from the cache or open it anew and validate the file header.
<i class="no-highlight">1187</i>&nbsp;     * This method takes a latch on this file, so that the file descriptor will
<i class="no-highlight">1188</i>&nbsp;     * be held in the cache as long as it&#39;s in use.  When the user is done with
<i class="no-highlight">1189</i>&nbsp;     * the file, the latch must be released.
<i class="no-highlight">1190</i>&nbsp;     *
<i class="no-highlight">1191</i>&nbsp;     * @param fileNum which file
<i class="no-highlight">1192</i>&nbsp;     * @return the file handle for the existing or newly created file
<i class="no-highlight">1193</i>&nbsp;     */
<i class="no-highlight">1194</i>&nbsp;    public FileHandle getFileHandle(long fileNum)
<i class="no-highlight">1195</i>&nbsp;        throws FileNotFoundException, ChecksumException, DatabaseException {
<i class="no-highlight">1196</i>&nbsp;
<i class="no-highlight">1197</i>&nbsp;        /* Check the file cache for this file. */
<b class="fc"><i class="no-highlight">1198</i>&nbsp;        Long fileId = Long.valueOf(fileNum);</b>
<b class="fc"><i class="no-highlight">1199</i>&nbsp;        FileHandle fileHandle = null;</b>
<i class="no-highlight">1200</i>&nbsp;
<i class="no-highlight">1201</i>&nbsp;        /**
<i class="no-highlight">1202</i>&nbsp;         * Loop until we get an open FileHandle.
<i class="no-highlight">1203</i>&nbsp;         */
<i class="no-highlight">1204</i>&nbsp;        try {
<i class="no-highlight">1205</i>&nbsp;            while (true) {
<i class="no-highlight">1206</i>&nbsp;
<i class="no-highlight">1207</i>&nbsp;                /*
<i class="no-highlight">1208</i>&nbsp;                 * The file cache is intentionally not latched here so that
<i class="no-highlight">1209</i>&nbsp;                 * it&#39;s not a bottleneck in the fast path.  We check that the
<i class="no-highlight">1210</i>&nbsp;                 * file handle that we get back is really still open after we
<i class="no-highlight">1211</i>&nbsp;                 * latch it down below.
<i class="no-highlight">1212</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">1213</i>&nbsp;                fileHandle = fileCache.get(fileId);</b>
<i class="no-highlight">1214</i>&nbsp;
<i class="no-highlight">1215</i>&nbsp;                /*
<i class="no-highlight">1216</i>&nbsp;                 * If the file isn&#39;t in the cache, latch the cache and check
<i class="no-highlight">1217</i>&nbsp;                 * again.  Under the latch, if the file is not in the cache we
<i class="no-highlight">1218</i>&nbsp;                 * add it to the cache but do not open the file yet.  We latch
<i class="no-highlight">1219</i>&nbsp;                 * the handle here, and open the file further below after
<i class="no-highlight">1220</i>&nbsp;                 * releasing the cache latch.  This prevents blocking other
<i class="no-highlight">1221</i>&nbsp;                 * threads that are opening other files while we open this
<i class="no-highlight">1222</i>&nbsp;                 * file.  The latch on the handle blocks other threads waiting
<i class="no-highlight">1223</i>&nbsp;                 * to open the same file, which is necessary.
<i class="no-highlight">1224</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">1225</i>&nbsp;                boolean newHandle = false;</b>
<b class="fc"><i class="no-highlight">1226</i>&nbsp;                if (fileHandle == null) {</b>
<b class="fc"><i class="no-highlight">1227</i>&nbsp;                    synchronized (fileCache) {</b>
<b class="fc"><i class="no-highlight">1228</i>&nbsp;                        fileHandle = fileCache.get(fileId);</b>
<b class="fc"><i class="no-highlight">1229</i>&nbsp;                        if (fileHandle == null) {</b>
<b class="fc"><i class="no-highlight">1230</i>&nbsp;                            newHandle = true;</b>
<b class="fc"><i class="no-highlight">1231</i>&nbsp;                            fileHandle = addFileHandle(fileId);</b>
<i class="no-highlight">1232</i>&nbsp;                        }
<b class="fc"><i class="no-highlight">1233</i>&nbsp;                    }</b>
<i class="no-highlight">1234</i>&nbsp;                }
<i class="no-highlight">1235</i>&nbsp;
<b class="fc"><i class="no-highlight">1236</i>&nbsp;                if (newHandle) {</b>
<i class="no-highlight">1237</i>&nbsp;
<i class="no-highlight">1238</i>&nbsp;                    /*
<i class="no-highlight">1239</i>&nbsp;                     * Open the file with the fileHandle latched.  It was
<i class="no-highlight">1240</i>&nbsp;                     * latched by addFileHandle above.
<i class="no-highlight">1241</i>&nbsp;                     */
<b class="fc"><i class="no-highlight">1242</i>&nbsp;                    boolean success = false;</b>
<i class="no-highlight">1243</i>&nbsp;                    try {
<b class="fc"><i class="no-highlight">1244</i>&nbsp;                        openFileHandle(fileHandle, FileMode.READ_MODE,</b>
<i class="no-highlight">1245</i>&nbsp;                                       null /*existingHandle*/);
<b class="fc"><i class="no-highlight">1246</i>&nbsp;                        success = true;</b>
<i class="no-highlight">1247</i>&nbsp;                    } finally {
<b class="fc"><i class="no-highlight">1248</i>&nbsp;                        if (!success) {</b>
<i class="no-highlight">1249</i>&nbsp;                            /* An exception is in flight -- clean up. */
<b class="nc"><i class="no-highlight">1250</i>&nbsp;                            fileHandle.release();</b>
<b class="nc"><i class="no-highlight">1251</i>&nbsp;                            clearFileCache(fileNum);</b>
<i class="no-highlight">1252</i>&nbsp;                        }
<b class="nc"><i class="no-highlight">1253</i>&nbsp;                    }</b>
<b class="fc"><i class="no-highlight">1254</i>&nbsp;                } else {</b>
<i class="no-highlight">1255</i>&nbsp;
<i class="no-highlight">1256</i>&nbsp;                    /*
<i class="no-highlight">1257</i>&nbsp;                     * The handle was found in the cache.  Latch the fileHandle
<i class="no-highlight">1258</i>&nbsp;                     * before checking getFile below and returning.
<i class="no-highlight">1259</i>&nbsp;                     */
<b class="fc"><i class="no-highlight">1260</i>&nbsp;                    if (!fileHandle.latchNoWait()) {</b>
<i class="no-highlight">1261</i>&nbsp;
<i class="no-highlight">1262</i>&nbsp;                        /*
<i class="no-highlight">1263</i>&nbsp;                         * But the handle was latched.  Rather than wait, let&#39;s
<i class="no-highlight">1264</i>&nbsp;                         * just make a new transient handle.  It doesn&#39;t need
<i class="no-highlight">1265</i>&nbsp;                         * to be latched, but it does need to be closed.
<i class="no-highlight">1266</i>&nbsp;                         */
<b class="nc"><i class="no-highlight">1267</i>&nbsp;                        final FileHandle existingHandle = fileHandle;</b>
<b class="nc"><i class="no-highlight">1268</i>&nbsp;                        fileHandle = new FileHandle(</b>
<b class="nc"><i class="no-highlight">1269</i>&nbsp;                            envImpl, fileId, getFileNumberString(fileId)) {</b>
<i class="no-highlight">1270</i>&nbsp;                                @Override
<i class="no-highlight">1271</i>&nbsp;                                public void release()
<i class="no-highlight">1272</i>&nbsp;                                    throws DatabaseException {
<i class="no-highlight">1273</i>&nbsp;
<i class="no-highlight">1274</i>&nbsp;                                    try {
<b class="nc"><i class="no-highlight">1275</i>&nbsp;                                        close();</b>
<b class="nc"><i class="no-highlight">1276</i>&nbsp;                                    } catch (IOException E) {</b>
<i class="no-highlight">1277</i>&nbsp;                                        // Ignore
<b class="nc"><i class="no-highlight">1278</i>&nbsp;                                    }</b>
<b class="nc"><i class="no-highlight">1279</i>&nbsp;                                }</b>
<i class="no-highlight">1280</i>&nbsp;                            };
<i class="no-highlight">1281</i>&nbsp;
<b class="nc"><i class="no-highlight">1282</i>&nbsp;                        openFileHandle(fileHandle, FileMode.READ_MODE,</b>
<i class="no-highlight">1283</i>&nbsp;                                       existingHandle);
<i class="no-highlight">1284</i>&nbsp;                    }
<i class="no-highlight">1285</i>&nbsp;                }
<i class="no-highlight">1286</i>&nbsp;
<i class="no-highlight">1287</i>&nbsp;                /*
<i class="no-highlight">1288</i>&nbsp;                 * We may have obtained this file handle outside the file cache
<i class="no-highlight">1289</i>&nbsp;                 * latch, so we have to test that the handle is still valid.
<i class="no-highlight">1290</i>&nbsp;                 * If it&#39;s not, then loop back and try again.
<i class="no-highlight">1291</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">1292</i>&nbsp;                if (fileHandle.getFile() == null) {</b>
<b class="nc"><i class="no-highlight">1293</i>&nbsp;                    fileHandle.release();</b>
<i class="no-highlight">1294</i>&nbsp;                } else {
<i class="no-highlight">1295</i>&nbsp;                    break;
<i class="no-highlight">1296</i>&nbsp;                }
<b class="nc"><i class="no-highlight">1297</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">1298</i>&nbsp;        } catch (FileNotFoundException e) {</b>
<i class="no-highlight">1299</i>&nbsp;            /* Handle at higher levels. */
<b class="nc"><i class="no-highlight">1300</i>&nbsp;            throw e;</b>
<b class="nc"><i class="no-highlight">1301</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">1302</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">1303</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_READ, e);
<b class="fc"><i class="no-highlight">1304</i>&nbsp;        }</b>
<i class="no-highlight">1305</i>&nbsp;
<b class="fc"><i class="no-highlight">1306</i>&nbsp;        return fileHandle;</b>
<i class="no-highlight">1307</i>&nbsp;    }
<i class="no-highlight">1308</i>&nbsp;
<i class="no-highlight">1309</i>&nbsp;    /**
<i class="no-highlight">1310</i>&nbsp;     * Creates a new FileHandle and adds it to the cache, but does not open
<i class="no-highlight">1311</i>&nbsp;     * the file.
<i class="no-highlight">1312</i>&nbsp;     * @return the latched FileHandle.
<i class="no-highlight">1313</i>&nbsp;     */
<i class="no-highlight">1314</i>&nbsp;    private FileHandle addFileHandle(Long fileNum)
<i class="no-highlight">1315</i>&nbsp;        throws IOException, DatabaseException {
<i class="no-highlight">1316</i>&nbsp;
<b class="fc"><i class="no-highlight">1317</i>&nbsp;        FileHandle fileHandle =</b>
<b class="fc"><i class="no-highlight">1318</i>&nbsp;            new FileHandle(envImpl, fileNum, getFileNumberString(fileNum));</b>
<b class="fc"><i class="no-highlight">1319</i>&nbsp;        fileCache.add(fileNum, fileHandle);</b>
<b class="fc"><i class="no-highlight">1320</i>&nbsp;        fileHandle.latch();</b>
<b class="fc"><i class="no-highlight">1321</i>&nbsp;        return fileHandle;</b>
<i class="no-highlight">1322</i>&nbsp;    }
<i class="no-highlight">1323</i>&nbsp;
<i class="no-highlight">1324</i>&nbsp;    private FileMode getAppropriateReadWriteMode() {
<b class="fc"><i class="no-highlight">1325</i>&nbsp;        if (useODSYNC) {</b>
<b class="nc"><i class="no-highlight">1326</i>&nbsp;            return FileMode.READWRITE_ODSYNC_MODE;</b>
<i class="no-highlight">1327</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1328</i>&nbsp;        return FileMode.READWRITE_MODE;</b>
<i class="no-highlight">1329</i>&nbsp;    }
<i class="no-highlight">1330</i>&nbsp;
<i class="no-highlight">1331</i>&nbsp;    /**
<i class="no-highlight">1332</i>&nbsp;     * Creates a new handle and opens it.  Does not add the handle to the
<i class="no-highlight">1333</i>&nbsp;     * cache.
<i class="no-highlight">1334</i>&nbsp;     */
<i class="no-highlight">1335</i>&nbsp;    private FileHandle makeFileHandle(long fileNum, FileMode mode)
<i class="no-highlight">1336</i>&nbsp;        throws FileNotFoundException, ChecksumException {
<i class="no-highlight">1337</i>&nbsp;
<b class="fc"><i class="no-highlight">1338</i>&nbsp;        FileHandle fileHandle =</b>
<b class="fc"><i class="no-highlight">1339</i>&nbsp;            new FileHandle(envImpl, fileNum, getFileNumberString(fileNum));</b>
<b class="fc"><i class="no-highlight">1340</i>&nbsp;        openFileHandle(fileHandle, mode, null /*existingHandle*/);</b>
<b class="fc"><i class="no-highlight">1341</i>&nbsp;        return fileHandle;</b>
<i class="no-highlight">1342</i>&nbsp;    }
<i class="no-highlight">1343</i>&nbsp;
<i class="no-highlight">1344</i>&nbsp;    /**
<i class="no-highlight">1345</i>&nbsp;     * Opens the file for the given handle and initializes it.
<i class="no-highlight">1346</i>&nbsp;     *
<i class="no-highlight">1347</i>&nbsp;     * @param existingHandle is an already open handle for the same file or
<i class="no-highlight">1348</i>&nbsp;     * null.  If non-null it is used to avoid the cost of reading the file
<i class="no-highlight">1349</i>&nbsp;     * header.
<i class="no-highlight">1350</i>&nbsp;     */
<i class="no-highlight">1351</i>&nbsp;    private void openFileHandle(FileHandle fileHandle,
<i class="no-highlight">1352</i>&nbsp;                                FileMode mode,
<i class="no-highlight">1353</i>&nbsp;                                FileHandle existingHandle)
<i class="no-highlight">1354</i>&nbsp;        throws FileNotFoundException, ChecksumException {
<i class="no-highlight">1355</i>&nbsp;
<b class="fc"><i class="no-highlight">1356</i>&nbsp;        nFileOpens.increment();</b>
<b class="fc"><i class="no-highlight">1357</i>&nbsp;        long fileNum = fileHandle.getFileNum();</b>
<b class="fc"><i class="no-highlight">1358</i>&nbsp;        String[] fileNames = getFullFileNames(fileNum);</b>
<b class="fc"><i class="no-highlight">1359</i>&nbsp;        RandomAccessFile newFile = null;</b>
<b class="fc"><i class="no-highlight">1360</i>&nbsp;        String fileName = null;</b>
<b class="fc"><i class="no-highlight">1361</i>&nbsp;        boolean success = false;</b>
<i class="no-highlight">1362</i>&nbsp;        try {
<i class="no-highlight">1363</i>&nbsp;
<i class="no-highlight">1364</i>&nbsp;            /*
<i class="no-highlight">1365</i>&nbsp;             * Open the file. Note that we are going to try a few names to open
<i class="no-highlight">1366</i>&nbsp;             * this file -- we&#39;ll try for N.jdb, and if that doesn&#39;t exist and
<i class="no-highlight">1367</i>&nbsp;             * we&#39;re configured to look for all types, we&#39;ll look for N.del.
<i class="no-highlight">1368</i>&nbsp;             */
<b class="fc"><i class="no-highlight">1369</i>&nbsp;            FileNotFoundException FNFE = null;</b>
<b class="fc"><i class="no-highlight">1370</i>&nbsp;            for (String fileName2 : fileNames) {</b>
<b class="fc"><i class="no-highlight">1371</i>&nbsp;                fileName = fileName2;</b>
<i class="no-highlight">1372</i>&nbsp;                try {
<b class="fc"><i class="no-highlight">1373</i>&nbsp;                    newFile = fileFactory.createFile(dbEnvHome, fileName,</b>
<b class="fc"><i class="no-highlight">1374</i>&nbsp;                                                     mode.getModeValue());</b>
<b class="fc"><i class="no-highlight">1375</i>&nbsp;                    break;</b>
<b class="nc"><i class="no-highlight">1376</i>&nbsp;                } catch (FileNotFoundException e) {</b>
<i class="no-highlight">1377</i>&nbsp;                    /* Save the first exception thrown. */
<b class="nc"><i class="no-highlight">1378</i>&nbsp;                    if (FNFE == null) {</b>
<b class="nc"><i class="no-highlight">1379</i>&nbsp;                        FNFE = e;</b>
<i class="no-highlight">1380</i>&nbsp;                    }
<i class="no-highlight">1381</i>&nbsp;                }
<i class="no-highlight">1382</i>&nbsp;            }
<i class="no-highlight">1383</i>&nbsp;
<i class="no-highlight">1384</i>&nbsp;            /*
<i class="no-highlight">1385</i>&nbsp;             * If we didn&#39;t find the file or couldn&#39;t create it, rethrow the
<i class="no-highlight">1386</i>&nbsp;             * exception.
<i class="no-highlight">1387</i>&nbsp;             */
<b class="fc"><i class="no-highlight">1388</i>&nbsp;            if (newFile == null) {</b>
<b class="nc"><i class="no-highlight">1389</i>&nbsp;        	assert FNFE != null;</b>
<b class="nc"><i class="no-highlight">1390</i>&nbsp;                throw FNFE;</b>
<i class="no-highlight">1391</i>&nbsp;            }
<i class="no-highlight">1392</i>&nbsp;
<i class="no-highlight">1393</i>&nbsp;            /*
<i class="no-highlight">1394</i>&nbsp;             * If there is an existing open handle, there is no need to read or
<i class="no-highlight">1395</i>&nbsp;             * validate the header.  Note that the log version is zero if the
<i class="no-highlight">1396</i>&nbsp;             * existing handle is not fully initialized.
<i class="no-highlight">1397</i>&nbsp;             */
<b class="fc"><i class="no-highlight">1398</i>&nbsp;            if (existingHandle != null) {</b>
<b class="nc"><i class="no-highlight">1399</i>&nbsp;                final int logVersion = existingHandle.getLogVersion();</b>
<b class="nc"><i class="no-highlight">1400</i>&nbsp;                if (logVersion &gt; 0) {</b>
<b class="nc"><i class="no-highlight">1401</i>&nbsp;                    fileHandle.init(newFile, logVersion);</b>
<b class="nc"><i class="no-highlight">1402</i>&nbsp;                    success = true;</b>
<b class="nc"><i class="no-highlight">1403</i>&nbsp;                    return;</b>
<i class="no-highlight">1404</i>&nbsp;                }
<i class="no-highlight">1405</i>&nbsp;            }
<i class="no-highlight">1406</i>&nbsp;
<b class="fc"><i class="no-highlight">1407</i>&nbsp;            int logVersion = LogEntryType.LOG_VERSION;</b>
<i class="no-highlight">1408</i>&nbsp;
<b class="fc"><i class="no-highlight">1409</i>&nbsp;            if (newFile.length() == 0) {</b>
<i class="no-highlight">1410</i>&nbsp;
<i class="no-highlight">1411</i>&nbsp;                /*
<i class="no-highlight">1412</i>&nbsp;                 * If the file is empty, reinitialize it if we can. If not,
<i class="no-highlight">1413</i>&nbsp;                 * send the file handle back up; the calling code will deal
<i class="no-highlight">1414</i>&nbsp;                 * with the fact that there&#39;s nothing there.
<i class="no-highlight">1415</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">1416</i>&nbsp;                if (mode.isWritable()) {</b>
<i class="no-highlight">1417</i>&nbsp;                    /* An empty file, write a header. */
<b class="fc"><i class="no-highlight">1418</i>&nbsp;                    long lastLsn = DbLsn.longToLsn(perFileLastUsedLsn.remove</b>
<b class="fc"><i class="no-highlight">1419</i>&nbsp;                       (Long.valueOf(fileNum - 1)));</b>
<b class="fc"><i class="no-highlight">1420</i>&nbsp;                    long headerPrevOffset = 0;</b>
<b class="fc"><i class="no-highlight">1421</i>&nbsp;                    if (lastLsn != DbLsn.NULL_LSN) {</b>
<b class="fc"><i class="no-highlight">1422</i>&nbsp;                        headerPrevOffset = DbLsn.getFileOffset(lastLsn);</b>
<i class="no-highlight">1423</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">1424</i>&nbsp;                    if ((headerPrevOffset == 0) &amp;&amp;</b>
<i class="no-highlight">1425</i>&nbsp;                        (fileNum &gt; 1) &amp;&amp;
<i class="no-highlight">1426</i>&nbsp;                        syncAtFileEnd) {
<i class="no-highlight">1427</i>&nbsp;                        /* Get more info if this happens again. [#20732] */
<b class="nc"><i class="no-highlight">1428</i>&nbsp;                        throw EnvironmentFailureException.unexpectedState</b>
<b class="nc"><i class="no-highlight">1429</i>&nbsp;                            (envImpl,</b>
<i class="no-highlight">1430</i>&nbsp;                             &quot;Zero prevOffset fileNum=0x&quot; +
<b class="nc"><i class="no-highlight">1431</i>&nbsp;                             Long.toHexString(fileNum) +</b>
<b class="nc"><i class="no-highlight">1432</i>&nbsp;                             &quot; lastLsn=&quot; + DbLsn.getNoFormatString(lastLsn) +</b>
<i class="no-highlight">1433</i>&nbsp;                             &quot; perFileLastUsedLsn=&quot; + perFileLastUsedLsn +
<b class="nc"><i class="no-highlight">1434</i>&nbsp;                             &quot; fileLen=&quot; + newFile.length());</b>
<i class="no-highlight">1435</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">1436</i>&nbsp;                    FileHeader fileHeader =</b>
<i class="no-highlight">1437</i>&nbsp;                        new FileHeader(fileNum, headerPrevOffset);
<b class="fc"><i class="no-highlight">1438</i>&nbsp;                    writeFileHeader(newFile, fileName, fileHeader, fileNum);</b>
<b class="fc"><i class="no-highlight">1439</i>&nbsp;                }</b>
<i class="no-highlight">1440</i>&nbsp;            } else {
<i class="no-highlight">1441</i>&nbsp;                /* A non-empty file, check the header */
<b class="fc"><i class="no-highlight">1442</i>&nbsp;                logVersion =</b>
<b class="fc"><i class="no-highlight">1443</i>&nbsp;                    readAndValidateFileHeader(newFile, fileName, fileNum);</b>
<i class="no-highlight">1444</i>&nbsp;            }
<b class="fc"><i class="no-highlight">1445</i>&nbsp;            fileHandle.init(newFile, logVersion);</b>
<b class="fc"><i class="no-highlight">1446</i>&nbsp;            success = true;</b>
<b class="nc"><i class="no-highlight">1447</i>&nbsp;        } catch (FileNotFoundException e) {</b>
<i class="no-highlight">1448</i>&nbsp;            /* Handle at higher levels. */
<b class="nc"><i class="no-highlight">1449</i>&nbsp;            throw e;</b>
<b class="nc"><i class="no-highlight">1450</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">1451</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">1452</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_READ,
<i class="no-highlight">1453</i>&nbsp;                 &quot;Couldn&#39;t open file &quot; + fileName, e);
<b class="nc"><i class="no-highlight">1454</i>&nbsp;        } catch (DatabaseException e) {</b>
<i class="no-highlight">1455</i>&nbsp;
<i class="no-highlight">1456</i>&nbsp;            /*
<i class="no-highlight">1457</i>&nbsp;             * Let this exception go as a checksum exception, so it sets the
<i class="no-highlight">1458</i>&nbsp;             * run recovery state correctly.
<i class="no-highlight">1459</i>&nbsp;             */
<b class="nc"><i class="no-highlight">1460</i>&nbsp;            closeFileInErrorCase(newFile);</b>
<b class="nc"><i class="no-highlight">1461</i>&nbsp;            e.addErrorMessage(&quot;Couldn&#39;t open file &quot; + fileName);</b>
<b class="nc"><i class="no-highlight">1462</i>&nbsp;            throw e;</b>
<i class="no-highlight">1463</i>&nbsp;        } finally {
<b class="fc"><i class="no-highlight">1464</i>&nbsp;            if (!success) {</b>
<b class="nc"><i class="no-highlight">1465</i>&nbsp;                closeFileInErrorCase(newFile);</b>
<i class="no-highlight">1466</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1467</i>&nbsp;        }</b>
<b class="fc"><i class="no-highlight">1468</i>&nbsp;    }</b>
<i class="no-highlight">1469</i>&nbsp;
<i class="no-highlight">1470</i>&nbsp;    /**
<i class="no-highlight">1471</i>&nbsp;     * Close this file and eat any exceptions. Used in catch clauses.
<i class="no-highlight">1472</i>&nbsp;     */
<i class="no-highlight">1473</i>&nbsp;    private void closeFileInErrorCase(RandomAccessFile file) {
<i class="no-highlight">1474</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">1475</i>&nbsp;            if (file != null) {</b>
<b class="nc"><i class="no-highlight">1476</i>&nbsp;                file.close();</b>
<i class="no-highlight">1477</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1478</i>&nbsp;        } catch (Exception e) {</b>
<b class="nc"><i class="no-highlight">1479</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">1480</i>&nbsp;    }</b>
<i class="no-highlight">1481</i>&nbsp;
<i class="no-highlight">1482</i>&nbsp;    /**
<i class="no-highlight">1483</i>&nbsp;     * Read the given JE log file and validate the header.
<i class="no-highlight">1484</i>&nbsp;     *
<i class="no-highlight">1485</i>&nbsp;     * @throws DatabaseException if the file header isn&#39;t valid
<i class="no-highlight">1486</i>&nbsp;     *
<i class="no-highlight">1487</i>&nbsp;     * @return file header log version.
<i class="no-highlight">1488</i>&nbsp;     */
<i class="no-highlight">1489</i>&nbsp;    private int readAndValidateFileHeader(RandomAccessFile file,
<i class="no-highlight">1490</i>&nbsp;                                          String fileName,
<i class="no-highlight">1491</i>&nbsp;                                          long fileNum)
<i class="no-highlight">1492</i>&nbsp;        throws ChecksumException, DatabaseException {
<i class="no-highlight">1493</i>&nbsp;
<i class="no-highlight">1494</i>&nbsp;        /*
<i class="no-highlight">1495</i>&nbsp;         * Read the file header from this file. It&#39;s always the first log
<i class="no-highlight">1496</i>&nbsp;         * entry.
<i class="no-highlight">1497</i>&nbsp;         *
<i class="no-highlight">1498</i>&nbsp;         * The special UNKNOWN_FILE_HEADER_VERSION value is passed for reading
<i class="no-highlight">1499</i>&nbsp;         * the entry header.  The actual log version is read as part of the
<i class="no-highlight">1500</i>&nbsp;         * FileHeader entry.  [#16939]
<i class="no-highlight">1501</i>&nbsp;         */
<b class="fc"><i class="no-highlight">1502</i>&nbsp;        LogManager logManager = envImpl.getLogManager();</b>
<b class="fc"><i class="no-highlight">1503</i>&nbsp;        LogEntry headerEntry = logManager.getLogEntryAllowChecksumException</b>
<b class="fc"><i class="no-highlight">1504</i>&nbsp;            (DbLsn.makeLsn(fileNum, 0), file,</b>
<i class="no-highlight">1505</i>&nbsp;             LogEntryType.UNKNOWN_FILE_HEADER_VERSION);
<b class="fc"><i class="no-highlight">1506</i>&nbsp;        FileHeader header = (FileHeader) headerEntry.getMainItem();</b>
<b class="fc"><i class="no-highlight">1507</i>&nbsp;        return header.validate(envImpl, fileName, fileNum);</b>
<i class="no-highlight">1508</i>&nbsp;    }
<i class="no-highlight">1509</i>&nbsp;
<i class="no-highlight">1510</i>&nbsp;    /**
<i class="no-highlight">1511</i>&nbsp;     * Write a proper file header to the given file.
<i class="no-highlight">1512</i>&nbsp;     */
<i class="no-highlight">1513</i>&nbsp;    private void writeFileHeader(RandomAccessFile file,
<i class="no-highlight">1514</i>&nbsp;                                 String fileName,
<i class="no-highlight">1515</i>&nbsp;                                 FileHeader header,
<i class="no-highlight">1516</i>&nbsp;                                 long fileNum)
<i class="no-highlight">1517</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">1518</i>&nbsp;
<i class="no-highlight">1519</i>&nbsp;        /* Fail loudly if the environment is invalid. */
<b class="fc"><i class="no-highlight">1520</i>&nbsp;        envImpl.checkIfInvalid();</b>
<i class="no-highlight">1521</i>&nbsp;
<i class="no-highlight">1522</i>&nbsp;        /*
<i class="no-highlight">1523</i>&nbsp;         * Fail silent if the environment is not open.
<i class="no-highlight">1524</i>&nbsp;         */
<b class="fc"><i class="no-highlight">1525</i>&nbsp;        if (envImpl.mayNotWrite()) {</b>
<b class="nc"><i class="no-highlight">1526</i>&nbsp;            return;</b>
<i class="no-highlight">1527</i>&nbsp;        }
<i class="no-highlight">1528</i>&nbsp;
<i class="no-highlight">1529</i>&nbsp;        /* Write file header into this buffer in the usual log entry format. */
<b class="fc"><i class="no-highlight">1530</i>&nbsp;        LogEntry headerLogEntry =</b>
<i class="no-highlight">1531</i>&nbsp;            new FileHeaderEntry(LogEntryType.LOG_FILE_HEADER, header);
<b class="fc"><i class="no-highlight">1532</i>&nbsp;        ByteBuffer headerBuf = envImpl.getLogManager().</b>
<b class="fc"><i class="no-highlight">1533</i>&nbsp;            putIntoBuffer(headerLogEntry,</b>
<i class="no-highlight">1534</i>&nbsp;                          0); // prevLogEntryOffset
<i class="no-highlight">1535</i>&nbsp;
<i class="no-highlight">1536</i>&nbsp;        /* Write the buffer into the channel. */
<i class="no-highlight">1537</i>&nbsp;        int bytesWritten;
<i class="no-highlight">1538</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">1539</i>&nbsp;            if (LOGWRITE_EXCEPTION_TESTING) {</b>
<b class="nc"><i class="no-highlight">1540</i>&nbsp;                generateLogWriteException(file, headerBuf, 0, fileNum);</b>
<i class="no-highlight">1541</i>&nbsp;            }
<i class="no-highlight">1542</i>&nbsp;
<i class="no-highlight">1543</i>&nbsp;            /*
<i class="no-highlight">1544</i>&nbsp;             * Always flush header so that file.length() will be non-zero when
<i class="no-highlight">1545</i>&nbsp;             * this method returns and two threads won&#39;t attempt to create the
<i class="no-highlight">1546</i>&nbsp;             * header. [#20732]
<i class="no-highlight">1547</i>&nbsp;             */
<b class="fc"><i class="no-highlight">1548</i>&nbsp;            bytesWritten = writeToFile(file, headerBuf, 0, fileNum,</b>
<i class="no-highlight">1549</i>&nbsp;                                       true /*flushRequired*/);
<i class="no-highlight">1550</i>&nbsp;
<b class="nc"><i class="no-highlight">1551</i>&nbsp;        } catch (ClosedChannelException e) {</b>
<i class="no-highlight">1552</i>&nbsp;
<i class="no-highlight">1553</i>&nbsp;            /*
<i class="no-highlight">1554</i>&nbsp;             * The channel should never be closed. It may be closed because
<i class="no-highlight">1555</i>&nbsp;             * of an interrupt received by another thread. See SR [#10463]
<i class="no-highlight">1556</i>&nbsp;             */
<b class="nc"><i class="no-highlight">1557</i>&nbsp;            throw new ThreadInterruptedException</b>
<i class="no-highlight">1558</i>&nbsp;                (envImpl, &quot;Channel closed, may be due to thread interrupt&quot;, e);
<b class="nc"><i class="no-highlight">1559</i>&nbsp;        } catch (IOException e) {</b>
<i class="no-highlight">1560</i>&nbsp;            /* Possibly an out of disk exception. */
<b class="nc"><i class="no-highlight">1561</i>&nbsp;            throw new LogWriteException(envImpl, e);</b>
<b class="fc"><i class="no-highlight">1562</i>&nbsp;        }</b>
<i class="no-highlight">1563</i>&nbsp;
<b class="fc"><i class="no-highlight">1564</i>&nbsp;        if (bytesWritten != headerLogEntry.getSize() +</b>
<i class="no-highlight">1565</i>&nbsp;            LogEntryHeader.MIN_HEADER_SIZE) {
<b class="nc"><i class="no-highlight">1566</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">1567</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_INTEGRITY,
<i class="no-highlight">1568</i>&nbsp;                 &quot;File &quot; + fileName +
<i class="no-highlight">1569</i>&nbsp;                 &quot; was created with an incomplete header. Only &quot; +
<i class="no-highlight">1570</i>&nbsp;                 bytesWritten + &quot; bytes were written.&quot;);
<i class="no-highlight">1571</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1572</i>&nbsp;    }</b>
<i class="no-highlight">1573</i>&nbsp;
<i class="no-highlight">1574</i>&nbsp;    /**
<i class="no-highlight">1575</i>&nbsp;     * @return the prevOffset field stored in the file header.
<i class="no-highlight">1576</i>&nbsp;     */
<i class="no-highlight">1577</i>&nbsp;    long getFileHeaderPrevOffset(long fileNum)
<i class="no-highlight">1578</i>&nbsp;        throws ChecksumException, DatabaseException {
<i class="no-highlight">1579</i>&nbsp;
<i class="no-highlight">1580</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">1581</i>&nbsp;            LogEntry headerEntry =</b>
<b class="nc"><i class="no-highlight">1582</i>&nbsp;                envImpl.getLogManager().getLogEntryAllowChecksumException</b>
<b class="nc"><i class="no-highlight">1583</i>&nbsp;                    (DbLsn.makeLsn(fileNum, 0));</b>
<b class="nc"><i class="no-highlight">1584</i>&nbsp;            FileHeader header = (FileHeader) headerEntry.getMainItem();</b>
<b class="nc"><i class="no-highlight">1585</i>&nbsp;            return header.getLastEntryInPrevFileOffset();</b>
<b class="nc"><i class="no-highlight">1586</i>&nbsp;        } catch (FileNotFoundException e) {</b>
<b class="nc"><i class="no-highlight">1587</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">1588</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_FILE_NOT_FOUND, e);
<i class="no-highlight">1589</i>&nbsp;        }
<i class="no-highlight">1590</i>&nbsp;    }
<i class="no-highlight">1591</i>&nbsp;
<i class="no-highlight">1592</i>&nbsp;    /*
<i class="no-highlight">1593</i>&nbsp;     * Support for writing new log entries
<i class="no-highlight">1594</i>&nbsp;     */
<i class="no-highlight">1595</i>&nbsp;
<i class="no-highlight">1596</i>&nbsp;    /**
<i class="no-highlight">1597</i>&nbsp;     * Returns whether we should flip files to log an entry of &#39;size&#39; bytes.
<i class="no-highlight">1598</i>&nbsp;     */
<i class="no-highlight">1599</i>&nbsp;    boolean shouldFlipFile(long size) {
<b class="fc"><i class="no-highlight">1600</i>&nbsp;        return forceNewFile ||</b>
<b class="fc"><i class="no-highlight">1601</i>&nbsp;            (DbLsn.getFileOffset(nextAvailableLsn) + size) &gt; maxFileSize;</b>
<i class="no-highlight">1602</i>&nbsp;    }
<i class="no-highlight">1603</i>&nbsp;
<i class="no-highlight">1604</i>&nbsp;    /**
<i class="no-highlight">1605</i>&nbsp;     * Calculates LSN of next entry to be logged.
<i class="no-highlight">1606</i>&nbsp;     */
<i class="no-highlight">1607</i>&nbsp;    long calculateNextLsn(boolean flippedFile) {
<b class="fc"><i class="no-highlight">1608</i>&nbsp;        return flippedFile ?</b>
<b class="fc"><i class="no-highlight">1609</i>&nbsp;            DbLsn.makeLsn(</b>
<i class="no-highlight">1610</i>&nbsp;                currentFileNum + 1,
<b class="fc"><i class="no-highlight">1611</i>&nbsp;                FileManager.firstLogEntryOffset()) :</b>
<i class="no-highlight">1612</i>&nbsp;            nextAvailableLsn;
<i class="no-highlight">1613</i>&nbsp;    }
<i class="no-highlight">1614</i>&nbsp;
<i class="no-highlight">1615</i>&nbsp;    /**
<i class="no-highlight">1616</i>&nbsp;     * Advance LSN position after determining the LSN of an entry to be logged.
<i class="no-highlight">1617</i>&nbsp;     *
<i class="no-highlight">1618</i>&nbsp;     * &lt;p&gt;When flippedFile is true, this method must be called after flushing
<i class="no-highlight">1619</i>&nbsp;     * the prior file. We guarantee that certain volatile LSN fields
<i class="no-highlight">1620</i>&nbsp;     * (currentFileNumber, nextAvailableLsn, lastUsedLsn) are not updated until
<i class="no-highlight">1621</i>&nbsp;     * after flushing the prior file.&lt;/p&gt;
<i class="no-highlight">1622</i>&nbsp;     *
<i class="no-highlight">1623</i>&nbsp;     * @param currentLsn value returned by {@link #calculateNextLsn}
<i class="no-highlight">1624</i>&nbsp;     *
<i class="no-highlight">1625</i>&nbsp;     * @param size value passed to {@link #shouldFlipFile}
<i class="no-highlight">1626</i>&nbsp;     *
<i class="no-highlight">1627</i>&nbsp;     * @param flippedFile value returned by {@link #shouldFlipFile}.
<i class="no-highlight">1628</i>&nbsp;     *
<i class="no-highlight">1629</i>&nbsp;     * @return the file offset of the previous LSN that was used. Needed for
<i class="no-highlight">1630</i>&nbsp;     * constructing the header of the log entry for currentLsn. If the previous
<i class="no-highlight">1631</i>&nbsp;     * LSN was in the previous file, or this is the very first LSN of the env,
<i class="no-highlight">1632</i>&nbsp;     * zero is returned.
<i class="no-highlight">1633</i>&nbsp;     */
<i class="no-highlight">1634</i>&nbsp;    long advanceLsn(long currentLsn, long size, boolean flippedFile) {
<i class="no-highlight">1635</i>&nbsp;
<i class="no-highlight">1636</i>&nbsp;        final long prevOffset;
<i class="no-highlight">1637</i>&nbsp;
<b class="fc"><i class="no-highlight">1638</i>&nbsp;        if (flippedFile) {</b>
<b class="fc"><i class="no-highlight">1639</i>&nbsp;            assert DbLsn.getFileNumber(currentLsn) == currentFileNum + 1;</b>
<b class="fc"><i class="no-highlight">1640</i>&nbsp;            assert DbLsn.getFileOffset(currentLsn) == firstLogEntryOffset();</b>
<i class="no-highlight">1641</i>&nbsp;
<b class="fc"><i class="no-highlight">1642</i>&nbsp;            perFileLastUsedLsn.put(currentFileNum, lastUsedLsn);</b>
<b class="fc"><i class="no-highlight">1643</i>&nbsp;            currentFileNum += 1;</b>
<b class="fc"><i class="no-highlight">1644</i>&nbsp;            prevOffset = 0;</b>
<i class="no-highlight">1645</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">1646</i>&nbsp;            assert DbLsn.getFileNumber(currentLsn) == currentFileNum;</b>
<i class="no-highlight">1647</i>&nbsp;
<b class="fc"><i class="no-highlight">1648</i>&nbsp;            prevOffset = (lastUsedLsn == DbLsn.NULL_LSN) ?</b>
<b class="fc"><i class="no-highlight">1649</i>&nbsp;                0 : DbLsn.getFileOffset(lastUsedLsn);</b>
<i class="no-highlight">1650</i>&nbsp;        }
<i class="no-highlight">1651</i>&nbsp;
<b class="fc"><i class="no-highlight">1652</i>&nbsp;        forceNewFile = false;</b>
<b class="fc"><i class="no-highlight">1653</i>&nbsp;        lastUsedLsn = currentLsn;</b>
<i class="no-highlight">1654</i>&nbsp;
<b class="fc"><i class="no-highlight">1655</i>&nbsp;        nextAvailableLsn = DbLsn.makeLsn(</b>
<i class="no-highlight">1656</i>&nbsp;            currentFileNum,
<b class="fc"><i class="no-highlight">1657</i>&nbsp;            DbLsn.getFileOffset(currentLsn) + size);</b>
<i class="no-highlight">1658</i>&nbsp;
<b class="fc"><i class="no-highlight">1659</i>&nbsp;        return prevOffset;</b>
<i class="no-highlight">1660</i>&nbsp;    }
<i class="no-highlight">1661</i>&nbsp;
<i class="no-highlight">1662</i>&nbsp;    /**
<i class="no-highlight">1663</i>&nbsp;     * Write out a log buffer to the file.
<i class="no-highlight">1664</i>&nbsp;     * @param fullBuffer buffer to write
<i class="no-highlight">1665</i>&nbsp;     * @param flushWriteQueue true if this write can not be queued on the
<i class="no-highlight">1666</i>&nbsp;     * Write Queue.
<i class="no-highlight">1667</i>&nbsp;     */
<i class="no-highlight">1668</i>&nbsp;    void writeLogBuffer(LogBuffer fullBuffer, boolean flushWriteQueue)
<i class="no-highlight">1669</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">1670</i>&nbsp;
<i class="no-highlight">1671</i>&nbsp;        /* Fail loudly if the environment is invalid. */
<b class="fc"><i class="no-highlight">1672</i>&nbsp;        envImpl.checkIfInvalid();</b>
<i class="no-highlight">1673</i>&nbsp;
<i class="no-highlight">1674</i>&nbsp;        /*
<i class="no-highlight">1675</i>&nbsp;         * Fail silent if the environment is not open.
<i class="no-highlight">1676</i>&nbsp;         */
<b class="fc"><i class="no-highlight">1677</i>&nbsp;        if (envImpl.mayNotWrite()) {</b>
<b class="nc"><i class="no-highlight">1678</i>&nbsp;            return;</b>
<i class="no-highlight">1679</i>&nbsp;        }
<i class="no-highlight">1680</i>&nbsp;
<i class="no-highlight">1681</i>&nbsp;        /* Use the LSN to figure out what file to write this buffer to. */
<b class="fc"><i class="no-highlight">1682</i>&nbsp;        long firstLsn = fullBuffer.getFirstLsn();</b>
<i class="no-highlight">1683</i>&nbsp;
<i class="no-highlight">1684</i>&nbsp;        /*
<i class="no-highlight">1685</i>&nbsp;         * Is there anything in this write buffer? We could have been called by
<i class="no-highlight">1686</i>&nbsp;         * the environment shutdown, and nothing is actually in the buffer.
<i class="no-highlight">1687</i>&nbsp;         */
<b class="fc"><i class="no-highlight">1688</i>&nbsp;        if (firstLsn != DbLsn.NULL_LSN) {</b>
<i class="no-highlight">1689</i>&nbsp;
<b class="fc"><i class="no-highlight">1690</i>&nbsp;            RandomAccessFile file =</b>
<b class="fc"><i class="no-highlight">1691</i>&nbsp;                endOfLog.getWritableFile(DbLsn.getFileNumber(firstLsn), true);</b>
<b class="fc"><i class="no-highlight">1692</i>&nbsp;            ByteBuffer data = fullBuffer.getDataBuffer();</b>
<i class="no-highlight">1693</i>&nbsp;
<i class="no-highlight">1694</i>&nbsp;            try {
<i class="no-highlight">1695</i>&nbsp;
<i class="no-highlight">1696</i>&nbsp;                /*
<i class="no-highlight">1697</i>&nbsp;                 * Check that we do not overwrite unless the file only contains
<i class="no-highlight">1698</i>&nbsp;                 * a header [#11915] [#12616].
<i class="no-highlight">1699</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">1700</i>&nbsp;                assert fullBuffer.getRewriteAllowed() ||</b>
<b class="nc"><i class="no-highlight">1701</i>&nbsp;                    (DbLsn.getFileOffset(firstLsn) &gt;= file.length() ||</b>
<b class="nc"><i class="no-highlight">1702</i>&nbsp;                     file.length() == firstLogEntryOffset()) :</b>
<i class="no-highlight">1703</i>&nbsp;                        &quot;FileManager would overwrite non-empty file 0x&quot; +
<b class="nc"><i class="no-highlight">1704</i>&nbsp;                        Long.toHexString(DbLsn.getFileNumber(firstLsn)) +</b>
<i class="no-highlight">1705</i>&nbsp;                        &quot; lsnOffset=0x&quot; +
<b class="nc"><i class="no-highlight">1706</i>&nbsp;                        Long.toHexString(DbLsn.getFileOffset(firstLsn)) +</b>
<i class="no-highlight">1707</i>&nbsp;                        &quot; fileLength=0x&quot; +
<b class="nc"><i class="no-highlight">1708</i>&nbsp;                        Long.toHexString(file.length());</b>
<i class="no-highlight">1709</i>&nbsp;
<b class="fc"><i class="no-highlight">1710</i>&nbsp;                if (LOGWRITE_EXCEPTION_TESTING) {</b>
<b class="nc"><i class="no-highlight">1711</i>&nbsp;                    generateLogWriteException</b>
<b class="nc"><i class="no-highlight">1712</i>&nbsp;                        (file, data, DbLsn.getFileOffset(firstLsn),</b>
<b class="nc"><i class="no-highlight">1713</i>&nbsp;                         DbLsn.getFileNumber(firstLsn));</b>
<i class="no-highlight">1714</i>&nbsp;                }
<b class="fc"><i class="no-highlight">1715</i>&nbsp;                writeToFile(file, data, DbLsn.getFileOffset(firstLsn),</b>
<b class="fc"><i class="no-highlight">1716</i>&nbsp;                            DbLsn.getFileNumber(firstLsn),</b>
<i class="no-highlight">1717</i>&nbsp;                            flushWriteQueue);
<b class="nc"><i class="no-highlight">1718</i>&nbsp;            } catch (ClosedChannelException e) {</b>
<i class="no-highlight">1719</i>&nbsp;
<i class="no-highlight">1720</i>&nbsp;                /*
<i class="no-highlight">1721</i>&nbsp;                 * The file should never be closed. It may be closed because
<i class="no-highlight">1722</i>&nbsp;                 * of an interrupt received by another thread. See SR [#10463].
<i class="no-highlight">1723</i>&nbsp;                 */
<b class="nc"><i class="no-highlight">1724</i>&nbsp;                throw new ThreadInterruptedException</b>
<i class="no-highlight">1725</i>&nbsp;                    (envImpl, &quot;File closed, may be due to thread interrupt&quot;,
<i class="no-highlight">1726</i>&nbsp;                     e);
<b class="nc"><i class="no-highlight">1727</i>&nbsp;            } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">1728</i>&nbsp;                throw new LogWriteException(envImpl, e);</b>
<b class="fc"><i class="no-highlight">1729</i>&nbsp;            }</b>
<i class="no-highlight">1730</i>&nbsp;
<b class="fc"><i class="no-highlight">1731</i>&nbsp;            assert EnvironmentImpl.maybeForceYield();</b>
<i class="no-highlight">1732</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1733</i>&nbsp;    }</b>
<i class="no-highlight">1734</i>&nbsp;
<i class="no-highlight">1735</i>&nbsp;    /**
<i class="no-highlight">1736</i>&nbsp;     * Write a buffer to a file at a given offset.
<i class="no-highlight">1737</i>&nbsp;     */
<i class="no-highlight">1738</i>&nbsp;    private int writeToFile(RandomAccessFile file,
<i class="no-highlight">1739</i>&nbsp;                            ByteBuffer data,
<i class="no-highlight">1740</i>&nbsp;                            long destOffset,
<i class="no-highlight">1741</i>&nbsp;                            long fileNum,
<i class="no-highlight">1742</i>&nbsp;                            boolean flushWriteQueue)
<i class="no-highlight">1743</i>&nbsp;        throws IOException, DatabaseException {
<b class="fc"><i class="no-highlight">1744</i>&nbsp;        COUNT_WRITE.incrementAndGet();</b>
<i class="no-highlight">1745</i>&nbsp;
<b class="fc"><i class="no-highlight">1746</i>&nbsp;        int totalBytesWritten = 0;</b>
<i class="no-highlight">1747</i>&nbsp;
<b class="fc"><i class="no-highlight">1748</i>&nbsp;        bumpWriteCount(&quot;write&quot;);</b>
<i class="no-highlight">1749</i>&nbsp;
<b class="fc"><i class="no-highlight">1750</i>&nbsp;        int pos = data.position();</b>
<b class="fc"><i class="no-highlight">1751</i>&nbsp;        int size = data.limit() - pos;</b>
<i class="no-highlight">1752</i>&nbsp;
<b class="fc"><i class="no-highlight">1753</i>&nbsp;        if (lastFileNumberTouched == fileNum &amp;&amp;</b>
<b class="fc"><i class="no-highlight">1754</i>&nbsp;            (Math.abs(destOffset - lastFileTouchedOffset) &lt;</b>
<i class="no-highlight">1755</i>&nbsp;             ADJACENT_TRACK_SEEK_DELTA)) {
<b class="fc"><i class="no-highlight">1756</i>&nbsp;            nSequentialWrites.increment();</b>
<b class="fc"><i class="no-highlight">1757</i>&nbsp;            nSequentialWriteBytes.add(size);</b>
<i class="no-highlight">1758</i>&nbsp;        } else {
<b class="fc"><i class="no-highlight">1759</i>&nbsp;            nRandomWrites.increment();</b>
<b class="fc"><i class="no-highlight">1760</i>&nbsp;            nRandomWriteBytes.add(size);</b>
<i class="no-highlight">1761</i>&nbsp;        }
<i class="no-highlight">1762</i>&nbsp;
<b class="fc"><i class="no-highlight">1763</i>&nbsp;        if (VERIFY_CHECKSUMS) {</b>
<b class="nc"><i class="no-highlight">1764</i>&nbsp;            verifyChecksums(data, destOffset, &quot;pre-write&quot;);</b>
<i class="no-highlight">1765</i>&nbsp;        }
<i class="no-highlight">1766</i>&nbsp;
<i class="no-highlight">1767</i>&nbsp;        /*
<i class="no-highlight">1768</i>&nbsp;         * Perform a RandomAccessFile write and update the buffer position.
<i class="no-highlight">1769</i>&nbsp;         * ByteBuffer.array() is safe to use since all non-direct ByteBuffers
<i class="no-highlight">1770</i>&nbsp;         * have a backing array.
<i class="no-highlight">1771</i>&nbsp;         *
<i class="no-highlight">1772</i>&nbsp;         * Synchronization on the file object is needed because two threads may
<i class="no-highlight">1773</i>&nbsp;         * call seek() on the same file object.
<i class="no-highlight">1774</i>&nbsp;         *
<i class="no-highlight">1775</i>&nbsp;         * If the Write Queue is enabled, attempt to get the fsync latch.  If
<i class="no-highlight">1776</i>&nbsp;         * we can&#39;t get it, then an fsync or write is in progress and we&#39;d
<i class="no-highlight">1777</i>&nbsp;         * block anyway.  In that case, queue the write operation.
<i class="no-highlight">1778</i>&nbsp;         */
<b class="fc"><i class="no-highlight">1779</i>&nbsp;        boolean fsyncLatchAcquired =</b>
<b class="fc"><i class="no-highlight">1780</i>&nbsp;            endOfLog.fsyncFileSynchronizer.tryLock();</b>
<b class="fc"><i class="no-highlight">1781</i>&nbsp;        boolean enqueueSuccess = false;</b>
<b class="fc"><i class="no-highlight">1782</i>&nbsp;        if (!fsyncLatchAcquired &amp;&amp;</b>
<i class="no-highlight">1783</i>&nbsp;            useWriteQueue &amp;&amp;
<i class="no-highlight">1784</i>&nbsp;            !flushWriteQueue) {
<b class="nc"><i class="no-highlight">1785</i>&nbsp;            enqueueSuccess =</b>
<b class="nc"><i class="no-highlight">1786</i>&nbsp;                endOfLog.enqueueWrite(fileNum, data.array(), destOffset,</b>
<b class="nc"><i class="no-highlight">1787</i>&nbsp;                                      pos + data.arrayOffset(), size);</b>
<i class="no-highlight">1788</i>&nbsp;        }
<i class="no-highlight">1789</i>&nbsp;
<b class="fc"><i class="no-highlight">1790</i>&nbsp;        if (!enqueueSuccess) {</b>
<b class="fc"><i class="no-highlight">1791</i>&nbsp;            if (!fsyncLatchAcquired) {</b>
<b class="nc"><i class="no-highlight">1792</i>&nbsp;                endOfLog.fsyncFileSynchronizer.lock();</b>
<i class="no-highlight">1793</i>&nbsp;            }
<i class="no-highlight">1794</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">1795</i>&nbsp;                if (useWriteQueue) {</b>
<b class="fc"><i class="no-highlight">1796</i>&nbsp;                    endOfLog.dequeuePendingWrites1();</b>
<i class="no-highlight">1797</i>&nbsp;                }
<i class="no-highlight">1798</i>&nbsp;
<b class="fc"><i class="no-highlight">1799</i>&nbsp;                synchronized (file) {</b>
<i class="no-highlight">1800</i>&nbsp;
<b class="fc"><i class="no-highlight">1801</i>&nbsp;                    file.seek(destOffset);</b>
<b class="fc"><i class="no-highlight">1802</i>&nbsp;                    file.write(data.array(), pos + data.arrayOffset(), size);</b>
<i class="no-highlight">1803</i>&nbsp;
<b class="fc"><i class="no-highlight">1804</i>&nbsp;                    if (VERIFY_CHECKSUMS) {</b>
<b class="nc"><i class="no-highlight">1805</i>&nbsp;                        file.seek(destOffset);</b>
<b class="nc"><i class="no-highlight">1806</i>&nbsp;                        file.read(</b>
<b class="nc"><i class="no-highlight">1807</i>&nbsp;                            data.array(), pos + data.arrayOffset(), size);</b>
<b class="nc"><i class="no-highlight">1808</i>&nbsp;                        verifyChecksums(data, destOffset, &quot;post-write&quot;);</b>
<i class="no-highlight">1809</i>&nbsp;                    }
<b class="fc"><i class="no-highlight">1810</i>&nbsp;                }</b>
<i class="no-highlight">1811</i>&nbsp;            } finally {
<b class="fc"><i class="no-highlight">1812</i>&nbsp;                endOfLog.fsyncFileSynchronizer.unlock();</b>
<b class="fc"><i class="no-highlight">1813</i>&nbsp;            }</b>
<i class="no-highlight">1814</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1815</i>&nbsp;        data.position(pos + size);</b>
<b class="fc"><i class="no-highlight">1816</i>&nbsp;        totalBytesWritten = size;</b>
<i class="no-highlight">1817</i>&nbsp;
<b class="fc"><i class="no-highlight">1818</i>&nbsp;        lastFileNumberTouched = fileNum;</b>
<b class="fc"><i class="no-highlight">1819</i>&nbsp;        lastFileTouchedOffset = destOffset + size;</b>
<b class="fc"><i class="no-highlight">1820</i>&nbsp;        return totalBytesWritten;</b>
<i class="no-highlight">1821</i>&nbsp;    }
<i class="no-highlight">1822</i>&nbsp;
<i class="no-highlight">1823</i>&nbsp;    private void bumpWriteCount(final String debugMsg)
<i class="no-highlight">1824</i>&nbsp;        throws IOException {
<i class="no-highlight">1825</i>&nbsp;
<i class="no-highlight">1826</i>&nbsp;        if (DEBUG) {
<i class="no-highlight">1827</i>&nbsp;            System.out.println(&quot;Write: &quot; + WRITE_COUNT + &quot; &quot; + debugMsg);
<i class="no-highlight">1828</i>&nbsp;        }
<i class="no-highlight">1829</i>&nbsp;
<b class="fc"><i class="no-highlight">1830</i>&nbsp;        if (++WRITE_COUNT &gt;= STOP_ON_WRITE_COUNT &amp;&amp;</b>
<i class="no-highlight">1831</i>&nbsp;            WRITE_COUNT &lt; (STOP_ON_WRITE_COUNT + N_BAD_WRITES)) {
<b class="nc"><i class="no-highlight">1832</i>&nbsp;            if (THROW_ON_WRITE) {</b>
<b class="nc"><i class="no-highlight">1833</i>&nbsp;                throw new IOException</b>
<i class="no-highlight">1834</i>&nbsp;                    (&quot;IOException generated for testing: &quot; + WRITE_COUNT +
<i class="no-highlight">1835</i>&nbsp;                     &quot; &quot; + debugMsg);
<i class="no-highlight">1836</i>&nbsp;            }
<b class="nc"><i class="no-highlight">1837</i>&nbsp;            Runtime.getRuntime().halt(0xff);</b>
<i class="no-highlight">1838</i>&nbsp;        }
<b class="fc"><i class="no-highlight">1839</i>&nbsp;    }</b>
<i class="no-highlight">1840</i>&nbsp;
<i class="no-highlight">1841</i>&nbsp;    /**
<i class="no-highlight">1842</i>&nbsp;     * Read a buffer from a file at a given offset. We know that the desired
<i class="no-highlight">1843</i>&nbsp;     * data exists in this file. There&#39;s no need to incur extra costs
<i class="no-highlight">1844</i>&nbsp;     * such as checks of the file length, nor to return status as to whether
<i class="no-highlight">1845</i>&nbsp;     * this file contains the data.
<i class="no-highlight">1846</i>&nbsp;     */
<i class="no-highlight">1847</i>&nbsp;    void readFromFile(RandomAccessFile file,
<i class="no-highlight">1848</i>&nbsp;                      ByteBuffer readBuffer,
<i class="no-highlight">1849</i>&nbsp;                      long offset,
<i class="no-highlight">1850</i>&nbsp;                      long fileNo)
<i class="no-highlight">1851</i>&nbsp;        throws DatabaseException {
<b class="fc"><i class="no-highlight">1852</i>&nbsp;        readFromFile(file, readBuffer, offset, fileNo,</b>
<i class="no-highlight">1853</i>&nbsp;                     true /* dataKnownToBeInFile */);
<b class="fc"><i class="no-highlight">1854</i>&nbsp;    }</b>
<i class="no-highlight">1855</i>&nbsp;
<i class="no-highlight">1856</i>&nbsp;    /**
<i class="no-highlight">1857</i>&nbsp;     * Read a buffer from a file at a given offset.
<i class="no-highlight">1858</i>&nbsp;     *
<i class="no-highlight">1859</i>&nbsp;     * @return true if the read buffer is filled, false, if there is nothing
<i class="no-highlight">1860</i>&nbsp;     * left in the file to read
<i class="no-highlight">1861</i>&nbsp;     */
<i class="no-highlight">1862</i>&nbsp;    boolean readFromFile(RandomAccessFile file,
<i class="no-highlight">1863</i>&nbsp;                         ByteBuffer readBuffer,
<i class="no-highlight">1864</i>&nbsp;                         long offset,
<i class="no-highlight">1865</i>&nbsp;                         long fileNo,
<i class="no-highlight">1866</i>&nbsp;                         boolean dataKnownToBeInFile)
<i class="no-highlight">1867</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">1868</i>&nbsp;
<i class="no-highlight">1869</i>&nbsp;        /*
<i class="no-highlight">1870</i>&nbsp;         * All IOExceptions on read turn into EnvironmentFailureExceptions
<i class="no-highlight">1871</i>&nbsp;         * [#15768].
<i class="no-highlight">1872</i>&nbsp;         */
<i class="no-highlight">1873</i>&nbsp;        try {
<i class="no-highlight">1874</i>&nbsp;
<i class="no-highlight">1875</i>&nbsp;            /*
<i class="no-highlight">1876</i>&nbsp;             * Check if there&#39;s a pending write(s) in the write queue for this
<i class="no-highlight">1877</i>&nbsp;             * fileNo/offset and if so, use it to fulfill this read request.
<i class="no-highlight">1878</i>&nbsp;             */
<b class="fc"><i class="no-highlight">1879</i>&nbsp;            if (useWriteQueue &amp;&amp;</b>
<b class="fc"><i class="no-highlight">1880</i>&nbsp;                endOfLog.checkWriteCache(readBuffer, offset, fileNo)) {</b>
<b class="nc"><i class="no-highlight">1881</i>&nbsp;                return true;</b>
<i class="no-highlight">1882</i>&nbsp;            }
<i class="no-highlight">1883</i>&nbsp;
<i class="no-highlight">1884</i>&nbsp;            /*
<i class="no-highlight">1885</i>&nbsp;             * Nothing queued, all data for this file must be in the file.
<i class="no-highlight">1886</i>&nbsp;             * Note that there&#39;s no synchronization between the check of the
<i class="no-highlight">1887</i>&nbsp;             * write queue above, and this check of file length. It&#39;s possible
<i class="no-highlight">1888</i>&nbsp;             * that a newly written log entry could show up between the
<i class="no-highlight">1889</i>&nbsp;             * statements, and enter the write queue just after we finish the
<i class="no-highlight">1890</i>&nbsp;             * check.
<i class="no-highlight">1891</i>&nbsp;             *
<i class="no-highlight">1892</i>&nbsp;             * Because of this, callers of this method must abide by one of
<i class="no-highlight">1893</i>&nbsp;             * three conditions:
<i class="no-highlight">1894</i>&nbsp;             * 1. They guarantee that the attempt to read a chunk of new data
<i class="no-highlight">1895</i>&nbsp;             *   comes after the new data has been logged by the LogManager.
<i class="no-highlight">1896</i>&nbsp;             * 2. The files are quiescent when the read is going on.
<i class="no-highlight">1897</i>&nbsp;             * 3. The caller is sure the data is in this file.
<i class="no-highlight">1898</i>&nbsp;             *
<i class="no-highlight">1899</i>&nbsp;             * The replication feeder reader abides by (1) while all other file
<i class="no-highlight">1900</i>&nbsp;             * readers abide by (2). Callers which are fetching specific log
<i class="no-highlight">1901</i>&nbsp;             * entries fall under (3).
<i class="no-highlight">1902</i>&nbsp;             */
<b class="fc"><i class="no-highlight">1903</i>&nbsp;            boolean readThisFile = true;</b>
<b class="fc"><i class="no-highlight">1904</i>&nbsp;            if (!dataKnownToBeInFile) {</b>
<i class="no-highlight">1905</i>&nbsp;
<i class="no-highlight">1906</i>&nbsp;                /*
<i class="no-highlight">1907</i>&nbsp;                 * Callers who are not sure whether the desired data is in this
<i class="no-highlight">1908</i>&nbsp;                 * file or the next incur the cost of a check of file.length(),
<i class="no-highlight">1909</i>&nbsp;                 * which is a system call.
<i class="no-highlight">1910</i>&nbsp;                 */
<b class="fc"><i class="no-highlight">1911</i>&nbsp;                readThisFile = (offset &lt; file.length());</b>
<i class="no-highlight">1912</i>&nbsp;            }
<i class="no-highlight">1913</i>&nbsp;
<b class="fc"><i class="no-highlight">1914</i>&nbsp;            if (readThisFile) {</b>
<b class="fc"><i class="no-highlight">1915</i>&nbsp;                readFromFileInternal(file, readBuffer, offset, fileNo);</b>
<b class="fc"><i class="no-highlight">1916</i>&nbsp;                return true;</b>
<i class="no-highlight">1917</i>&nbsp;            }
<i class="no-highlight">1918</i>&nbsp;
<b class="fc"><i class="no-highlight">1919</i>&nbsp;            return false;</b>
<b class="nc"><i class="no-highlight">1920</i>&nbsp;        } catch (ClosedChannelException e) {</b>
<i class="no-highlight">1921</i>&nbsp;
<i class="no-highlight">1922</i>&nbsp;            /*
<i class="no-highlight">1923</i>&nbsp;             * The channel should never be closed. It may be closed because
<i class="no-highlight">1924</i>&nbsp;             * of an interrupt received by another thread. See SR [#10463]
<i class="no-highlight">1925</i>&nbsp;             */
<b class="nc"><i class="no-highlight">1926</i>&nbsp;            throw new ThreadInterruptedException</b>
<i class="no-highlight">1927</i>&nbsp;                (envImpl, &quot;Channel closed, may be due to thread interrupt&quot;, e);
<b class="nc"><i class="no-highlight">1928</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">1929</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">1930</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_READ, e);
<i class="no-highlight">1931</i>&nbsp;        }
<i class="no-highlight">1932</i>&nbsp;    }
<i class="no-highlight">1933</i>&nbsp;
<i class="no-highlight">1934</i>&nbsp;    private void readFromFileInternal(RandomAccessFile file,
<i class="no-highlight">1935</i>&nbsp;                                      ByteBuffer readBuffer,
<i class="no-highlight">1936</i>&nbsp;                                      long offset,
<i class="no-highlight">1937</i>&nbsp;                                      long fileNum)
<i class="no-highlight">1938</i>&nbsp;        throws IOException {
<b class="fc"><i class="no-highlight">1939</i>&nbsp;        COUNT_READ.incrementAndGet();</b>
<i class="no-highlight">1940</i>&nbsp;
<i class="no-highlight">1941</i>&nbsp;        /*
<i class="no-highlight">1942</i>&nbsp;         * Perform a RandomAccessFile read and update the buffer position.
<i class="no-highlight">1943</i>&nbsp;         * ByteBuffer.array() is safe to use since all non-direct ByteBuffers
<i class="no-highlight">1944</i>&nbsp;         * have a backing array.  Synchronization on the file object is needed
<i class="no-highlight">1945</i>&nbsp;         * because two threads may call seek() on the same file object.
<i class="no-highlight">1946</i>&nbsp;         */
<b class="fc"><i class="no-highlight">1947</i>&nbsp;        synchronized (file) {</b>
<b class="fc"><i class="no-highlight">1948</i>&nbsp;            int pos = readBuffer.position();</b>
<b class="fc"><i class="no-highlight">1949</i>&nbsp;            int size = readBuffer.limit() - pos;</b>
<i class="no-highlight">1950</i>&nbsp;
<b class="fc"><i class="no-highlight">1951</i>&nbsp;            if (lastFileNumberTouched == fileNum &amp;&amp;</b>
<b class="fc"><i class="no-highlight">1952</i>&nbsp;                (Math.abs(offset - lastFileTouchedOffset) &lt;</b>
<i class="no-highlight">1953</i>&nbsp;                 ADJACENT_TRACK_SEEK_DELTA)) {
<b class="fc"><i class="no-highlight">1954</i>&nbsp;                nSequentialReads.increment();</b>
<b class="fc"><i class="no-highlight">1955</i>&nbsp;                nSequentialReadBytes.add(size);</b>
<i class="no-highlight">1956</i>&nbsp;            } else {
<b class="fc"><i class="no-highlight">1957</i>&nbsp;                nRandomReads.increment();</b>
<b class="fc"><i class="no-highlight">1958</i>&nbsp;                nRandomReadBytes.add(size);</b>
<i class="no-highlight">1959</i>&nbsp;            }
<i class="no-highlight">1960</i>&nbsp;
<b class="fc"><i class="no-highlight">1961</i>&nbsp;            file.seek(offset);</b>
<i class="no-highlight">1962</i>&nbsp;
<b class="fc"><i class="no-highlight">1963</i>&nbsp;            int bytesRead = file.read(readBuffer.array(),</b>
<b class="fc"><i class="no-highlight">1964</i>&nbsp;                                      pos + readBuffer.arrayOffset(),</b>
<i class="no-highlight">1965</i>&nbsp;                                      size);
<b class="fc"><i class="no-highlight">1966</i>&nbsp;            if (bytesRead &gt; 0) {</b>
<b class="fc"><i class="no-highlight">1967</i>&nbsp;                readBuffer.position(pos + bytesRead);</b>
<i class="no-highlight">1968</i>&nbsp;            }
<i class="no-highlight">1969</i>&nbsp;
<b class="fc"><i class="no-highlight">1970</i>&nbsp;            lastFileNumberTouched = fileNum;</b>
<b class="fc"><i class="no-highlight">1971</i>&nbsp;            lastFileTouchedOffset = offset + bytesRead;</b>
<b class="fc"><i class="no-highlight">1972</i>&nbsp;        }</b>
<b class="fc"><i class="no-highlight">1973</i>&nbsp;    }</b>
<i class="no-highlight">1974</i>&nbsp;
<i class="no-highlight">1975</i>&nbsp;    private void printLogBuffer(ByteBuffer entryBuffer, long lsn) {
<i class="no-highlight">1976</i>&nbsp;
<b class="nc"><i class="no-highlight">1977</i>&nbsp;        int curPos = entryBuffer.position();</b>
<i class="no-highlight">1978</i>&nbsp;
<b class="nc"><i class="no-highlight">1979</i>&nbsp;        while (entryBuffer.remaining() &gt; 0) {</b>
<i class="no-highlight">1980</i>&nbsp;
<b class="nc"><i class="no-highlight">1981</i>&nbsp;            int recStartPos = entryBuffer.position();</b>
<i class="no-highlight">1982</i>&nbsp;
<b class="nc"><i class="no-highlight">1983</i>&nbsp;            LogEntryHeader header = null;</b>
<i class="no-highlight">1984</i>&nbsp;
<i class="no-highlight">1985</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">1986</i>&nbsp;                header = new LogEntryHeader(</b>
<i class="no-highlight">1987</i>&nbsp;                    entryBuffer, LogEntryType.LOG_VERSION, lsn);
<b class="nc"><i class="no-highlight">1988</i>&nbsp;            } catch (ChecksumException e) {</b>
<b class="nc"><i class="no-highlight">1989</i>&nbsp;                System.err.println(&quot;ChecksumException in printLogBuffer &quot; + e);</b>
<b class="nc"><i class="no-highlight">1990</i>&nbsp;                break;</b>
<b class="nc"><i class="no-highlight">1991</i>&nbsp;            }</b>
<i class="no-highlight">1992</i>&nbsp;
<b class="nc"><i class="no-highlight">1993</i>&nbsp;            LogEntryType recType = LogEntryType.findType(header.getType());</b>
<b class="nc"><i class="no-highlight">1994</i>&nbsp;            int recSize = header.getSize() + header.getItemSize();</b>
<i class="no-highlight">1995</i>&nbsp;
<b class="nc"><i class="no-highlight">1996</i>&nbsp;            System.out.println(</b>
<b class="nc"><i class="no-highlight">1997</i>&nbsp;                &quot;LOGREC &quot; + recType.toStringNoVersion() +</b>
<b class="nc"><i class="no-highlight">1998</i>&nbsp;                &quot; at LSN &quot; + DbLsn.toString(lsn) +</b>
<i class="no-highlight">1999</i>&nbsp;                &quot; , log buffer offset &quot; + recStartPos);
<i class="no-highlight">2000</i>&nbsp;
<b class="nc"><i class="no-highlight">2001</i>&nbsp;            lsn += recSize;</b>
<i class="no-highlight">2002</i>&nbsp;
<b class="nc"><i class="no-highlight">2003</i>&nbsp;            entryBuffer.position(recStartPos + recSize);</b>
<b class="nc"><i class="no-highlight">2004</i>&nbsp;        }</b>
<i class="no-highlight">2005</i>&nbsp;
<b class="nc"><i class="no-highlight">2006</i>&nbsp;        entryBuffer.position(curPos);</b>
<b class="nc"><i class="no-highlight">2007</i>&nbsp;    }</b>
<i class="no-highlight">2008</i>&nbsp;
<i class="no-highlight">2009</i>&nbsp;    private void verifyChecksums(ByteBuffer entryBuffer,
<i class="no-highlight">2010</i>&nbsp;                                 long lsn,
<i class="no-highlight">2011</i>&nbsp;                                 String comment) {
<b class="nc"><i class="no-highlight">2012</i>&nbsp;        int curPos = entryBuffer.position();</b>
<i class="no-highlight">2013</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">2014</i>&nbsp;            while (entryBuffer.remaining() &gt; 0) {</b>
<b class="nc"><i class="no-highlight">2015</i>&nbsp;                int recStartPos = entryBuffer.position();</b>
<i class="no-highlight">2016</i>&nbsp;                /* Write buffer contains current log version entries. */
<b class="nc"><i class="no-highlight">2017</i>&nbsp;                LogEntryHeader header = new LogEntryHeader(</b>
<i class="no-highlight">2018</i>&nbsp;                    entryBuffer, LogEntryType.LOG_VERSION, lsn);
<b class="nc"><i class="no-highlight">2019</i>&nbsp;                verifyChecksum(entryBuffer, header, lsn, comment);</b>
<b class="nc"><i class="no-highlight">2020</i>&nbsp;                entryBuffer.position(recStartPos + header.getSize() +</b>
<b class="nc"><i class="no-highlight">2021</i>&nbsp;                                     header.getItemSize());</b>
<b class="nc"><i class="no-highlight">2022</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2023</i>&nbsp;        } catch (ChecksumException e) {</b>
<b class="nc"><i class="no-highlight">2024</i>&nbsp;            System.err.println(&quot;ChecksumException: (&quot; + comment + &quot;) &quot; + e);</b>
<b class="nc"><i class="no-highlight">2025</i>&nbsp;            System.err.println(&quot;start stack trace&quot;);</b>
<b class="nc"><i class="no-highlight">2026</i>&nbsp;            e.printStackTrace(System.err);</b>
<b class="nc"><i class="no-highlight">2027</i>&nbsp;            System.err.println(&quot;end stack trace&quot;);</b>
<b class="nc"><i class="no-highlight">2028</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2029</i>&nbsp;        entryBuffer.position(curPos);</b>
<b class="nc"><i class="no-highlight">2030</i>&nbsp;    }</b>
<i class="no-highlight">2031</i>&nbsp;
<i class="no-highlight">2032</i>&nbsp;    private void verifyChecksum(ByteBuffer entryBuffer,
<i class="no-highlight">2033</i>&nbsp;                                LogEntryHeader header,
<i class="no-highlight">2034</i>&nbsp;                                long lsn,
<i class="no-highlight">2035</i>&nbsp;                                String comment)
<i class="no-highlight">2036</i>&nbsp;        throws ChecksumException {
<i class="no-highlight">2037</i>&nbsp;
<b class="nc"><i class="no-highlight">2038</i>&nbsp;        ChecksumValidator validator = null;</b>
<i class="no-highlight">2039</i>&nbsp;        /* Add header to checksum bytes */
<b class="nc"><i class="no-highlight">2040</i>&nbsp;        validator = new ChecksumValidator();</b>
<b class="nc"><i class="no-highlight">2041</i>&nbsp;        int headerSizeMinusChecksum = header.getSizeMinusChecksum();</b>
<b class="nc"><i class="no-highlight">2042</i>&nbsp;        int itemStart = entryBuffer.position();</b>
<b class="nc"><i class="no-highlight">2043</i>&nbsp;        entryBuffer.position(itemStart - headerSizeMinusChecksum);</b>
<b class="nc"><i class="no-highlight">2044</i>&nbsp;        validator.update(entryBuffer, headerSizeMinusChecksum);</b>
<b class="nc"><i class="no-highlight">2045</i>&nbsp;        entryBuffer.position(itemStart);</b>
<i class="no-highlight">2046</i>&nbsp;
<i class="no-highlight">2047</i>&nbsp;        /*
<i class="no-highlight">2048</i>&nbsp;         * Now that we know the size, read the rest of the entry if the first
<i class="no-highlight">2049</i>&nbsp;         * read didn&#39;t get enough.
<i class="no-highlight">2050</i>&nbsp;         */
<b class="nc"><i class="no-highlight">2051</i>&nbsp;        int itemSize = header.getItemSize();</b>
<b class="nc"><i class="no-highlight">2052</i>&nbsp;        if (entryBuffer.remaining() &lt; itemSize) {</b>
<b class="nc"><i class="no-highlight">2053</i>&nbsp;            System.err.println(&quot;Couldn&#39;t verify checksum (&quot; + comment + &quot;)&quot;);</b>
<b class="nc"><i class="no-highlight">2054</i>&nbsp;            return;</b>
<i class="no-highlight">2055</i>&nbsp;        }
<i class="no-highlight">2056</i>&nbsp;
<i class="no-highlight">2057</i>&nbsp;        /*
<i class="no-highlight">2058</i>&nbsp;         * Do entry validation. Run checksum before checking the entry
<i class="no-highlight">2059</i>&nbsp;         * type, it will be the more encompassing error.
<i class="no-highlight">2060</i>&nbsp;         */
<b class="nc"><i class="no-highlight">2061</i>&nbsp;        validator.update(entryBuffer, itemSize);</b>
<b class="nc"><i class="no-highlight">2062</i>&nbsp;        validator.validate(header.getChecksum(), lsn);</b>
<b class="nc"><i class="no-highlight">2063</i>&nbsp;    }</b>
<i class="no-highlight">2064</i>&nbsp;
<i class="no-highlight">2065</i>&nbsp;    /**
<i class="no-highlight">2066</i>&nbsp;     * FSync the end of the log.
<i class="no-highlight">2067</i>&nbsp;     */
<i class="no-highlight">2068</i>&nbsp;    void syncLogEnd()
<i class="no-highlight">2069</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">2070</i>&nbsp;
<i class="no-highlight">2071</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">2072</i>&nbsp;            endOfLog.force();</b>
<b class="nc"><i class="no-highlight">2073</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">2074</i>&nbsp;            throw new LogWriteException</b>
<i class="no-highlight">2075</i>&nbsp;                (envImpl, &quot;IOException during fsync&quot;, e);
<b class="fc"><i class="no-highlight">2076</i>&nbsp;        }</b>
<b class="fc"><i class="no-highlight">2077</i>&nbsp;    }</b>
<i class="no-highlight">2078</i>&nbsp;
<i class="no-highlight">2079</i>&nbsp;    /**
<i class="no-highlight">2080</i>&nbsp;     * Sync the end of the log, close off this log file. Should only be called
<i class="no-highlight">2081</i>&nbsp;     * under the log write latch.
<i class="no-highlight">2082</i>&nbsp;     */
<i class="no-highlight">2083</i>&nbsp;    void syncLogEndAndFinishFile()
<i class="no-highlight">2084</i>&nbsp;        throws DatabaseException, IOException {
<i class="no-highlight">2085</i>&nbsp;
<b class="fc"><i class="no-highlight">2086</i>&nbsp;        if (syncAtFileEnd) {</b>
<b class="fc"><i class="no-highlight">2087</i>&nbsp;            syncLogEnd();</b>
<i class="no-highlight">2088</i>&nbsp;        }
<b class="fc"><i class="no-highlight">2089</i>&nbsp;        endOfLog.close();</b>
<b class="fc"><i class="no-highlight">2090</i>&nbsp;    }</b>
<i class="no-highlight">2091</i>&nbsp;
<i class="no-highlight">2092</i>&nbsp;    /**
<i class="no-highlight">2093</i>&nbsp;     * Returns whether anything is in the write queue.
<i class="no-highlight">2094</i>&nbsp;     */
<i class="no-highlight">2095</i>&nbsp;    public boolean hasQueuedWrites() {
<b class="nc"><i class="no-highlight">2096</i>&nbsp;        return endOfLog.hasQueuedWrites();</b>
<i class="no-highlight">2097</i>&nbsp;    }
<i class="no-highlight">2098</i>&nbsp;
<i class="no-highlight">2099</i>&nbsp;    /**
<i class="no-highlight">2100</i>&nbsp;     * For unit testing only.
<i class="no-highlight">2101</i>&nbsp;     */
<i class="no-highlight">2102</i>&nbsp;    public void testWriteQueueLock() {
<b class="nc"><i class="no-highlight">2103</i>&nbsp;        endOfLog.fsyncFileSynchronizer.lock();</b>
<b class="nc"><i class="no-highlight">2104</i>&nbsp;    }</b>
<i class="no-highlight">2105</i>&nbsp;
<i class="no-highlight">2106</i>&nbsp;    /**
<i class="no-highlight">2107</i>&nbsp;     * For unit testing only.
<i class="no-highlight">2108</i>&nbsp;     */
<i class="no-highlight">2109</i>&nbsp;    public void testWriteQueueUnlock() {
<b class="nc"><i class="no-highlight">2110</i>&nbsp;        endOfLog.fsyncFileSynchronizer.unlock();</b>
<b class="nc"><i class="no-highlight">2111</i>&nbsp;    }</b>
<i class="no-highlight">2112</i>&nbsp;
<i class="no-highlight">2113</i>&nbsp;    public void startFileCacheWarmer(final long recoveryStartLsn){
<b class="nc"><i class="no-highlight">2114</i>&nbsp;        assert fileCacheWarmer == null;</b>
<i class="no-highlight">2115</i>&nbsp;
<b class="nc"><i class="no-highlight">2116</i>&nbsp;        final DbConfigManager cm = envImpl.getConfigManager();</b>
<i class="no-highlight">2117</i>&nbsp;
<b class="nc"><i class="no-highlight">2118</i>&nbsp;        final int warmUpSize = cm.getInt(</b>
<i class="no-highlight">2119</i>&nbsp;            EnvironmentParams.LOG_FILE_WARM_UP_SIZE);
<i class="no-highlight">2120</i>&nbsp;
<b class="nc"><i class="no-highlight">2121</i>&nbsp;        if (warmUpSize == 0) {</b>
<b class="nc"><i class="no-highlight">2122</i>&nbsp;            return;</b>
<i class="no-highlight">2123</i>&nbsp;        }
<i class="no-highlight">2124</i>&nbsp;
<b class="nc"><i class="no-highlight">2125</i>&nbsp;        final int bufSize = cm.getInt(</b>
<i class="no-highlight">2126</i>&nbsp;            EnvironmentParams.LOG_FILE_WARM_UP_BUF_SIZE);
<i class="no-highlight">2127</i>&nbsp;
<b class="nc"><i class="no-highlight">2128</i>&nbsp;        fileCacheWarmer = new FileCacheWarmer(</b>
<i class="no-highlight">2129</i>&nbsp;            envImpl, recoveryStartLsn, lastUsedLsn, warmUpSize, bufSize);
<i class="no-highlight">2130</i>&nbsp;
<b class="nc"><i class="no-highlight">2131</i>&nbsp;        fileCacheWarmer.start();</b>
<b class="nc"><i class="no-highlight">2132</i>&nbsp;    }</b>
<i class="no-highlight">2133</i>&nbsp;
<i class="no-highlight">2134</i>&nbsp;    private void stopFileCacheWarmer(){
<i class="no-highlight">2135</i>&nbsp;
<i class="no-highlight">2136</i>&nbsp;        /*
<i class="no-highlight">2137</i>&nbsp;         * Use fcw local var because fileCacheWarmer can be set to null by
<i class="no-highlight">2138</i>&nbsp;         * other threads calling clearFileCacheWarmer, namely the cache warmer
<i class="no-highlight">2139</i>&nbsp;         * thread.
<i class="no-highlight">2140</i>&nbsp;         */
<b class="fc"><i class="no-highlight">2141</i>&nbsp;        final FileCacheWarmer fcw = fileCacheWarmer;</b>
<i class="no-highlight">2142</i>&nbsp;
<b class="fc"><i class="no-highlight">2143</i>&nbsp;        if (fcw == null) {</b>
<b class="fc"><i class="no-highlight">2144</i>&nbsp;            return;</b>
<i class="no-highlight">2145</i>&nbsp;        }
<i class="no-highlight">2146</i>&nbsp;
<b class="nc"><i class="no-highlight">2147</i>&nbsp;        fcw.shutdown();</b>
<i class="no-highlight">2148</i>&nbsp;
<b class="nc"><i class="no-highlight">2149</i>&nbsp;        clearFileCacheWarmer();</b>
<b class="nc"><i class="no-highlight">2150</i>&nbsp;    }</b>
<i class="no-highlight">2151</i>&nbsp;
<i class="no-highlight">2152</i>&nbsp;    /* Allow cache warmer thread to be GC&#39;d. */
<i class="no-highlight">2153</i>&nbsp;    void clearFileCacheWarmer() {
<b class="nc"><i class="no-highlight">2154</i>&nbsp;        fileCacheWarmer = null;</b>
<b class="nc"><i class="no-highlight">2155</i>&nbsp;    }</b>
<i class="no-highlight">2156</i>&nbsp;
<i class="no-highlight">2157</i>&nbsp;    /**
<i class="no-highlight">2158</i>&nbsp;     * Close all file handles and empty the cache.
<i class="no-highlight">2159</i>&nbsp;     */
<i class="no-highlight">2160</i>&nbsp;    public void clear()
<i class="no-highlight">2161</i>&nbsp;        throws IOException, DatabaseException {
<i class="no-highlight">2162</i>&nbsp;
<b class="fc"><i class="no-highlight">2163</i>&nbsp;        synchronized (fileCache) {</b>
<b class="fc"><i class="no-highlight">2164</i>&nbsp;            fileCache.clear();</b>
<b class="fc"><i class="no-highlight">2165</i>&nbsp;        }</b>
<i class="no-highlight">2166</i>&nbsp;
<b class="fc"><i class="no-highlight">2167</i>&nbsp;        endOfLog.close();</b>
<b class="fc"><i class="no-highlight">2168</i>&nbsp;    }</b>
<i class="no-highlight">2169</i>&nbsp;
<i class="no-highlight">2170</i>&nbsp;    /**
<i class="no-highlight">2171</i>&nbsp;     * Clear the file lock.
<i class="no-highlight">2172</i>&nbsp;     */
<i class="no-highlight">2173</i>&nbsp;    public void close()
<i class="no-highlight">2174</i>&nbsp;        throws IOException {
<i class="no-highlight">2175</i>&nbsp;
<b class="fc"><i class="no-highlight">2176</i>&nbsp;        stopFileCacheWarmer();</b>
<i class="no-highlight">2177</i>&nbsp;
<b class="fc"><i class="no-highlight">2178</i>&nbsp;        if (envLock != null) {</b>
<b class="fc"><i class="no-highlight">2179</i>&nbsp;            envLock.release();</b>
<b class="fc"><i class="no-highlight">2180</i>&nbsp;            envLock = null;</b>
<i class="no-highlight">2181</i>&nbsp;        }
<i class="no-highlight">2182</i>&nbsp;
<b class="fc"><i class="no-highlight">2183</i>&nbsp;        if (exclLock != null) {</b>
<b class="nc"><i class="no-highlight">2184</i>&nbsp;            exclLock.release();</b>
<b class="nc"><i class="no-highlight">2185</i>&nbsp;            exclLock = null;</b>
<i class="no-highlight">2186</i>&nbsp;        }
<i class="no-highlight">2187</i>&nbsp;
<b class="fc"><i class="no-highlight">2188</i>&nbsp;        if (channel != null) {</b>
<b class="fc"><i class="no-highlight">2189</i>&nbsp;            channel.close();</b>
<b class="fc"><i class="no-highlight">2190</i>&nbsp;            channel = null;</b>
<i class="no-highlight">2191</i>&nbsp;        }
<i class="no-highlight">2192</i>&nbsp;
<b class="fc"><i class="no-highlight">2193</i>&nbsp;        if (lockFile != null) {</b>
<b class="fc"><i class="no-highlight">2194</i>&nbsp;            lockFile.close();</b>
<b class="fc"><i class="no-highlight">2195</i>&nbsp;            lockFile = null;</b>
<i class="no-highlight">2196</i>&nbsp;        }
<i class="no-highlight">2197</i>&nbsp;        
<b class="fc"><i class="no-highlight">2198</i>&nbsp;        if (fdd != null) {</b>
<b class="fc"><i class="no-highlight">2199</i>&nbsp;            fdd.close();</b>
<i class="no-highlight">2200</i>&nbsp;        }
<b class="fc"><i class="no-highlight">2201</i>&nbsp;    }</b>
<i class="no-highlight">2202</i>&nbsp;
<i class="no-highlight">2203</i>&nbsp;    /**
<i class="no-highlight">2204</i>&nbsp;     * Lock the environment.  Return true if the lock was acquired.  If
<i class="no-highlight">2205</i>&nbsp;     * exclusive is false, then this implements a single writer, multiple
<i class="no-highlight">2206</i>&nbsp;     * reader lock.  If exclusive is true, then implement an exclusive lock.
<i class="no-highlight">2207</i>&nbsp;     *
<i class="no-highlight">2208</i>&nbsp;     * There is a lock file and there are two regions of the lock file: byte 0,
<i class="no-highlight">2209</i>&nbsp;     * and byte 1.  Byte 0 is the exclusive writer process area of the lock
<i class="no-highlight">2210</i>&nbsp;     * file.  If an environment is opened for write, then it attempts to take
<i class="no-highlight">2211</i>&nbsp;     * an exclusive write lock on byte 0.  Byte 1 is the shared reader process
<i class="no-highlight">2212</i>&nbsp;     * area of the lock file.  If an environment is opened for read-only, then
<i class="no-highlight">2213</i>&nbsp;     * it attempts to take a shared lock on byte 1.  This is how we implement
<i class="no-highlight">2214</i>&nbsp;     * single writer, multi reader semantics.
<i class="no-highlight">2215</i>&nbsp;     *
<i class="no-highlight">2216</i>&nbsp;     * The cleaner, each time it is invoked, attempts to take an exclusive lock
<i class="no-highlight">2217</i>&nbsp;     * on byte 1.  The owning process already either has an exclusive lock on
<i class="no-highlight">2218</i>&nbsp;     * byte 0, or a shared lock on byte 1.  This will necessarily conflict with
<i class="no-highlight">2219</i>&nbsp;     * any shared locks on byte 1, even if it&#39;s in the same process and there
<i class="no-highlight">2220</i>&nbsp;     * are no other holders of that shared lock.  So if there is only one
<i class="no-highlight">2221</i>&nbsp;     * read-only process, it will have byte 1 for shared access, and the
<i class="no-highlight">2222</i>&nbsp;     * cleaner can not run in it because it will attempt to get an exclusive
<i class="no-highlight">2223</i>&nbsp;     * lock on byte 1 (which is already locked for shared access by itself).
<i class="no-highlight">2224</i>&nbsp;     * If a write process comes along and tries to run the cleaner, it will
<i class="no-highlight">2225</i>&nbsp;     * attempt to get an exclusive lock on byte 1.  If there are no other
<i class="no-highlight">2226</i>&nbsp;     * reader processes (with shared locks on byte 1), and no other writers
<i class="no-highlight">2227</i>&nbsp;     * (which are running cleaners on with exclusive locks on byte 1), then the
<i class="no-highlight">2228</i>&nbsp;     * cleaner will run.
<i class="no-highlight">2229</i>&nbsp;     */
<i class="no-highlight">2230</i>&nbsp;    public boolean lockEnvironment(boolean rdOnly, boolean exclusive) {
<i class="no-highlight">2231</i>&nbsp;        try {
<b class="fc"><i class="no-highlight">2232</i>&nbsp;            if (checkEnvHomePermissions(rdOnly)) {</b>
<b class="nc"><i class="no-highlight">2233</i>&nbsp;                return true;</b>
<i class="no-highlight">2234</i>&nbsp;            }
<i class="no-highlight">2235</i>&nbsp;
<b class="fc"><i class="no-highlight">2236</i>&nbsp;            if (lockFile == null) {</b>
<b class="fc"><i class="no-highlight">2237</i>&nbsp;                lockFile =</b>
<i class="no-highlight">2238</i>&nbsp;                    new RandomAccessFile
<i class="no-highlight">2239</i>&nbsp;                    (new File(dbEnvHome, LOCK_FILE),
<b class="fc"><i class="no-highlight">2240</i>&nbsp;                     FileMode.READWRITE_MODE.getModeValue());</b>
<i class="no-highlight">2241</i>&nbsp;            }
<i class="no-highlight">2242</i>&nbsp;
<b class="fc"><i class="no-highlight">2243</i>&nbsp;            channel = lockFile.getChannel();</b>
<i class="no-highlight">2244</i>&nbsp;
<i class="no-highlight">2245</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">2246</i>&nbsp;                if (exclusive) {</b>
<i class="no-highlight">2247</i>&nbsp;
<i class="no-highlight">2248</i>&nbsp;                    /*
<i class="no-highlight">2249</i>&nbsp;                     * To lock exclusive, must have exclusive on
<i class="no-highlight">2250</i>&nbsp;                     * shared reader area (byte 1).
<i class="no-highlight">2251</i>&nbsp;                     */
<b class="nc"><i class="no-highlight">2252</i>&nbsp;                    exclLock = channel.tryLock(1, 1, false);</b>
<b class="nc"><i class="no-highlight">2253</i>&nbsp;                    if (exclLock == null) {</b>
<b class="nc"><i class="no-highlight">2254</i>&nbsp;                        return false;</b>
<i class="no-highlight">2255</i>&nbsp;                    }
<b class="nc"><i class="no-highlight">2256</i>&nbsp;                    return true;</b>
<i class="no-highlight">2257</i>&nbsp;                }
<b class="fc"><i class="no-highlight">2258</i>&nbsp;                if (rdOnly) {</b>
<b class="nc"><i class="no-highlight">2259</i>&nbsp;                    envLock = channel.tryLock(1, 1, true);</b>
<i class="no-highlight">2260</i>&nbsp;                } else {
<b class="fc"><i class="no-highlight">2261</i>&nbsp;                    envLock = channel.tryLock(0, 1, false);</b>
<i class="no-highlight">2262</i>&nbsp;                }
<b class="fc"><i class="no-highlight">2263</i>&nbsp;                if (envLock == null) {</b>
<b class="nc"><i class="no-highlight">2264</i>&nbsp;                    return false;</b>
<i class="no-highlight">2265</i>&nbsp;                }
<b class="fc"><i class="no-highlight">2266</i>&nbsp;                return true;</b>
<b class="nc"><i class="no-highlight">2267</i>&nbsp;            } catch (OverlappingFileLockException e) {</b>
<b class="nc"><i class="no-highlight">2268</i>&nbsp;                return false;</b>
<i class="no-highlight">2269</i>&nbsp;            }
<b class="nc"><i class="no-highlight">2270</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">2271</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">2272</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_INTEGRITY, e);
<i class="no-highlight">2273</i>&nbsp;        }
<i class="no-highlight">2274</i>&nbsp;    }
<i class="no-highlight">2275</i>&nbsp;
<i class="no-highlight">2276</i>&nbsp;    public void releaseExclusiveLock()
<i class="no-highlight">2277</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">2278</i>&nbsp;
<i class="no-highlight">2279</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">2280</i>&nbsp;            if (exclLock != null) {</b>
<b class="nc"><i class="no-highlight">2281</i>&nbsp;                exclLock.release();</b>
<i class="no-highlight">2282</i>&nbsp;            }
<b class="nc"><i class="no-highlight">2283</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">2284</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">2285</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_INTEGRITY, e);
<b class="nc"><i class="no-highlight">2286</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2287</i>&nbsp;    }</b>
<i class="no-highlight">2288</i>&nbsp;
<i class="no-highlight">2289</i>&nbsp;    /**
<i class="no-highlight">2290</i>&nbsp;     * Ensure that if the environment home dir is on readonly media or in a
<i class="no-highlight">2291</i>&nbsp;     * readonly directory that the environment has been opened for readonly
<i class="no-highlight">2292</i>&nbsp;     * access.
<i class="no-highlight">2293</i>&nbsp;     *
<i class="no-highlight">2294</i>&nbsp;     * @return true if the environment home dir is readonly.
<i class="no-highlight">2295</i>&nbsp;     *
<i class="no-highlight">2296</i>&nbsp;     * @throws IllegalArgumentException via Environment ctor
<i class="no-highlight">2297</i>&nbsp;     */
<i class="no-highlight">2298</i>&nbsp;    public boolean checkEnvHomePermissions(boolean rdOnly)
<i class="no-highlight">2299</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">2300</i>&nbsp;
<b class="fc"><i class="no-highlight">2301</i>&nbsp;        if (nDataDirs == 0) {</b>
<b class="fc"><i class="no-highlight">2302</i>&nbsp;            return checkEnvHomePermissionsSingleEnvDir(dbEnvHome, rdOnly);</b>
<i class="no-highlight">2303</i>&nbsp;        } else {
<b class="nc"><i class="no-highlight">2304</i>&nbsp;            return checkEnvHomePermissionsMultiEnvDir(rdOnly);</b>
<i class="no-highlight">2305</i>&nbsp;        }
<i class="no-highlight">2306</i>&nbsp;    }
<i class="no-highlight">2307</i>&nbsp;
<i class="no-highlight">2308</i>&nbsp;    private boolean checkEnvHomePermissionsSingleEnvDir(File dbEnvHome,
<i class="no-highlight">2309</i>&nbsp;                                                        boolean rdOnly)
<i class="no-highlight">2310</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">2311</i>&nbsp;
<b class="fc"><i class="no-highlight">2312</i>&nbsp;        boolean envDirIsReadOnly = !dbEnvHome.canWrite();</b>
<b class="fc"><i class="no-highlight">2313</i>&nbsp;        if (envDirIsReadOnly &amp;&amp; !rdOnly) {</b>
<i class="no-highlight">2314</i>&nbsp;
<i class="no-highlight">2315</i>&nbsp;            /*
<i class="no-highlight">2316</i>&nbsp;             * Use the absolute path in the exception message, to
<i class="no-highlight">2317</i>&nbsp;             * make a mis-specified relative path problem more obvious.
<i class="no-highlight">2318</i>&nbsp;             */
<b class="nc"><i class="no-highlight">2319</i>&nbsp;            throw new IllegalArgumentException</b>
<i class="no-highlight">2320</i>&nbsp;                (&quot;The Environment directory &quot; +
<b class="nc"><i class="no-highlight">2321</i>&nbsp;                 dbEnvHome.getAbsolutePath() +</b>
<i class="no-highlight">2322</i>&nbsp;                 &quot; is not writable, but the &quot; +
<i class="no-highlight">2323</i>&nbsp;                 &quot;Environment was opened for read-write access.&quot;);
<i class="no-highlight">2324</i>&nbsp;        }
<i class="no-highlight">2325</i>&nbsp;
<b class="fc"><i class="no-highlight">2326</i>&nbsp;        return envDirIsReadOnly;</b>
<i class="no-highlight">2327</i>&nbsp;    }
<i class="no-highlight">2328</i>&nbsp;
<i class="no-highlight">2329</i>&nbsp;    private boolean checkEnvHomePermissionsMultiEnvDir(boolean rdOnly)
<i class="no-highlight">2330</i>&nbsp;        throws DatabaseException {
<i class="no-highlight">2331</i>&nbsp;
<b class="nc"><i class="no-highlight">2332</i>&nbsp;        for (File dbEnvDir : dbEnvDataDirs) {</b>
<b class="nc"><i class="no-highlight">2333</i>&nbsp;            if (!checkEnvHomePermissionsSingleEnvDir(dbEnvDir, rdOnly)) {</b>
<b class="nc"><i class="no-highlight">2334</i>&nbsp;                return false;</b>
<i class="no-highlight">2335</i>&nbsp;            }
<i class="no-highlight">2336</i>&nbsp;        }
<i class="no-highlight">2337</i>&nbsp;
<b class="nc"><i class="no-highlight">2338</i>&nbsp;        return true;</b>
<i class="no-highlight">2339</i>&nbsp;    }
<i class="no-highlight">2340</i>&nbsp;
<i class="no-highlight">2341</i>&nbsp;    /**
<i class="no-highlight">2342</i>&nbsp;     * Truncate a log at this position. Used by recovery to a timestamp
<i class="no-highlight">2343</i>&nbsp;     * utilities and by recovery to set the end-of-log position, see
<i class="no-highlight">2344</i>&nbsp;     * LastFileReader.setEndOfFile().
<i class="no-highlight">2345</i>&nbsp;     *
<i class="no-highlight">2346</i>&nbsp;     * &lt;p&gt;This method forces a new log file to be written next, if the last
<i class="no-highlight">2347</i>&nbsp;     * file (the file truncated to) has an old version in its header. This
<i class="no-highlight">2348</i>&nbsp;     * ensures that when the log is opened by an old version of JE, a version
<i class="no-highlight">2349</i>&nbsp;     * incompatibility will be detected.  [#11243]&lt;/p&gt;
<i class="no-highlight">2350</i>&nbsp;     */
<i class="no-highlight">2351</i>&nbsp;    public void truncateSingleFile(long fileNum, long offset)
<i class="no-highlight">2352</i>&nbsp;        throws IOException, DatabaseException {
<i class="no-highlight">2353</i>&nbsp;
<i class="no-highlight">2354</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">2355</i>&nbsp;            FileHandle handle =</b>
<b class="nc"><i class="no-highlight">2356</i>&nbsp;                makeFileHandle(fileNum, getAppropriateReadWriteMode());</b>
<b class="nc"><i class="no-highlight">2357</i>&nbsp;            RandomAccessFile file = handle.getFile();</b>
<i class="no-highlight">2358</i>&nbsp;
<i class="no-highlight">2359</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">2360</i>&nbsp;                file.getChannel().truncate(offset);</b>
<i class="no-highlight">2361</i>&nbsp;            } finally {
<b class="nc"><i class="no-highlight">2362</i>&nbsp;                file.close();</b>
<b class="nc"><i class="no-highlight">2363</i>&nbsp;            }</b>
<i class="no-highlight">2364</i>&nbsp;
<b class="nc"><i class="no-highlight">2365</i>&nbsp;            if (handle.isOldHeaderVersion()) {</b>
<b class="nc"><i class="no-highlight">2366</i>&nbsp;                forceNewFile = true;</b>
<i class="no-highlight">2367</i>&nbsp;            }
<b class="nc"><i class="no-highlight">2368</i>&nbsp;        } catch (ChecksumException e) {</b>
<b class="nc"><i class="no-highlight">2369</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">2370</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_CHECKSUM, e);
<b class="nc"><i class="no-highlight">2371</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2372</i>&nbsp;    }</b>
<i class="no-highlight">2373</i>&nbsp;
<i class="no-highlight">2374</i>&nbsp;    /*
<i class="no-highlight">2375</i>&nbsp;     * Truncate all log entries after a specified log entry, the position of
<i class="no-highlight">2376</i>&nbsp;     * that entry is specified by the fileNum and offset, we do this to avoid
<i class="no-highlight">2377</i>&nbsp;     * the log file gap. Used by replication hard recovery and the
<i class="no-highlight">2378</i>&nbsp;     * DbTruncateLog utility, see SR [#19463].
<i class="no-highlight">2379</i>&nbsp;     */
<i class="no-highlight">2380</i>&nbsp;    public void truncateLog(long fileNum, long offset)
<i class="no-highlight">2381</i>&nbsp;        throws IOException, DatabaseException {
<i class="no-highlight">2382</i>&nbsp;
<i class="no-highlight">2383</i>&nbsp;        /*
<i class="no-highlight">2384</i>&nbsp;         * Truncate the log files following by this log file in descending
<i class="no-highlight">2385</i>&nbsp;         * order to avoid the log entry gap, see SR [#19463].
<i class="no-highlight">2386</i>&nbsp;         */
<b class="nc"><i class="no-highlight">2387</i>&nbsp;        for (long i = getLastFileNum(); i &gt;= fileNum; i--) {</b>
<i class="no-highlight">2388</i>&nbsp;            /* Do nothing if this file doesn&#39;t exist. */
<b class="nc"><i class="no-highlight">2389</i>&nbsp;            if (!isFileValid(i)) {</b>
<b class="nc"><i class="no-highlight">2390</i>&nbsp;                continue;</b>
<i class="no-highlight">2391</i>&nbsp;            }
<i class="no-highlight">2392</i>&nbsp;
<i class="no-highlight">2393</i>&nbsp;            /*
<i class="no-highlight">2394</i>&nbsp;             * If this is the file that truncation starts, invoke
<i class="no-highlight">2395</i>&nbsp;             * truncateSingleFile. If the offset is 0, which means the
<i class="no-highlight">2396</i>&nbsp;             * FileHeader is also deleted, delete the whole file to avoid a log
<i class="no-highlight">2397</i>&nbsp;             * file gap.
<i class="no-highlight">2398</i>&nbsp;             */
<b class="nc"><i class="no-highlight">2399</i>&nbsp;            if (i == fileNum) {</b>
<b class="nc"><i class="no-highlight">2400</i>&nbsp;                truncateSingleFile(fileNum, offset);</b>
<b class="nc"><i class="no-highlight">2401</i>&nbsp;                if (offset != 0) {</b>
<b class="nc"><i class="no-highlight">2402</i>&nbsp;                    continue;</b>
<i class="no-highlight">2403</i>&nbsp;                }
<i class="no-highlight">2404</i>&nbsp;            }
<i class="no-highlight">2405</i>&nbsp;
<b class="nc"><i class="no-highlight">2406</i>&nbsp;            boolean deleted = deleteFile(i);</b>
<b class="nc"><i class="no-highlight">2407</i>&nbsp;            assert deleted : &quot;File &quot; + getFullFileName(i, JE_SUFFIX) +</b>
<i class="no-highlight">2408</i>&nbsp;                             &quot; not deleted during truncateLog&quot;;
<i class="no-highlight">2409</i>&nbsp;        }
<b class="nc"><i class="no-highlight">2410</i>&nbsp;    }</b>
<i class="no-highlight">2411</i>&nbsp;
<i class="no-highlight">2412</i>&nbsp;    /**
<i class="no-highlight">2413</i>&nbsp;     * Mark the specified log entries as invisible and obsolete. The entries
<i class="no-highlight">2414</i>&nbsp;     * are written here, but are fsync&#39;ed later. If there is any problem or
<i class="no-highlight">2415</i>&nbsp;     * exception during the setting, the method will throw an
<i class="no-highlight">2416</i>&nbsp;     * EnvironmentFailureException.
<i class="no-highlight">2417</i>&nbsp;     *
<i class="no-highlight">2418</i>&nbsp;     * These changes are made directly to the file, but recently logged log
<i class="no-highlight">2419</i>&nbsp;     * entries may also be resident in the log buffers. The caller must take
<i class="no-highlight">2420</i>&nbsp;     * care to call LogManager.flush() before this method, to ensure that all
<i class="no-highlight">2421</i>&nbsp;     * entries are on disk.
<i class="no-highlight">2422</i>&nbsp;     *
<i class="no-highlight">2423</i>&nbsp;     * In addition, we must ensure that after this step, the affected log
<i class="no-highlight">2424</i>&nbsp;     * entries will only be read via a FileReader, and will not be faulted in
<i class="no-highlight">2425</i>&nbsp;     * by the LogManager. Entries may be present in the log and in the log
<i class="no-highlight">2426</i>&nbsp;     * buffers, but only the on disk version is modified by this method. The
<i class="no-highlight">2427</i>&nbsp;     * LogManager can read directly from the log buffers and may read the
<i class="no-highlight">2428</i>&nbsp;     * incorrect, non-invisible version of the log entry, rather than the
<i class="no-highlight">2429</i>&nbsp;     * invisible version from the file. This should not be an issue, because
<i class="no-highlight">2430</i>&nbsp;     * invisible log entries should be detached from the in-memory tree before
<i class="no-highlight">2431</i>&nbsp;     * they are made invisible.
<i class="no-highlight">2432</i>&nbsp;     *
<i class="no-highlight">2433</i>&nbsp;     * @param fileNum target file.
<i class="no-highlight">2434</i>&nbsp;     * @param lsns The list of LSNs to make invisible, must be sorted in
<i class="no-highlight">2435</i>&nbsp;     * ascending order.
<i class="no-highlight">2436</i>&nbsp;     */
<i class="no-highlight">2437</i>&nbsp;    public void makeInvisible(long fileNum, List&lt;Long&gt; lsns) {
<b class="nc"><i class="no-highlight">2438</i>&nbsp;        if (lsns.size() == 0) {</b>
<b class="nc"><i class="no-highlight">2439</i>&nbsp;            return;</b>
<i class="no-highlight">2440</i>&nbsp;        }
<i class="no-highlight">2441</i>&nbsp;
<i class="no-highlight">2442</i>&nbsp;        /* Open this file. */
<b class="nc"><i class="no-highlight">2443</i>&nbsp;        FileHandle handle = null;</b>
<i class="no-highlight">2444</i>&nbsp;        try {
<i class="no-highlight">2445</i>&nbsp;
<i class="no-highlight">2446</i>&nbsp;            /*
<i class="no-highlight">2447</i>&nbsp;             * Note that we are getting a new, non-cached file handle for
<i class="no-highlight">2448</i>&nbsp;             * specific use by this method.
<i class="no-highlight">2449</i>&nbsp;             */
<b class="nc"><i class="no-highlight">2450</i>&nbsp;            handle = makeFileHandle(fileNum, getAppropriateReadWriteMode());</b>
<b class="nc"><i class="no-highlight">2451</i>&nbsp;        } catch (ChecksumException e) {</b>
<b class="nc"><i class="no-highlight">2452</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">2453</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_CHECKSUM,
<i class="no-highlight">2454</i>&nbsp;                 &quot;Opening file &quot; + fileNum +  &quot; for invisible marking &quot;, e);
<b class="nc"><i class="no-highlight">2455</i>&nbsp;        } catch (FileNotFoundException e) {</b>
<b class="nc"><i class="no-highlight">2456</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">2457</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_FILE_NOT_FOUND,
<i class="no-highlight">2458</i>&nbsp;                 &quot;Opening file &quot; + fileNum +  &quot; for invisible marking &quot;, e);
<b class="nc"><i class="no-highlight">2459</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2460</i>&nbsp;        RandomAccessFile file = handle.getFile();</b>
<i class="no-highlight">2461</i>&nbsp;
<i class="no-highlight">2462</i>&nbsp;        /* Set the invisible bit for each entry. */
<i class="no-highlight">2463</i>&nbsp;        try {
<b class="nc"><i class="no-highlight">2464</i>&nbsp;            for (Long lsn : lsns) {</b>
<b class="nc"><i class="no-highlight">2465</i>&nbsp;                if (DbLsn.getFileNumber(lsn) != fileNum) {</b>
<i class="no-highlight">2466</i>&nbsp;
<i class="no-highlight">2467</i>&nbsp;                    /*
<i class="no-highlight">2468</i>&nbsp;                     * This failure will not invalidate the environment right
<i class="no-highlight">2469</i>&nbsp;                     * away. But since it causes replication syncup to fail,
<i class="no-highlight">2470</i>&nbsp;                     * the environment will shutdown, which is the effect we
<i class="no-highlight">2471</i>&nbsp;                     * want.
<i class="no-highlight">2472</i>&nbsp;                     */
<b class="nc"><i class="no-highlight">2473</i>&nbsp;                    throw new EnvironmentFailureException</b>
<i class="no-highlight">2474</i>&nbsp;                        (envImpl, EnvironmentFailureReason.UNEXPECTED_STATE,
<b class="nc"><i class="no-highlight">2475</i>&nbsp;                         &quot;LSN of &quot; + DbLsn.getNoFormatString(lsn) +</b>
<i class="no-highlight">2476</i>&nbsp;                         &quot; did not match file number&quot; + fileNum);
<i class="no-highlight">2477</i>&nbsp;                }
<i class="no-highlight">2478</i>&nbsp;
<b class="nc"><i class="no-highlight">2479</i>&nbsp;                int entryFlagsOffset = (int)</b>
<b class="nc"><i class="no-highlight">2480</i>&nbsp;                    (DbLsn.getFileOffset(lsn) + LogEntryHeader.FLAGS_OFFSET);</b>
<b class="nc"><i class="no-highlight">2481</i>&nbsp;                file.seek(entryFlagsOffset);</b>
<b class="nc"><i class="no-highlight">2482</i>&nbsp;                byte flags = file.readByte();</b>
<b class="nc"><i class="no-highlight">2483</i>&nbsp;                byte newFlags = LogEntryHeader.makeInvisible(flags);</b>
<b class="nc"><i class="no-highlight">2484</i>&nbsp;                file.seek(entryFlagsOffset);</b>
<b class="nc"><i class="no-highlight">2485</i>&nbsp;                file.writeByte(newFlags);</b>
<b class="nc"><i class="no-highlight">2486</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2487</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">2488</i>&nbsp;            throw new EnvironmentFailureException</b>
<i class="no-highlight">2489</i>&nbsp;                (envImpl, EnvironmentFailureReason.LOG_WRITE,
<i class="no-highlight">2490</i>&nbsp;                 &quot;Flipping invisibility in file &quot; + fileNum, e);
<i class="no-highlight">2491</i>&nbsp;        } finally {
<i class="no-highlight">2492</i>&nbsp;
<i class="no-highlight">2493</i>&nbsp;            /*
<i class="no-highlight">2494</i>&nbsp;             * Just close the file. Fsyncs will be done later on, in the hope
<i class="no-highlight">2495</i>&nbsp;             * that the OS has already synced asynchronously.
<i class="no-highlight">2496</i>&nbsp;             */
<b class="nc"><i class="no-highlight">2497</i>&nbsp;            try {</b>
<b class="nc"><i class="no-highlight">2498</i>&nbsp;                file.close();</b>
<b class="nc"><i class="no-highlight">2499</i>&nbsp;            } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">2500</i>&nbsp;                throw new EnvironmentFailureException</b>
<i class="no-highlight">2501</i>&nbsp;                    (envImpl, EnvironmentFailureReason.LOG_WRITE,
<i class="no-highlight">2502</i>&nbsp;                     &quot;Closing after invisibility cloaking: file &quot; + fileNum, e);
<b class="nc"><i class="no-highlight">2503</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2504</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2505</i>&nbsp;    }</b>
<i class="no-highlight">2506</i>&nbsp;
<i class="no-highlight">2507</i>&nbsp;    /**
<i class="no-highlight">2508</i>&nbsp;     * Fsync this set of log files. Used for replication syncup rollback.
<i class="no-highlight">2509</i>&nbsp;     */
<i class="no-highlight">2510</i>&nbsp;    public void force(Set&lt;Long&gt; fileNums) {
<b class="nc"><i class="no-highlight">2511</i>&nbsp;        for (long fileNum : fileNums) {</b>
<b class="nc"><i class="no-highlight">2512</i>&nbsp;            RandomAccessFile file = null;</b>
<i class="no-highlight">2513</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">2514</i>&nbsp;                FileHandle handle =</b>
<b class="nc"><i class="no-highlight">2515</i>&nbsp;                    makeFileHandle(fileNum, getAppropriateReadWriteMode());</b>
<b class="nc"><i class="no-highlight">2516</i>&nbsp;                file = handle.getFile();</b>
<b class="nc"><i class="no-highlight">2517</i>&nbsp;                file.getChannel().force(false);</b>
<b class="nc"><i class="no-highlight">2518</i>&nbsp;                nLogFSyncs.increment();</b>
<b class="nc"><i class="no-highlight">2519</i>&nbsp;            } catch (FileNotFoundException e) {</b>
<b class="nc"><i class="no-highlight">2520</i>&nbsp;                throw new EnvironmentFailureException</b>
<i class="no-highlight">2521</i>&nbsp;                    (envImpl, EnvironmentFailureReason.LOG_FILE_NOT_FOUND,
<i class="no-highlight">2522</i>&nbsp;                     &quot;Invisible fsyncing file &quot; + fileNum, e);
<b class="nc"><i class="no-highlight">2523</i>&nbsp;            } catch (ChecksumException e) {</b>
<b class="nc"><i class="no-highlight">2524</i>&nbsp;                throw new EnvironmentFailureException</b>
<i class="no-highlight">2525</i>&nbsp;                    (envImpl, EnvironmentFailureReason.LOG_CHECKSUM,
<i class="no-highlight">2526</i>&nbsp;                     &quot;Invisible fsyncing file &quot; + fileNum, e);
<b class="nc"><i class="no-highlight">2527</i>&nbsp;            } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">2528</i>&nbsp;                throw new EnvironmentFailureException</b>
<i class="no-highlight">2529</i>&nbsp;                    (envImpl, EnvironmentFailureReason.LOG_WRITE,
<i class="no-highlight">2530</i>&nbsp;                     &quot;Invisible fsyncing file &quot; + fileNum, e);
<i class="no-highlight">2531</i>&nbsp;            } finally {
<b class="nc"><i class="no-highlight">2532</i>&nbsp;                if (file != null) {</b>
<i class="no-highlight">2533</i>&nbsp;                    try {
<b class="nc"><i class="no-highlight">2534</i>&nbsp;                        file.close();</b>
<b class="nc"><i class="no-highlight">2535</i>&nbsp;                    } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">2536</i>&nbsp;                        throw new EnvironmentFailureException</b>
<i class="no-highlight">2537</i>&nbsp;                            (envImpl, EnvironmentFailureReason.LOG_WRITE,
<i class="no-highlight">2538</i>&nbsp;                             &quot;Invisible fsyncing file &quot; + fileNum, e);
<b class="nc"><i class="no-highlight">2539</i>&nbsp;                    }</b>
<i class="no-highlight">2540</i>&nbsp;                }
<b class="nc"><i class="no-highlight">2541</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2542</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2543</i>&nbsp;    }</b>
<i class="no-highlight">2544</i>&nbsp;
<i class="no-highlight">2545</i>&nbsp;    /**
<i class="no-highlight">2546</i>&nbsp;     * Set the flag that causes a new file to be written before the next write.
<i class="no-highlight">2547</i>&nbsp;     */
<i class="no-highlight">2548</i>&nbsp;    public void forceNewLogFile() {
<b class="nc"><i class="no-highlight">2549</i>&nbsp;        forceNewFile = true;</b>
<b class="nc"><i class="no-highlight">2550</i>&nbsp;    }</b>
<i class="no-highlight">2551</i>&nbsp;
<i class="no-highlight">2552</i>&nbsp;    /**
<i class="no-highlight">2553</i>&nbsp;     * Return the offset of the first log entry after the file header.
<i class="no-highlight">2554</i>&nbsp;     *
<i class="no-highlight">2555</i>&nbsp;     * @return the size in bytes of the file header log entry.
<i class="no-highlight">2556</i>&nbsp;     */
<i class="no-highlight">2557</i>&nbsp;    public static int firstLogEntryOffset() {
<b class="fc"><i class="no-highlight">2558</i>&nbsp;        return FileHeader.entrySize() + LogEntryHeader.MIN_HEADER_SIZE;</b>
<i class="no-highlight">2559</i>&nbsp;    }
<i class="no-highlight">2560</i>&nbsp;
<i class="no-highlight">2561</i>&nbsp;    /**
<i class="no-highlight">2562</i>&nbsp;     * Return the next available LSN in the log. Note that this is
<i class="no-highlight">2563</i>&nbsp;     * unsynchronized, so if it is called outside the log write latch it is
<i class="no-highlight">2564</i>&nbsp;     * only valid as an approximation.
<i class="no-highlight">2565</i>&nbsp;     */
<i class="no-highlight">2566</i>&nbsp;    public long getNextLsn() {
<b class="fc"><i class="no-highlight">2567</i>&nbsp;        return nextAvailableLsn;</b>
<i class="no-highlight">2568</i>&nbsp;    }
<i class="no-highlight">2569</i>&nbsp;
<i class="no-highlight">2570</i>&nbsp;    /**
<i class="no-highlight">2571</i>&nbsp;     * Return the last allocated LSN in the log. Note that this is
<i class="no-highlight">2572</i>&nbsp;     * unsynchronized, so if it is called outside the log write latch it is
<i class="no-highlight">2573</i>&nbsp;     * only valid as an approximation.
<i class="no-highlight">2574</i>&nbsp;     */
<i class="no-highlight">2575</i>&nbsp;    public long getLastUsedLsn() {
<b class="fc"><i class="no-highlight">2576</i>&nbsp;        return lastUsedLsn;</b>
<i class="no-highlight">2577</i>&nbsp;    }
<i class="no-highlight">2578</i>&nbsp;
<i class="no-highlight">2579</i>&nbsp;    StatGroup loadStats(StatsConfig config) {
<b class="nc"><i class="no-highlight">2580</i>&nbsp;        nOpenFiles.set(fileCache.size());</b>
<b class="nc"><i class="no-highlight">2581</i>&nbsp;        StatGroup copyStats = stats.cloneGroup(config.getClear());</b>
<i class="no-highlight">2582</i>&nbsp;
<b class="nc"><i class="no-highlight">2583</i>&nbsp;        return copyStats;</b>
<i class="no-highlight">2584</i>&nbsp;    }
<i class="no-highlight">2585</i>&nbsp;
<i class="no-highlight">2586</i>&nbsp;    /*
<i class="no-highlight">2587</i>&nbsp;     * Unit test support
<i class="no-highlight">2588</i>&nbsp;     */
<i class="no-highlight">2589</i>&nbsp;
<i class="no-highlight">2590</i>&nbsp;    /*
<i class="no-highlight">2591</i>&nbsp;     * @return ids of files in cache
<i class="no-highlight">2592</i>&nbsp;     */
<i class="no-highlight">2593</i>&nbsp;    Set&lt;Long&gt; getCacheKeys() {
<b class="nc"><i class="no-highlight">2594</i>&nbsp;        return fileCache.getCacheKeys();</b>
<i class="no-highlight">2595</i>&nbsp;    }
<i class="no-highlight">2596</i>&nbsp;
<i class="no-highlight">2597</i>&nbsp;    /**
<i class="no-highlight">2598</i>&nbsp;     * Clear a file out of the file cache regardless of mode type.
<i class="no-highlight">2599</i>&nbsp;     */
<i class="no-highlight">2600</i>&nbsp;    private void clearFileCache(long fileNum)
<i class="no-highlight">2601</i>&nbsp;        throws IOException, DatabaseException {
<i class="no-highlight">2602</i>&nbsp;
<b class="nc"><i class="no-highlight">2603</i>&nbsp;        synchronized (fileCache) {</b>
<b class="nc"><i class="no-highlight">2604</i>&nbsp;            fileCache.remove(fileNum);</b>
<b class="nc"><i class="no-highlight">2605</i>&nbsp;        }</b>
<b class="nc"><i class="no-highlight">2606</i>&nbsp;    }</b>
<i class="no-highlight">2607</i>&nbsp;
<i class="no-highlight">2608</i>&nbsp;    /*
<i class="no-highlight">2609</i>&nbsp;     * The file cache keeps N RandomAccessFile objects cached for file
<i class="no-highlight">2610</i>&nbsp;     * access. The cache consists of two parts: a Hashtable that doesn&#39;t
<i class="no-highlight">2611</i>&nbsp;     * require extra synchronization, for the most common access, and a linked
<i class="no-highlight">2612</i>&nbsp;     * list of files to support cache administration. Looking up a file from
<i class="no-highlight">2613</i>&nbsp;     * the hash table doesn&#39;t require extra latching, but adding or deleting a
<i class="no-highlight">2614</i>&nbsp;     * file does.
<i class="no-highlight">2615</i>&nbsp;     */
<b class="fc"><i class="no-highlight">2616</i>&nbsp;    private static class FileCache {</b>
<i class="no-highlight">2617</i>&nbsp;        private final Map&lt;Long, FileHandle&gt; fileMap;            // Long-&gt;file
<i class="no-highlight">2618</i>&nbsp;        private final List&lt;Long&gt; fileList;    // list of file numbers
<i class="no-highlight">2619</i>&nbsp;        private final int fileCacheSize;
<i class="no-highlight">2620</i>&nbsp;
<b class="fc"><i class="no-highlight">2621</i>&nbsp;        FileCache(DbConfigManager configManager) {</b>
<i class="no-highlight">2622</i>&nbsp;
<i class="no-highlight">2623</i>&nbsp;            /*
<i class="no-highlight">2624</i>&nbsp;             * A fileMap maps the file number to FileHandles (RandomAccessFile,
<i class="no-highlight">2625</i>&nbsp;             * latch). The fileList is a list of Longs to determine which files
<i class="no-highlight">2626</i>&nbsp;             * to eject out of the file cache if it&#39;s too small.
<i class="no-highlight">2627</i>&nbsp;             */
<b class="fc"><i class="no-highlight">2628</i>&nbsp;            fileMap = new Hashtable&lt;Long, FileHandle&gt;();</b>
<b class="fc"><i class="no-highlight">2629</i>&nbsp;            fileList = new LinkedList&lt;Long&gt;();</b>
<b class="fc"><i class="no-highlight">2630</i>&nbsp;            fileCacheSize =</b>
<b class="fc"><i class="no-highlight">2631</i>&nbsp;                configManager.getInt(EnvironmentParams.LOG_FILE_CACHE_SIZE);</b>
<b class="fc"><i class="no-highlight">2632</i>&nbsp;        }</b>
<i class="no-highlight">2633</i>&nbsp;
<i class="no-highlight">2634</i>&nbsp;        private FileHandle get(Long fileId) {
<b class="fc"><i class="no-highlight">2635</i>&nbsp;            return fileMap.get(fileId);</b>
<i class="no-highlight">2636</i>&nbsp;        }
<i class="no-highlight">2637</i>&nbsp;
<i class="no-highlight">2638</i>&nbsp;        private void add(Long fileId, FileHandle fileHandle)
<i class="no-highlight">2639</i>&nbsp;            throws IOException, DatabaseException {
<i class="no-highlight">2640</i>&nbsp;
<i class="no-highlight">2641</i>&nbsp;            /*
<i class="no-highlight">2642</i>&nbsp;             * Does the cache have any room or do we have to evict?  Hunt down
<i class="no-highlight">2643</i>&nbsp;             * the file list for an unused file. Note that the file cache might
<i class="no-highlight">2644</i>&nbsp;             * actually grow past the prescribed size if there is nothing
<i class="no-highlight">2645</i>&nbsp;             * evictable. Should we try to shrink the file cache? Presently if
<i class="no-highlight">2646</i>&nbsp;             * it grows, it doesn&#39;t shrink.
<i class="no-highlight">2647</i>&nbsp;             */
<b class="fc"><i class="no-highlight">2648</i>&nbsp;            if (fileList.size() &gt;= fileCacheSize) {</b>
<b class="nc"><i class="no-highlight">2649</i>&nbsp;                Iterator&lt;Long&gt; iter = fileList.iterator();</b>
<b class="nc"><i class="no-highlight">2650</i>&nbsp;                while (iter.hasNext()) {</b>
<b class="nc"><i class="no-highlight">2651</i>&nbsp;                    Long evictId = iter.next();</b>
<b class="nc"><i class="no-highlight">2652</i>&nbsp;                    FileHandle evictTarget = fileMap.get(evictId);</b>
<i class="no-highlight">2653</i>&nbsp;
<i class="no-highlight">2654</i>&nbsp;                    /*
<i class="no-highlight">2655</i>&nbsp;                     * Try to latch. If latchNoWait returns false, then another
<i class="no-highlight">2656</i>&nbsp;                     * thread owns this latch. Note that a thread that&#39;s trying
<i class="no-highlight">2657</i>&nbsp;                     * to get a new file handle should never already own the
<i class="no-highlight">2658</i>&nbsp;                     * latch on another file handle, because these latches are
<i class="no-highlight">2659</i>&nbsp;                     * meant to be short lived and only held over the i/o out
<i class="no-highlight">2660</i>&nbsp;                     * of the file.
<i class="no-highlight">2661</i>&nbsp;                     */
<b class="nc"><i class="no-highlight">2662</i>&nbsp;                    if (evictTarget.latchNoWait()) {</b>
<i class="no-highlight">2663</i>&nbsp;                        try {
<b class="nc"><i class="no-highlight">2664</i>&nbsp;                            fileMap.remove(evictId);</b>
<b class="nc"><i class="no-highlight">2665</i>&nbsp;                            iter.remove();</b>
<b class="nc"><i class="no-highlight">2666</i>&nbsp;                            evictTarget.close();</b>
<i class="no-highlight">2667</i>&nbsp;                        } finally {
<b class="nc"><i class="no-highlight">2668</i>&nbsp;                            evictTarget.release();</b>
<b class="nc"><i class="no-highlight">2669</i>&nbsp;                        }</b>
<b class="nc"><i class="no-highlight">2670</i>&nbsp;                        break;</b>
<i class="no-highlight">2671</i>&nbsp;                    }
<b class="nc"><i class="no-highlight">2672</i>&nbsp;                }</b>
<i class="no-highlight">2673</i>&nbsp;            }
<i class="no-highlight">2674</i>&nbsp;
<i class="no-highlight">2675</i>&nbsp;            /*
<i class="no-highlight">2676</i>&nbsp;             * We&#39;ve done our best to evict. Add the file the the cache now
<i class="no-highlight">2677</i>&nbsp;             * whether or not we did evict.
<i class="no-highlight">2678</i>&nbsp;             */
<b class="fc"><i class="no-highlight">2679</i>&nbsp;            fileList.add(fileId);</b>
<b class="fc"><i class="no-highlight">2680</i>&nbsp;            fileMap.put(fileId, fileHandle);</b>
<b class="fc"><i class="no-highlight">2681</i>&nbsp;        }</b>
<i class="no-highlight">2682</i>&nbsp;
<i class="no-highlight">2683</i>&nbsp;        /**
<i class="no-highlight">2684</i>&nbsp;         * Take any file handles corresponding to this file name out of the
<i class="no-highlight">2685</i>&nbsp;         * cache. A file handle could be there twice, in rd only and in r/w
<i class="no-highlight">2686</i>&nbsp;         * mode.
<i class="no-highlight">2687</i>&nbsp;         */
<i class="no-highlight">2688</i>&nbsp;        private void remove(long fileNum)
<i class="no-highlight">2689</i>&nbsp;            throws IOException, DatabaseException {
<i class="no-highlight">2690</i>&nbsp;
<b class="nc"><i class="no-highlight">2691</i>&nbsp;            Iterator&lt;Long&gt; iter = fileList.iterator();</b>
<b class="nc"><i class="no-highlight">2692</i>&nbsp;            while (iter.hasNext()) {</b>
<b class="nc"><i class="no-highlight">2693</i>&nbsp;                Long evictId = iter.next();</b>
<b class="nc"><i class="no-highlight">2694</i>&nbsp;                if (evictId.longValue() == fileNum) {</b>
<b class="nc"><i class="no-highlight">2695</i>&nbsp;                    FileHandle evictTarget = fileMap.get(evictId);</b>
<i class="no-highlight">2696</i>&nbsp;                    try {
<b class="nc"><i class="no-highlight">2697</i>&nbsp;                        evictTarget.latch();</b>
<b class="nc"><i class="no-highlight">2698</i>&nbsp;                        fileMap.remove(evictId);</b>
<b class="nc"><i class="no-highlight">2699</i>&nbsp;                        iter.remove();</b>
<b class="nc"><i class="no-highlight">2700</i>&nbsp;                        evictTarget.close();</b>
<i class="no-highlight">2701</i>&nbsp;                    } finally {
<b class="nc"><i class="no-highlight">2702</i>&nbsp;                        evictTarget.release();</b>
<b class="nc"><i class="no-highlight">2703</i>&nbsp;                    }</b>
<i class="no-highlight">2704</i>&nbsp;                }
<b class="nc"><i class="no-highlight">2705</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2706</i>&nbsp;        }</b>
<i class="no-highlight">2707</i>&nbsp;
<i class="no-highlight">2708</i>&nbsp;        private void clear()
<i class="no-highlight">2709</i>&nbsp;            throws IOException, DatabaseException {
<i class="no-highlight">2710</i>&nbsp;
<b class="fc"><i class="no-highlight">2711</i>&nbsp;            Iterator&lt;FileHandle&gt; iter = fileMap.values().iterator();</b>
<b class="fc"><i class="no-highlight">2712</i>&nbsp;            while (iter.hasNext()) {</b>
<b class="fc"><i class="no-highlight">2713</i>&nbsp;                FileHandle fileHandle = iter.next();</b>
<i class="no-highlight">2714</i>&nbsp;                try {
<b class="fc"><i class="no-highlight">2715</i>&nbsp;                    fileHandle.latch();</b>
<b class="fc"><i class="no-highlight">2716</i>&nbsp;                    fileHandle.close();</b>
<b class="fc"><i class="no-highlight">2717</i>&nbsp;                    iter.remove();</b>
<i class="no-highlight">2718</i>&nbsp;                } finally {
<b class="fc"><i class="no-highlight">2719</i>&nbsp;                    fileHandle.release();</b>
<b class="fc"><i class="no-highlight">2720</i>&nbsp;                }</b>
<b class="fc"><i class="no-highlight">2721</i>&nbsp;            }</b>
<b class="fc"><i class="no-highlight">2722</i>&nbsp;            fileMap.clear();</b>
<b class="fc"><i class="no-highlight">2723</i>&nbsp;            fileList.clear();</b>
<b class="fc"><i class="no-highlight">2724</i>&nbsp;        }</b>
<i class="no-highlight">2725</i>&nbsp;
<i class="no-highlight">2726</i>&nbsp;        private Set&lt;Long&gt; getCacheKeys() {
<b class="nc"><i class="no-highlight">2727</i>&nbsp;            return fileMap.keySet();</b>
<i class="no-highlight">2728</i>&nbsp;        }
<i class="no-highlight">2729</i>&nbsp;
<i class="no-highlight">2730</i>&nbsp;        private int size() {
<b class="nc"><i class="no-highlight">2731</i>&nbsp;            return fileMap.size();</b>
<i class="no-highlight">2732</i>&nbsp;        }
<i class="no-highlight">2733</i>&nbsp;    }
<i class="no-highlight">2734</i>&nbsp;
<i class="no-highlight">2735</i>&nbsp;    /**
<i class="no-highlight">2736</i>&nbsp;     * The LogEndFileDescriptor is used to write and fsync the end of the log.
<i class="no-highlight">2737</i>&nbsp;     * Because the JE log is append only, there is only one logical R/W file
<i class="no-highlight">2738</i>&nbsp;     * descriptor for the whole environment. This class actually implements two
<i class="no-highlight">2739</i>&nbsp;     * RandomAccessFile instances, one for writing and one for fsyncing, so the
<i class="no-highlight">2740</i>&nbsp;     * two types of operations don&#39;t block each other.
<i class="no-highlight">2741</i>&nbsp;     *
<i class="no-highlight">2742</i>&nbsp;     * The write file descriptor is considered the master.  Manipulation of
<i class="no-highlight">2743</i>&nbsp;     * this class is done under the log write latch. Here&#39;s an explanation of
<i class="no-highlight">2744</i>&nbsp;     * why the log write latch is sufficient to safeguard all operations.
<i class="no-highlight">2745</i>&nbsp;     *
<i class="no-highlight">2746</i>&nbsp;     * There are two types of callers who may use this file descriptor: the
<i class="no-highlight">2747</i>&nbsp;     * thread that is currently writing to the end of the log and any threads
<i class="no-highlight">2748</i>&nbsp;     * that are fsyncing on behalf of the FSyncManager.
<i class="no-highlight">2749</i>&nbsp;     *
<i class="no-highlight">2750</i>&nbsp;     * The writing thread appends data to the file and fsyncs the file when we
<i class="no-highlight">2751</i>&nbsp;     * flip over to a new log file.  The file is only instantiated at the point
<i class="no-highlight">2752</i>&nbsp;     * that it must do so -- which is either when the first fsync is required
<i class="no-highlight">2753</i>&nbsp;     * by JE or when the log file is full and we flip files.  Therefore, the
<i class="no-highlight">2754</i>&nbsp;     * writing thread has two actions that change this descriptor -- we
<i class="no-highlight">2755</i>&nbsp;     * initialize the file descriptor for the given log file at the first write
<i class="no-highlight">2756</i>&nbsp;     * to the file, and we close the file descriptor when the log file is full.
<i class="no-highlight">2757</i>&nbsp;     * Therefore is a period when there is no log descriptor -- when we have
<i class="no-highlight">2758</i>&nbsp;     * not yet written a log buffer into a given log file.
<i class="no-highlight">2759</i>&nbsp;     *
<i class="no-highlight">2760</i>&nbsp;     * The fsyncing threads ask for the log end file descriptor asynchronously,
<i class="no-highlight">2761</i>&nbsp;     * but will never modify it.  These threads may arrive at the point when
<i class="no-highlight">2762</i>&nbsp;     * the file descriptor is null, and therefore skip their fysnc, but that is
<i class="no-highlight">2763</i>&nbsp;     * fine because it means a writing thread already flipped that target file
<i class="no-highlight">2764</i>&nbsp;     * and has moved on to the next file.
<i class="no-highlight">2765</i>&nbsp;     *
<i class="no-highlight">2766</i>&nbsp;     * Time     Activity
<i class="no-highlight">2767</i>&nbsp;     * 10       thread 1 writes log entry A into file 0x0, issues fsync
<i class="no-highlight">2768</i>&nbsp;     *          outside of log write latch, yields the processor
<i class="no-highlight">2769</i>&nbsp;     * 20       thread 2 writes log entry B, piggybacks off thread 1
<i class="no-highlight">2770</i>&nbsp;     * 30       thread 3 writes log entry C, but no room left in that file,
<i class="no-highlight">2771</i>&nbsp;     *          so it flips the log, and fsyncs file 0x0, all under the log
<i class="no-highlight">2772</i>&nbsp;     *          write latch. It nulls out endOfLogRWFile, moves onto file
<i class="no-highlight">2773</i>&nbsp;     *          0x1, but doesn&#39;t create the file yet.
<i class="no-highlight">2774</i>&nbsp;     * 40       thread 1 finally comes along, but endOfLogRWFile is null--
<i class="no-highlight">2775</i>&nbsp;     *          no need to fsync in that case, 0x0 got fsynced.
<i class="no-highlight">2776</i>&nbsp;     *
<i class="no-highlight">2777</i>&nbsp;     * If a write is attempted and an fsync is already in progress, then the
<i class="no-highlight">2778</i>&nbsp;     * information pertaining to the data to be written (data, offset, length)
<i class="no-highlight">2779</i>&nbsp;     * is saved away in the &quot;queuedWrites&quot; array.  When the fsync completes,
<i class="no-highlight">2780</i>&nbsp;     * the queuedWrites buffer is emptied.  This ensures that writes continue
<i class="no-highlight">2781</i>&nbsp;     * to execute on file systems which block all IO calls during an fsync()
<i class="no-highlight">2782</i>&nbsp;     * call (e.g. ext3).
<i class="no-highlight">2783</i>&nbsp;     */
<b class="fc"><i class="no-highlight">2784</i>&nbsp;    class LogEndFileDescriptor {</b>
<b class="fc"><i class="no-highlight">2785</i>&nbsp;        private RandomAccessFile endOfLogRWFile = null;</b>
<b class="fc"><i class="no-highlight">2786</i>&nbsp;        private RandomAccessFile endOfLogSyncFile = null;</b>
<b class="fc"><i class="no-highlight">2787</i>&nbsp;        private final ReentrantLock fsyncFileSynchronizer = new ReentrantLock();</b>
<i class="no-highlight">2788</i>&nbsp;
<i class="no-highlight">2789</i>&nbsp;        /*
<i class="no-highlight">2790</i>&nbsp;         * Holds all data for writes which have been queued due to their
<i class="no-highlight">2791</i>&nbsp;         * being blocked by an fsync when the original write was attempted.
<i class="no-highlight">2792</i>&nbsp;         * The next thread to execute an fsync or write will execute any
<i class="no-highlight">2793</i>&nbsp;         * queued writes in this buffer.
<i class="no-highlight">2794</i>&nbsp;         * Latch order is fsyncFileSynchronizer, followed by the queuedWrites
<i class="no-highlight">2795</i>&nbsp;         * mutex [ synchronized (queuedWrites) {} ].
<i class="no-highlight">2796</i>&nbsp;         *
<i class="no-highlight">2797</i>&nbsp;         * Default protection for unit tests.
<i class="no-highlight">2798</i>&nbsp;         */
<b class="fc"><i class="no-highlight">2799</i>&nbsp;        private final byte[] queuedWrites =</b>
<b class="fc"><i class="no-highlight">2800</i>&nbsp;            useWriteQueue ? new byte[writeQueueSize] : null;</b>
<i class="no-highlight">2801</i>&nbsp;
<i class="no-highlight">2802</i>&nbsp;        /* Current position in the queuedWrites array. */
<b class="fc"><i class="no-highlight">2803</i>&nbsp;        private int queuedWritesPosition = 0;</b>
<i class="no-highlight">2804</i>&nbsp;
<i class="no-highlight">2805</i>&nbsp;        /* The starting offset on disk of the first byte in queuedWrites. */
<i class="no-highlight">2806</i>&nbsp;        private long qwStartingOffset;
<i class="no-highlight">2807</i>&nbsp;
<i class="no-highlight">2808</i>&nbsp;        /* The file number that the queuedWrites are destined for. */
<b class="fc"><i class="no-highlight">2809</i>&nbsp;        private long qwFileNum = -1;</b>
<i class="no-highlight">2810</i>&nbsp;
<i class="no-highlight">2811</i>&nbsp;        /* For unit tests. */
<i class="no-highlight">2812</i>&nbsp;        void setQueueFileNum(final long qwFileNum) {
<b class="nc"><i class="no-highlight">2813</i>&nbsp;            this.qwFileNum = qwFileNum;</b>
<b class="nc"><i class="no-highlight">2814</i>&nbsp;        }</b>
<i class="no-highlight">2815</i>&nbsp;
<i class="no-highlight">2816</i>&nbsp;        /*
<i class="no-highlight">2817</i>&nbsp;         * Check if fileNo/offset is present in queuedWrites, and if so, fill
<i class="no-highlight">2818</i>&nbsp;         * readBuffer with those bytes.  We theorize that this is needed
<i class="no-highlight">2819</i>&nbsp;         * because HA will be reading at the very end of the log and those
<i class="no-highlight">2820</i>&nbsp;         * writes, if enqueued, may no longer be in LogBuffers in the
<i class="no-highlight">2821</i>&nbsp;         * LogBufferPool.  This might happen in the case of lots of concurrent
<i class="no-highlight">2822</i>&nbsp;         * non-synchronous writes (with synchronous commits) which become
<i class="no-highlight">2823</i>&nbsp;         * enqueued in the queuedWrites cache, but cycle out of the LBP.  In
<i class="no-highlight">2824</i>&nbsp;         * general, using synchronous commits with HA is a bad idea.
<i class="no-highlight">2825</i>&nbsp;         *
<i class="no-highlight">2826</i>&nbsp;         * Default protection for unit tests.
<i class="no-highlight">2827</i>&nbsp;         * @return true if more data was available. If so, the read buffer
<i class="no-highlight">2828</i>&nbsp;         * will be filled up.
<i class="no-highlight">2829</i>&nbsp;         */
<i class="no-highlight">2830</i>&nbsp;        /* private */
<i class="no-highlight">2831</i>&nbsp;        boolean checkWriteCache(final ByteBuffer readBuffer,
<i class="no-highlight">2832</i>&nbsp;                                final long requestedOffset,
<i class="no-highlight">2833</i>&nbsp;                                final long fileNum) {
<i class="no-highlight">2834</i>&nbsp;
<b class="fc"><i class="no-highlight">2835</i>&nbsp;            int pos = readBuffer.position();</b>
<b class="fc"><i class="no-highlight">2836</i>&nbsp;            int targetBufSize = readBuffer.limit() - pos;</b>
<b class="fc"><i class="no-highlight">2837</i>&nbsp;            synchronized (queuedWrites) {</b>
<b class="fc"><i class="no-highlight">2838</i>&nbsp;                if (qwFileNum != fileNum) {</b>
<b class="fc"><i class="no-highlight">2839</i>&nbsp;                    return false;</b>
<i class="no-highlight">2840</i>&nbsp;                }
<i class="no-highlight">2841</i>&nbsp;
<b class="nc"><i class="no-highlight">2842</i>&nbsp;                if (queuedWritesPosition == 0) {</b>
<b class="nc"><i class="no-highlight">2843</i>&nbsp;                    return false;</b>
<i class="no-highlight">2844</i>&nbsp;                }
<i class="no-highlight">2845</i>&nbsp;
<b class="nc"><i class="no-highlight">2846</i>&nbsp;                if (requestedOffset &lt; qwStartingOffset ||</b>
<i class="no-highlight">2847</i>&nbsp;                    (qwStartingOffset + queuedWritesPosition) &lt;=
<i class="no-highlight">2848</i>&nbsp;                    requestedOffset) {
<b class="nc"><i class="no-highlight">2849</i>&nbsp;                    return false;</b>
<i class="no-highlight">2850</i>&nbsp;                }
<i class="no-highlight">2851</i>&nbsp;
<i class="no-highlight">2852</i>&nbsp;                /* We have the bytes available. */
<b class="nc"><i class="no-highlight">2853</i>&nbsp;                int nBytesToCopy = (int)</b>
<i class="no-highlight">2854</i>&nbsp;                    (queuedWritesPosition -
<i class="no-highlight">2855</i>&nbsp;                     (requestedOffset - qwStartingOffset));
<b class="nc"><i class="no-highlight">2856</i>&nbsp;                nBytesToCopy = Math.min(nBytesToCopy, targetBufSize);</b>
<b class="nc"><i class="no-highlight">2857</i>&nbsp;                readBuffer.put(queuedWrites,</b>
<i class="no-highlight">2858</i>&nbsp;                               (int) (requestedOffset - qwStartingOffset),
<i class="no-highlight">2859</i>&nbsp;                               nBytesToCopy);
<b class="nc"><i class="no-highlight">2860</i>&nbsp;                nBytesReadFromWriteQueue.add(nBytesToCopy);</b>
<b class="nc"><i class="no-highlight">2861</i>&nbsp;                nReadsFromWriteQueue.increment();</b>
<b class="nc"><i class="no-highlight">2862</i>&nbsp;                return true;</b>
<b class="nc"><i class="no-highlight">2863</i>&nbsp;            }</b>
<i class="no-highlight">2864</i>&nbsp;        }
<i class="no-highlight">2865</i>&nbsp;
<i class="no-highlight">2866</i>&nbsp;        /*
<i class="no-highlight">2867</i>&nbsp;         * Enqueue a blocked write call for later execution by the next thread
<i class="no-highlight">2868</i>&nbsp;         * to do either an fsync or write call. fsyncFileSynchronizer is not
<i class="no-highlight">2869</i>&nbsp;         * held when this is called.
<i class="no-highlight">2870</i>&nbsp;         *
<i class="no-highlight">2871</i>&nbsp;         * Default protection for unit tests.
<i class="no-highlight">2872</i>&nbsp;         */
<i class="no-highlight">2873</i>&nbsp;        /* private */
<i class="no-highlight">2874</i>&nbsp;        boolean enqueueWrite(final long fileNum,
<i class="no-highlight">2875</i>&nbsp;                             final byte[] data,
<i class="no-highlight">2876</i>&nbsp;                             final long destOffset,
<i class="no-highlight">2877</i>&nbsp;                             final int arrayOffset,
<i class="no-highlight">2878</i>&nbsp;                             final int size)
<i class="no-highlight">2879</i>&nbsp;            throws DatabaseException {
<i class="no-highlight">2880</i>&nbsp;
<b class="nc"><i class="no-highlight">2881</i>&nbsp;            assert !fsyncFileSynchronizer.isHeldByCurrentThread();</b>
<i class="no-highlight">2882</i>&nbsp;
<b class="nc"><i class="no-highlight">2883</i>&nbsp;            for (int i = 0; i &lt; 2; i++) {</b>
<i class="no-highlight">2884</i>&nbsp;                try {
<b class="nc"><i class="no-highlight">2885</i>&nbsp;                    enqueueWrite1(fileNum, data, destOffset,</b>
<i class="no-highlight">2886</i>&nbsp;                                  arrayOffset, size);
<b class="nc"><i class="no-highlight">2887</i>&nbsp;                    return true;</b>
<b class="nc"><i class="no-highlight">2888</i>&nbsp;                } catch (RelatchRequiredException RE) {</b>
<b class="nc"><i class="no-highlight">2889</i>&nbsp;                    dequeuePendingWrites();</b>
<i class="no-highlight">2890</i>&nbsp;                }
<i class="no-highlight">2891</i>&nbsp;            }
<i class="no-highlight">2892</i>&nbsp;
<i class="no-highlight">2893</i>&nbsp;            /* Give up after two tries. */
<b class="nc"><i class="no-highlight">2894</i>&nbsp;            nWriteQueueOverflowFailures.increment();</b>
<b class="nc"><i class="no-highlight">2895</i>&nbsp;            return false;</b>
<i class="no-highlight">2896</i>&nbsp;        }
<i class="no-highlight">2897</i>&nbsp;
<i class="no-highlight">2898</i>&nbsp;        private void enqueueWrite1(final long fileNum,
<i class="no-highlight">2899</i>&nbsp;                                   final byte[] data,
<i class="no-highlight">2900</i>&nbsp;                                   final long destOffset,
<i class="no-highlight">2901</i>&nbsp;                                   final int arrayOffset,
<i class="no-highlight">2902</i>&nbsp;                                   final int size)
<i class="no-highlight">2903</i>&nbsp;            throws RelatchRequiredException, DatabaseException {
<i class="no-highlight">2904</i>&nbsp;
<i class="no-highlight">2905</i>&nbsp;            /*
<i class="no-highlight">2906</i>&nbsp;             * The queuedWrites queue only ever holds writes for a single file.
<i class="no-highlight">2907</i>&nbsp;             *
<i class="no-highlight">2908</i>&nbsp;             * This check is safe because qwFileNum can only ever change inside
<i class="no-highlight">2909</i>&nbsp;             * enqueueWrite which can only ever be called while the Log Write
<i class="no-highlight">2910</i>&nbsp;             * Latch is held.
<i class="no-highlight">2911</i>&nbsp;             *
<i class="no-highlight">2912</i>&nbsp;             * NOTE: We believe the commented out second condition is safe
<i class="no-highlight">2913</i>&nbsp;             * to add to the code if we ever see contention with this call to
<i class="no-highlight">2914</i>&nbsp;             * dequeuePendingWrites against an fsync.  Here is the reasoning:
<i class="no-highlight">2915</i>&nbsp;             *
<i class="no-highlight">2916</i>&nbsp;             * queuedWritesPosition is changed in two places: (1) enqueueWrite1
<i class="no-highlight">2917</i>&nbsp;             * where it is incremented, and (2) dequeuePendingWrites1 where it
<i class="no-highlight">2918</i>&nbsp;             * is zeroed. Both of these places are proected by the queuedWrites
<i class="no-highlight">2919</i>&nbsp;             * mutex.  The zero&#39;ing (2) will only make the dequeue unnecessary
<i class="no-highlight">2920</i>&nbsp;             * so the extra commented out check below is safe since it will
<i class="no-highlight">2921</i>&nbsp;             * only result in eliminating an unnecessary dequeuePendingWrites
<i class="no-highlight">2922</i>&nbsp;             * call.
<i class="no-highlight">2923</i>&nbsp;             */
<b class="nc"><i class="no-highlight">2924</i>&nbsp;            if (qwFileNum &lt; fileNum /* &amp;&amp; queuedWritesPosition &gt; 0 */) {</b>
<b class="nc"><i class="no-highlight">2925</i>&nbsp;                dequeuePendingWrites();</b>
<b class="nc"><i class="no-highlight">2926</i>&nbsp;                qwFileNum = fileNum;</b>
<i class="no-highlight">2927</i>&nbsp;            }
<i class="no-highlight">2928</i>&nbsp;
<b class="nc"><i class="no-highlight">2929</i>&nbsp;            synchronized (queuedWrites) {</b>
<b class="nc"><i class="no-highlight">2930</i>&nbsp;                boolean overflow =</b>
<b class="nc"><i class="no-highlight">2931</i>&nbsp;                    (writeQueueSize - queuedWritesPosition) &lt; size;</b>
<b class="nc"><i class="no-highlight">2932</i>&nbsp;                if (overflow) {</b>
<b class="nc"><i class="no-highlight">2933</i>&nbsp;                    nWriteQueueOverflow.increment();</b>
<i class="no-highlight">2934</i>&nbsp;
<i class="no-highlight">2935</i>&nbsp;                    /*
<i class="no-highlight">2936</i>&nbsp;                     * Since we can&#39;t write this &quot;write call&quot; into the
<i class="no-highlight">2937</i>&nbsp;                     * ByteBuffer without overflowing, we will try to dequeue
<i class="no-highlight">2938</i>&nbsp;                     * all current writes in the buffer.  But that requires
<i class="no-highlight">2939</i>&nbsp;                     * holding the fsyncFileSynchronizer latch first which
<i class="no-highlight">2940</i>&nbsp;                     * would be latching out of order relative to the
<i class="no-highlight">2941</i>&nbsp;                     * queuedWrites mutex.
<i class="no-highlight">2942</i>&nbsp;                     */
<b class="nc"><i class="no-highlight">2943</i>&nbsp;                    throw RelatchRequiredException.relatchRequiredException;</b>
<i class="no-highlight">2944</i>&nbsp;                }
<i class="no-highlight">2945</i>&nbsp;
<b class="nc"><i class="no-highlight">2946</i>&nbsp;                assert qwFileNum == fileNum;</b>
<b class="nc"><i class="no-highlight">2947</i>&nbsp;                int curPos = queuedWritesPosition;</b>
<b class="nc"><i class="no-highlight">2948</i>&nbsp;                if (curPos == 0) {</b>
<i class="no-highlight">2949</i>&nbsp;
<i class="no-highlight">2950</i>&nbsp;                    /*
<i class="no-highlight">2951</i>&nbsp;                     * This is the first entry in queue.  Set qwStartingOffset.
<i class="no-highlight">2952</i>&nbsp;                     */
<b class="nc"><i class="no-highlight">2953</i>&nbsp;                    qwStartingOffset = destOffset;</b>
<i class="no-highlight">2954</i>&nbsp;                }
<i class="no-highlight">2955</i>&nbsp;
<b class="nc"><i class="no-highlight">2956</i>&nbsp;                if (curPos + qwStartingOffset != destOffset) {</b>
<b class="nc"><i class="no-highlight">2957</i>&nbsp;                    throw new EnvironmentFailureException</b>
<b class="nc"><i class="no-highlight">2958</i>&nbsp;                        (envImpl, EnvironmentFailureReason.LOG_INTEGRITY,</b>
<i class="no-highlight">2959</i>&nbsp;                         &quot;non-consecutive writes queued. &quot; +
<i class="no-highlight">2960</i>&nbsp;                         &quot;qwPos=&quot; + queuedWritesPosition +
<i class="no-highlight">2961</i>&nbsp;                         &quot; write destOffset=&quot; + destOffset);
<i class="no-highlight">2962</i>&nbsp;                }
<i class="no-highlight">2963</i>&nbsp;
<b class="nc"><i class="no-highlight">2964</i>&nbsp;                System.arraycopy(data, arrayOffset,</b>
<i class="no-highlight">2965</i>&nbsp;                                 queuedWrites, queuedWritesPosition,
<i class="no-highlight">2966</i>&nbsp;                                 size);
<b class="nc"><i class="no-highlight">2967</i>&nbsp;                queuedWritesPosition += size;</b>
<b class="nc"><i class="no-highlight">2968</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2969</i>&nbsp;        }</b>
<i class="no-highlight">2970</i>&nbsp;
<i class="no-highlight">2971</i>&nbsp;        /**
<i class="no-highlight">2972</i>&nbsp;         * Returns whether anything is in the write queue.
<i class="no-highlight">2973</i>&nbsp;         */
<i class="no-highlight">2974</i>&nbsp;        boolean hasQueuedWrites() {
<b class="nc"><i class="no-highlight">2975</i>&nbsp;            return queuedWritesPosition &gt; 0;</b>
<i class="no-highlight">2976</i>&nbsp;        }
<i class="no-highlight">2977</i>&nbsp;
<i class="no-highlight">2978</i>&nbsp;        /*
<i class="no-highlight">2979</i>&nbsp;         * Execute pending writes.  Assumes fsyncFileSynchronizer is not held.
<i class="no-highlight">2980</i>&nbsp;         */
<i class="no-highlight">2981</i>&nbsp;        private void dequeuePendingWrites()
<i class="no-highlight">2982</i>&nbsp;            throws DatabaseException {
<i class="no-highlight">2983</i>&nbsp;
<b class="nc"><i class="no-highlight">2984</i>&nbsp;            assert !fsyncFileSynchronizer.isHeldByCurrentThread();</b>
<i class="no-highlight">2985</i>&nbsp;
<b class="nc"><i class="no-highlight">2986</i>&nbsp;            fsyncFileSynchronizer.lock();</b>
<i class="no-highlight">2987</i>&nbsp;            try {
<b class="nc"><i class="no-highlight">2988</i>&nbsp;                dequeuePendingWrites1();</b>
<i class="no-highlight">2989</i>&nbsp;            } finally {
<b class="nc"><i class="no-highlight">2990</i>&nbsp;                fsyncFileSynchronizer.unlock();</b>
<b class="nc"><i class="no-highlight">2991</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">2992</i>&nbsp;        }</b>
<i class="no-highlight">2993</i>&nbsp;
<i class="no-highlight">2994</i>&nbsp;        /*
<i class="no-highlight">2995</i>&nbsp;         * Execute pending writes.  Assumes fsyncFileSynchronizer is held.
<i class="no-highlight">2996</i>&nbsp;         */
<i class="no-highlight">2997</i>&nbsp;        private void dequeuePendingWrites1()
<i class="no-highlight">2998</i>&nbsp;            throws DatabaseException {
<i class="no-highlight">2999</i>&nbsp;
<b class="fc"><i class="no-highlight">3000</i>&nbsp;            assert fsyncFileSynchronizer.isHeldByCurrentThread();</b>
<i class="no-highlight">3001</i>&nbsp;
<i class="no-highlight">3002</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">3003</i>&nbsp;                synchronized (queuedWrites) {</b>
<i class="no-highlight">3004</i>&nbsp;                    /* Nothing to see here.  Move along. */
<b class="fc"><i class="no-highlight">3005</i>&nbsp;                    if (queuedWritesPosition == 0) {</b>
<b class="fc"><i class="no-highlight">3006</i>&nbsp;                        return;</b>
<i class="no-highlight">3007</i>&nbsp;                    }
<i class="no-highlight">3008</i>&nbsp;
<b class="nc"><i class="no-highlight">3009</i>&nbsp;                    RandomAccessFile file = getWritableFile(qwFileNum, false);</b>
<b class="nc"><i class="no-highlight">3010</i>&nbsp;                    synchronized (file) {</b>
<b class="nc"><i class="no-highlight">3011</i>&nbsp;                        file.seek(qwStartingOffset);</b>
<b class="nc"><i class="no-highlight">3012</i>&nbsp;                        file.write(queuedWrites, 0, queuedWritesPosition);</b>
<b class="nc"><i class="no-highlight">3013</i>&nbsp;                        nBytesWrittenFromWriteQueue.add(queuedWritesPosition);</b>
<b class="nc"><i class="no-highlight">3014</i>&nbsp;                        nWritesFromWriteQueue.increment();</b>
<b class="nc"><i class="no-highlight">3015</i>&nbsp;                        if (VERIFY_CHECKSUMS) {</b>
<b class="nc"><i class="no-highlight">3016</i>&nbsp;                            file.seek(qwStartingOffset);</b>
<b class="nc"><i class="no-highlight">3017</i>&nbsp;                            file.read(queuedWrites, 0, queuedWritesPosition);</b>
<b class="nc"><i class="no-highlight">3018</i>&nbsp;                            ByteBuffer bb =</b>
<b class="nc"><i class="no-highlight">3019</i>&nbsp;                                ByteBuffer.allocate(queuedWritesPosition);</b>
<b class="nc"><i class="no-highlight">3020</i>&nbsp;                            bb.put(queuedWrites, 0, queuedWritesPosition);</b>
<b class="nc"><i class="no-highlight">3021</i>&nbsp;                            bb.position(0);</b>
<b class="nc"><i class="no-highlight">3022</i>&nbsp;                            verifyChecksums</b>
<i class="no-highlight">3023</i>&nbsp;                                (bb, qwStartingOffset, &quot;post-write&quot;);
<i class="no-highlight">3024</i>&nbsp;                        }
<b class="nc"><i class="no-highlight">3025</i>&nbsp;                    }</b>
<i class="no-highlight">3026</i>&nbsp;
<i class="no-highlight">3027</i>&nbsp;                    /* We flushed the queue.  Reset the buffer. */
<b class="nc"><i class="no-highlight">3028</i>&nbsp;                    queuedWritesPosition = 0;</b>
<b class="nc"><i class="no-highlight">3029</i>&nbsp;                }</b>
<b class="nc"><i class="no-highlight">3030</i>&nbsp;            } catch (IOException e) {</b>
<b class="nc"><i class="no-highlight">3031</i>&nbsp;                throw new LogWriteException</b>
<b class="nc"><i class="no-highlight">3032</i>&nbsp;                    (envImpl, &quot;IOException during fsync&quot;, e);</b>
<b class="nc"><i class="no-highlight">3033</i>&nbsp;            }</b>
<b class="nc"><i class="no-highlight">3034</i>&nbsp;        }</b>
<i class="no-highlight">3035</i>&nbsp;
<i class="no-highlight">3036</i>&nbsp;        /**
<i class="no-highlight">3037</i>&nbsp;         * getWritableFile must be called under the log write latch.
<i class="no-highlight">3038</i>&nbsp;         *
<i class="no-highlight">3039</i>&nbsp;         * Typically, endOfLogRWFile is not null.  Hence the
<i class="no-highlight">3040</i>&nbsp;         * fsyncFileSynchronizer does not need to be locked (which would
<i class="no-highlight">3041</i>&nbsp;         * block the write queue from operating.
<i class="no-highlight">3042</i>&nbsp;         */
<i class="no-highlight">3043</i>&nbsp;        private RandomAccessFile getWritableFile(final long fileNumber,
<i class="no-highlight">3044</i>&nbsp;                                                 final boolean doLock) {
<i class="no-highlight">3045</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">3046</i>&nbsp;                if (endOfLogRWFile == null) {</b>
<i class="no-highlight">3047</i>&nbsp;
<i class="no-highlight">3048</i>&nbsp;                    /*
<i class="no-highlight">3049</i>&nbsp;                     * We need to make a file descriptor for the end of the
<i class="no-highlight">3050</i>&nbsp;                     * log.  This is guaranteed to be called under the log
<i class="no-highlight">3051</i>&nbsp;                     * write latch.
<i class="no-highlight">3052</i>&nbsp;                     *
<i class="no-highlight">3053</i>&nbsp;                     * Protect both the RWFile and SyncFile under this lock,
<i class="no-highlight">3054</i>&nbsp;                     * to avoid a race for creating the file and writing the
<i class="no-highlight">3055</i>&nbsp;                     * header.  [#20732]
<i class="no-highlight">3056</i>&nbsp;                     */
<b class="fc"><i class="no-highlight">3057</i>&nbsp;                    if (doLock) {</b>
<b class="fc"><i class="no-highlight">3058</i>&nbsp;                        fsyncFileSynchronizer.lock();</b>
<i class="no-highlight">3059</i>&nbsp;                    }
<i class="no-highlight">3060</i>&nbsp;                    try {
<b class="fc"><i class="no-highlight">3061</i>&nbsp;                        endOfLogRWFile =</b>
<b class="fc"><i class="no-highlight">3062</i>&nbsp;                            makeFileHandle(fileNumber,</b>
<b class="fc"><i class="no-highlight">3063</i>&nbsp;                                           getAppropriateReadWriteMode()).</b>
<b class="fc"><i class="no-highlight">3064</i>&nbsp;                            getFile();</b>
<b class="fc"><i class="no-highlight">3065</i>&nbsp;                        endOfLogSyncFile =</b>
<b class="fc"><i class="no-highlight">3066</i>&nbsp;                            makeFileHandle(fileNumber,</b>
<b class="fc"><i class="no-highlight">3067</i>&nbsp;                                           getAppropriateReadWriteMode()).</b>
<b class="fc"><i class="no-highlight">3068</i>&nbsp;                            getFile();</b>
<i class="no-highlight">3069</i>&nbsp;                    } finally {
<b class="fc"><i class="no-highlight">3070</i>&nbsp;                        if (doLock) {</b>
<b class="fc"><i class="no-highlight">3071</i>&nbsp;                            fsyncFileSynchronizer.unlock();</b>
<i class="no-highlight">3072</i>&nbsp;                        }
<b class="nc"><i class="no-highlight">3073</i>&nbsp;                    }</b>
<i class="no-highlight">3074</i>&nbsp;                }
<i class="no-highlight">3075</i>&nbsp;
<b class="fc"><i class="no-highlight">3076</i>&nbsp;                return endOfLogRWFile;</b>
<b class="nc"><i class="no-highlight">3077</i>&nbsp;            } catch (Exception e) {</b>
<i class="no-highlight">3078</i>&nbsp;
<i class="no-highlight">3079</i>&nbsp;                /*
<i class="no-highlight">3080</i>&nbsp;                 * If we can&#39;t get a write channel, we need to invalidate the
<i class="no-highlight">3081</i>&nbsp;                 * environment.
<i class="no-highlight">3082</i>&nbsp;                 */
<b class="nc"><i class="no-highlight">3083</i>&nbsp;                throw new EnvironmentFailureException</b>
<b class="nc"><i class="no-highlight">3084</i>&nbsp;                    (envImpl, EnvironmentFailureReason.LOG_INTEGRITY, e);</b>
<i class="no-highlight">3085</i>&nbsp;            }
<i class="no-highlight">3086</i>&nbsp;        }
<i class="no-highlight">3087</i>&nbsp;
<i class="no-highlight">3088</i>&nbsp;        /**
<i class="no-highlight">3089</i>&nbsp;         * FSync the log file that makes up the end of the log.
<i class="no-highlight">3090</i>&nbsp;         */
<i class="no-highlight">3091</i>&nbsp;        private void force()
<i class="no-highlight">3092</i>&nbsp;            throws DatabaseException, IOException {
<b class="fc"><i class="no-highlight">3093</i>&nbsp;            COUNT_FORCE.incrementAndGet();</b>
<i class="no-highlight">3094</i>&nbsp;
<i class="no-highlight">3095</i>&nbsp;            /*
<i class="no-highlight">3096</i>&nbsp;             * Get a local copy of the end of the log file descriptor, it could
<i class="no-highlight">3097</i>&nbsp;             * change. No need to latch, no harm done if we get an old file
<i class="no-highlight">3098</i>&nbsp;             * descriptor, because we forcibly fsync under the log write latch
<i class="no-highlight">3099</i>&nbsp;             * when we switch files.
<i class="no-highlight">3100</i>&nbsp;             *
<i class="no-highlight">3101</i>&nbsp;             * If there is no current end file descriptor, we know that the log
<i class="no-highlight">3102</i>&nbsp;             * file has flipped to a new file since the fsync was issued.
<i class="no-highlight">3103</i>&nbsp;             */
<b class="fc"><i class="no-highlight">3104</i>&nbsp;            fsyncFileSynchronizer.lock();</b>
<i class="no-highlight">3105</i>&nbsp;            try {
<i class="no-highlight">3106</i>&nbsp;
<i class="no-highlight">3107</i>&nbsp;                /* Flush any queued writes. */
<b class="fc"><i class="no-highlight">3108</i>&nbsp;                if (useWriteQueue) {</b>
<b class="fc"><i class="no-highlight">3109</i>&nbsp;                    dequeuePendingWrites1();</b>
<i class="no-highlight">3110</i>&nbsp;                }
<i class="no-highlight">3111</i>&nbsp;
<b class="fc"><i class="no-highlight">3112</i>&nbsp;                RandomAccessFile file = endOfLogSyncFile;</b>
<b class="fc"><i class="no-highlight">3113</i>&nbsp;                if (file != null) {</b>
<b class="fc"><i class="no-highlight">3114</i>&nbsp;                    bumpWriteCount(&quot;fsync&quot;);</b>
<b class="fc"><i class="no-highlight">3115</i>&nbsp;                    FileChannel ch = file.getChannel();</b>
<i class="no-highlight">3116</i>&nbsp;
<b class="fc"><i class="no-highlight">3117</i>&nbsp;                    long start = System.currentTimeMillis();</b>
<i class="no-highlight">3118</i>&nbsp;                    try {
<b class="fc"><i class="no-highlight">3119</i>&nbsp;                        ch.force(false);</b>
<b class="nc"><i class="no-highlight">3120</i>&nbsp;                    } catch (ClosedChannelException e) {</b>
<i class="no-highlight">3121</i>&nbsp;
<i class="no-highlight">3122</i>&nbsp;                        /*
<i class="no-highlight">3123</i>&nbsp;                         * The channel should never be closed. It may be closed
<i class="no-highlight">3124</i>&nbsp;                         * because of an interrupt received by another thread.
<i class="no-highlight">3125</i>&nbsp;                         * See SR [#10463].
<i class="no-highlight">3126</i>&nbsp;                         */
<b class="nc"><i class="no-highlight">3127</i>&nbsp;                        throw new ThreadInterruptedException</b>
<b class="nc"><i class="no-highlight">3128</i>&nbsp;                            (envImpl,</b>
<i class="no-highlight">3129</i>&nbsp;                             &quot;Channel closed, may be due to thread interrupt&quot;,
<i class="no-highlight">3130</i>&nbsp;                             e);
<b class="fc"><i class="no-highlight">3131</i>&nbsp;                    }</b>
<b class="fc"><i class="no-highlight">3132</i>&nbsp;                    final long fSyncMs = System.currentTimeMillis() - start;</b>
<i class="no-highlight">3133</i>&nbsp;
<b class="fc"><i class="no-highlight">3134</i>&nbsp;                    nLogFSyncs.increment();</b>
<b class="fc"><i class="no-highlight">3135</i>&nbsp;                    nFSyncTime.add(fSyncMs);</b>
<i class="no-highlight">3136</i>&nbsp;
<b class="fc"><i class="no-highlight">3137</i>&nbsp;                    if (nFSyncMaxTime.setMax(fSyncMs) &amp;&amp;</b>
<b class="fc"><i class="no-highlight">3138</i>&nbsp;                        fSyncTimeLimit != 0 &amp;&amp;</b>
<b class="fc"><i class="no-highlight">3139</i>&nbsp;                        fSyncMs &gt; fSyncTimeLimit) {</b>
<i class="no-highlight">3140</i>&nbsp;
<b class="nc"><i class="no-highlight">3141</i>&nbsp;                        LoggerUtils.warning(</b>
<b class="nc"><i class="no-highlight">3142</i>&nbsp;                            envImpl.getLogger(), envImpl,</b>
<b class="nc"><i class="no-highlight">3143</i>&nbsp;                            String.format(</b>
<i class="no-highlight">3144</i>&nbsp;                                &quot;FSync time of %d ms exceeds limit (%d ms)&quot;,
<b class="nc"><i class="no-highlight">3145</i>&nbsp;                                fSyncMs, fSyncTimeLimit));</b>
<i class="no-highlight">3146</i>&nbsp;                    }
<i class="no-highlight">3147</i>&nbsp;
<b class="fc"><i class="no-highlight">3148</i>&nbsp;                    assert EnvironmentImpl.maybeForceYield();</b>
<i class="no-highlight">3149</i>&nbsp;                }
<i class="no-highlight">3150</i>&nbsp;
<i class="no-highlight">3151</i>&nbsp;                /* Flush any writes which were queued while fsync&#39;ing. */
<b class="fc"><i class="no-highlight">3152</i>&nbsp;                if (useWriteQueue) {</b>
<b class="fc"><i class="no-highlight">3153</i>&nbsp;                    dequeuePendingWrites1();</b>
<i class="no-highlight">3154</i>&nbsp;                }
<i class="no-highlight">3155</i>&nbsp;            } finally {
<b class="fc"><i class="no-highlight">3156</i>&nbsp;                fsyncFileSynchronizer.unlock();</b>
<b class="fc"><i class="no-highlight">3157</i>&nbsp;            }</b>
<b class="fc"><i class="no-highlight">3158</i>&nbsp;        }</b>
<i class="no-highlight">3159</i>&nbsp;
<i class="no-highlight">3160</i>&nbsp;        /**
<i class="no-highlight">3161</i>&nbsp;         * Close the end of the log file descriptor. Use atomic assignment to
<i class="no-highlight">3162</i>&nbsp;         * ensure that we won&#39;t force and close on the same descriptor.
<i class="no-highlight">3163</i>&nbsp;         */
<i class="no-highlight">3164</i>&nbsp;        void close()
<i class="no-highlight">3165</i>&nbsp;            throws IOException {
<i class="no-highlight">3166</i>&nbsp;
<i class="no-highlight">3167</i>&nbsp;            /*
<i class="no-highlight">3168</i>&nbsp;             * Protect both the RWFile and SyncFile under this lock out of
<i class="no-highlight">3169</i>&nbsp;             * paranoia, although we don&#39;t expect two threads to call close
<i class="no-highlight">3170</i>&nbsp;             * concurrently.  [#20732]
<i class="no-highlight">3171</i>&nbsp;             */
<b class="fc"><i class="no-highlight">3172</i>&nbsp;            fsyncFileSynchronizer.lock();</b>
<i class="no-highlight">3173</i>&nbsp;            try {
<b class="fc"><i class="no-highlight">3174</i>&nbsp;                IOException firstException = null;</b>
<b class="fc"><i class="no-highlight">3175</i>&nbsp;                if (endOfLogRWFile != null) {</b>
<b class="fc"><i class="no-highlight">3176</i>&nbsp;                    RandomAccessFile file = endOfLogRWFile;</b>
<i class="no-highlight">3177</i>&nbsp;
<i class="no-highlight">3178</i>&nbsp;                    /*
<i class="no-highlight">3179</i>&nbsp;                     * Null out so that other threads know endOfLogRWFile is no
<i class="no-highlight">3180</i>&nbsp;                     * longer available.
<i class="no-highlight">3181</i>&nbsp;                     */
<b class="fc"><i class="no-highlight">3182</i>&nbsp;                    endOfLogRWFile = null;</b>
<i class="no-highlight">3183</i>&nbsp;                    try {
<b class="fc"><i class="no-highlight">3184</i>&nbsp;                        file.close();</b>
<b class="nc"><i class="no-highlight">3185</i>&nbsp;                    } catch (IOException e) {</b>
<i class="no-highlight">3186</i>&nbsp;                        /* Save this exception, so we can try second close. */
<b class="nc"><i class="no-highlight">3187</i>&nbsp;                        firstException = e;</b>
<b class="fc"><i class="no-highlight">3188</i>&nbsp;                    }</b>
<i class="no-highlight">3189</i>&nbsp;                }
<b class="fc"><i class="no-highlight">3190</i>&nbsp;                if (endOfLogSyncFile != null) {</b>
<b class="fc"><i class="no-highlight">3191</i>&nbsp;                    RandomAccessFile file = endOfLogSyncFile;</b>
<i class="no-highlight">3192</i>&nbsp;
<i class="no-highlight">3193</i>&nbsp;                    /*
<i class="no-highlight">3194</i>&nbsp;                     * Null out so that other threads know endOfLogSyncFile is
<i class="no-highlight">3195</i>&nbsp;                     * no longer available.
<i class="no-highlight">3196</i>&nbsp;                     */
<b class="fc"><i class="no-highlight">3197</i>&nbsp;                    endOfLogSyncFile = null;</b>
<b class="fc"><i class="no-highlight">3198</i>&nbsp;                    file.close();</b>
<i class="no-highlight">3199</i>&nbsp;                }
<i class="no-highlight">3200</i>&nbsp;
<b class="fc"><i class="no-highlight">3201</i>&nbsp;                if (firstException != null) {</b>
<b class="nc"><i class="no-highlight">3202</i>&nbsp;                    throw firstException;</b>
<i class="no-highlight">3203</i>&nbsp;                }
<i class="no-highlight">3204</i>&nbsp;            } finally {
<b class="fc"><i class="no-highlight">3205</i>&nbsp;                fsyncFileSynchronizer.unlock();</b>
<b class="fc"><i class="no-highlight">3206</i>&nbsp;            }</b>
<b class="fc"><i class="no-highlight">3207</i>&nbsp;        }</b>
<i class="no-highlight">3208</i>&nbsp;    }
<i class="no-highlight">3209</i>&nbsp;
<i class="no-highlight">3210</i>&nbsp;    /*
<i class="no-highlight">3211</i>&nbsp;     * Generate IOExceptions for testing.
<i class="no-highlight">3212</i>&nbsp;     */
<i class="no-highlight">3213</i>&nbsp;
<i class="no-highlight">3214</i>&nbsp;    /* Testing switch. public so others can read the value. */
<i class="no-highlight">3215</i>&nbsp;    public static final boolean LOGWRITE_EXCEPTION_TESTING;
<b class="fc"><i class="no-highlight">3216</i>&nbsp;    private static String RRET_PROPERTY_NAME = &quot;je.logwrite.exception.testing&quot;;</b>
<i class="no-highlight">3217</i>&nbsp;
<i class="no-highlight">3218</i>&nbsp;    static {
<b class="fc"><i class="no-highlight">3219</i>&nbsp;        LOGWRITE_EXCEPTION_TESTING =</b>
<b class="fc"><i class="no-highlight">3220</i>&nbsp;            (System.getProperty(RRET_PROPERTY_NAME) != null);</b>
<i class="no-highlight">3221</i>&nbsp;    }
<i class="no-highlight">3222</i>&nbsp;
<i class="no-highlight">3223</i>&nbsp;    /* Max write counter value. */
<i class="no-highlight">3224</i>&nbsp;    private static final int LOGWRITE_EXCEPTION_MAX = 100;
<i class="no-highlight">3225</i>&nbsp;    /* Current write counter value. */
<b class="fc"><i class="no-highlight">3226</i>&nbsp;    private int logWriteExceptionCounter = 0;</b>
<i class="no-highlight">3227</i>&nbsp;    /* Whether an exception has been thrown. */
<b class="fc"><i class="no-highlight">3228</i>&nbsp;    private boolean logWriteExceptionThrown = false;</b>
<i class="no-highlight">3229</i>&nbsp;    /* Random number generator. */
<b class="fc"><i class="no-highlight">3230</i>&nbsp;    private Random logWriteExceptionRandom = null;</b>
<i class="no-highlight">3231</i>&nbsp;
<i class="no-highlight">3232</i>&nbsp;    private void generateLogWriteException(RandomAccessFile file,
<i class="no-highlight">3233</i>&nbsp;                                           ByteBuffer data,
<i class="no-highlight">3234</i>&nbsp;                                           long destOffset,
<i class="no-highlight">3235</i>&nbsp;                                           long fileNum)
<i class="no-highlight">3236</i>&nbsp;        throws DatabaseException, IOException {
<i class="no-highlight">3237</i>&nbsp;
<b class="nc"><i class="no-highlight">3238</i>&nbsp;        if (logWriteExceptionThrown) {</b>
<b class="nc"><i class="no-highlight">3239</i>&nbsp;            (new Exception(&quot;Write after LogWriteException&quot;)).</b>
<b class="nc"><i class="no-highlight">3240</i>&nbsp;                printStackTrace();</b>
<i class="no-highlight">3241</i>&nbsp;        }
<b class="nc"><i class="no-highlight">3242</i>&nbsp;        logWriteExceptionCounter += 1;</b>
<b class="nc"><i class="no-highlight">3243</i>&nbsp;        if (logWriteExceptionCounter &gt;= LOGWRITE_EXCEPTION_MAX) {</b>
<b class="nc"><i class="no-highlight">3244</i>&nbsp;            logWriteExceptionCounter = 0;</b>
<i class="no-highlight">3245</i>&nbsp;        }
<b class="nc"><i class="no-highlight">3246</i>&nbsp;        if (logWriteExceptionRandom == null) {</b>
<b class="nc"><i class="no-highlight">3247</i>&nbsp;            logWriteExceptionRandom = new Random(System.currentTimeMillis());</b>
<i class="no-highlight">3248</i>&nbsp;        }
<b class="nc"><i class="no-highlight">3249</i>&nbsp;        if (logWriteExceptionCounter ==</b>
<b class="nc"><i class="no-highlight">3250</i>&nbsp;            logWriteExceptionRandom.nextInt(LOGWRITE_EXCEPTION_MAX)) {</b>
<b class="nc"><i class="no-highlight">3251</i>&nbsp;            int len = logWriteExceptionRandom.nextInt(data.remaining());</b>
<b class="nc"><i class="no-highlight">3252</i>&nbsp;            if (len &gt; 0) {</b>
<b class="nc"><i class="no-highlight">3253</i>&nbsp;                byte[] a = new byte[len];</b>
<b class="nc"><i class="no-highlight">3254</i>&nbsp;                data.get(a, 0, len);</b>
<b class="nc"><i class="no-highlight">3255</i>&nbsp;                ByteBuffer buf = ByteBuffer.wrap(a);</b>
<b class="nc"><i class="no-highlight">3256</i>&nbsp;                writeToFile(file, buf, destOffset, fileNum,</b>
<i class="no-highlight">3257</i>&nbsp;                            false /*flushRequired*/);
<i class="no-highlight">3258</i>&nbsp;            }
<b class="nc"><i class="no-highlight">3259</i>&nbsp;            logWriteExceptionThrown = true;</b>
<b class="nc"><i class="no-highlight">3260</i>&nbsp;            throw new IOException(&quot;Randomly generated for testing&quot;);</b>
<i class="no-highlight">3261</i>&nbsp;        }
<b class="nc"><i class="no-highlight">3262</i>&nbsp;    }</b>
<i class="no-highlight">3263</i>&nbsp;
<i class="no-highlight">3264</i>&nbsp;    /**
<i class="no-highlight">3265</i>&nbsp;     * The factory interface for creating RandomAccessFiles.  For production
<i class="no-highlight">3266</i>&nbsp;     * use, the default factory is always used and a DefaultRandomAccessFile is
<i class="no-highlight">3267</i>&nbsp;     * always created.  For testing, the factory can be overridden to return a
<i class="no-highlight">3268</i>&nbsp;     * subclass of DefaultRandomAccessFile that overrides methods and injects
<i class="no-highlight">3269</i>&nbsp;     * faults, for example.
<i class="no-highlight">3270</i>&nbsp;     */
<i class="no-highlight">3271</i>&nbsp;    public interface FileFactory {
<i class="no-highlight">3272</i>&nbsp;
<i class="no-highlight">3273</i>&nbsp;        /**
<i class="no-highlight">3274</i>&nbsp;         * @param envHome can be used to distinguish environments in a test
<i class="no-highlight">3275</i>&nbsp;         * program that opens multiple environments.  Not for production use.
<i class="no-highlight">3276</i>&nbsp;         *
<i class="no-highlight">3277</i>&nbsp;         * @param fullName the full file name to be passed to the
<i class="no-highlight">3278</i>&nbsp;         * RandomAccessFile constructor.
<i class="no-highlight">3279</i>&nbsp;         *
<i class="no-highlight">3280</i>&nbsp;         * @param mode the file mode to be passed to the RandomAccessFile
<i class="no-highlight">3281</i>&nbsp;         * constructor.
<i class="no-highlight">3282</i>&nbsp;         */
<i class="no-highlight">3283</i>&nbsp;        RandomAccessFile createFile(File envHome, String fullName, String mode)
<i class="no-highlight">3284</i>&nbsp;            throws FileNotFoundException;
<i class="no-highlight">3285</i>&nbsp;    }
<i class="no-highlight">3286</i>&nbsp;
<i class="no-highlight">3287</i>&nbsp;    /**
<i class="no-highlight">3288</i>&nbsp;     * The RandomAccessFile for production use.  Tests that override the
<i class="no-highlight">3289</i>&nbsp;     * default FileFactory should return a RandomAccessFile that subclasses
<i class="no-highlight">3290</i>&nbsp;     * this class to inherit workarounds such as the overridden length method.
<i class="no-highlight">3291</i>&nbsp;     */
<i class="no-highlight">3292</i>&nbsp;    public static class DefaultRandomAccessFile extends RandomAccessFile {
<i class="no-highlight">3293</i>&nbsp;
<i class="no-highlight">3294</i>&nbsp;        public DefaultRandomAccessFile(String fullName, String mode)
<i class="no-highlight">3295</i>&nbsp;            throws FileNotFoundException {
<i class="no-highlight">3296</i>&nbsp;
<b class="fc"><i class="no-highlight">3297</i>&nbsp;            super(fullName, mode);</b>
<b class="fc"><i class="no-highlight">3298</i>&nbsp;        }</b>
<i class="no-highlight">3299</i>&nbsp;
<i class="no-highlight">3300</i>&nbsp;        /**
<i class="no-highlight">3301</i>&nbsp;         * RandomAccessFile.length() is not thread safe and side-effects the
<i class="no-highlight">3302</i>&nbsp;         * file pointer if interrupted in the middle.  It is synchronized here
<i class="no-highlight">3303</i>&nbsp;         * to work around that problem.
<i class="no-highlight">3304</i>&nbsp;         */
<i class="no-highlight">3305</i>&nbsp;        @Override
<i class="no-highlight">3306</i>&nbsp;        public synchronized long length()
<i class="no-highlight">3307</i>&nbsp;            throws IOException {
<i class="no-highlight">3308</i>&nbsp;
<b class="fc"><i class="no-highlight">3309</i>&nbsp;            return super.length();</b>
<i class="no-highlight">3310</i>&nbsp;        }
<i class="no-highlight">3311</i>&nbsp;    }
<i class="no-highlight">3312</i>&nbsp;
<i class="no-highlight">3313</i>&nbsp;    /**
<i class="no-highlight">3314</i>&nbsp;     * The factory instance used to create RandomAccessFiles.  This field is
<i class="no-highlight">3315</i>&nbsp;     * intentionally public and non-static so it may be set by tests.  See
<i class="no-highlight">3316</i>&nbsp;     * FileFactory.
<i class="no-highlight">3317</i>&nbsp;     */
<b class="fc"><i class="no-highlight">3318</i>&nbsp;    public static FileFactory fileFactory = new FileFactory() {</b>
<i class="no-highlight">3319</i>&nbsp;
<i class="no-highlight">3320</i>&nbsp;        public RandomAccessFile createFile(File envHome,
<i class="no-highlight">3321</i>&nbsp;                                           String fullName,
<i class="no-highlight">3322</i>&nbsp;                                           String mode)
<i class="no-highlight">3323</i>&nbsp;            throws FileNotFoundException {
<i class="no-highlight">3324</i>&nbsp;
<b class="fc"><i class="no-highlight">3325</i>&nbsp;            return new DefaultRandomAccessFile(fullName, mode);</b>
<i class="no-highlight">3326</i>&nbsp;        }
<i class="no-highlight">3327</i>&nbsp;    };
<i class="no-highlight">3328</i>&nbsp;}
</div>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
        var codeBlock = document.getElementById('sourceCode');

        if (codeBlock) {
            hljs.highlightBlock(codeBlock);
        }
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2021-04-19 13:44</div>
</div>
</body>
</html>
